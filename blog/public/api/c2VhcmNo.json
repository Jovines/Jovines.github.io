[{"title":".gitignore忽略文件总结","date":"2019-10-03T17:23:00.000Z","author":"Jon","updated":"2019-10-03T17:40:07.952Z","content":"语法归纳1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#               表示此为注释,将被Git忽略*.a             表示忽略所有 .a 结尾的文件!lib.a          表示但lib.a除外/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt bin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件/bin:           表示忽略根目录下的bin文件/*.c:           表示忽略cat.c，不忽略 build/cat.cdebug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj**/foo:         表示忽略/foo,a/foo,a/b/foo等a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等!/bin/run.sh    表示不忽略bin目录下的run.sh文件*.log:          表示忽略所有 .log 文件config.php:     表示忽略当前路径的 config.php 文件 /mtk/           表示过滤整个文件夹*.zip           表示过滤所有.zip文件/mtk/do.c       表示过滤某个具体文件 被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。 需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：!*.zip!/mtk/one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：/mtk/*!/mtk/one.txt 假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！ ----------------------------------------------------------------------------------还有一些规则如下：fd1/*说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； /fd1/*说明：忽略根目录下的 /fd1/ 目录的全部内容； /*!.gitignore!/fw/ /fw/*!/fw/bin/!/fw/sf/说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。\n\n从版本库去除并忽略提交先执行以下任意删除命令123git rm file\t\t\t\t\t\t# 从版本库删除，并删除本地文件git rm --cached file\t\t\t# 从版本库删除文件并保留本地文件git rm -r --cached loggers \t \t# -r 是允许递归删除，当要删除的是文件夹的时候有用\n\n在.gitignore文件中添加提醒.gitignore忽略规则的匹配语法每一行的忽略规则的语法如下：\n\n空格不匹配任意文件，可作为分隔符，可用反斜杠转义\n以“＃”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。\n可以使用标准的glob模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。\n以斜杠”/“开头表示目录；”/“结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；”/“开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。\n以星号”**”通配多个字符，即匹配多个任意字符；使用两个星号”*“ 表示匹配任意中间目录，比如`a//z`可以匹配 a/z, a/b/z 或 a/b/c/z等。\n以问号”?“通配单个字符，即匹配一个任意字符；\n以方括号”[]“包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。\n以叹号”!“表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用”!”规则是不起作用的。也就是说”!”开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用”!”也不会再次被包含。可以使用反斜杠进行转义。\n\n需要谨记：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；\n.gitignore忽略规则的优先级在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：\n\n从命令行中读取可用的忽略规则\n当前目录定义的规则\n父级目录定义的规则，依次递推\n$GIT_DIR/info/exclude 文件中定义的规则\ncore.excludesfile中定义的全局规则\n\n","plink":"https://treeeeeeee.github.io/2019/10/04/gitignore忽略文件总结/"},{"title":"linux后台运行程序命令","date":"2019-10-03T15:50:00.000Z","author":"Jon","updated":"2019-10-03T17:19:08.586Z","content":"linux后台执行命令：&amp;和nohup归纳：ps -ef或者grep查看进程kill XX杀死进程，XX替换为进程PID命令后加&amp;后台运行，但生命周期受窗口限制nohup 命令 &amp;完全后台运行原文链接，本文归纳梳理，便于自己记忆。\n后台运行命令&amp;断开链接或者关闭窗口仍然会终止程序\n\n在命令后面加上&amp; 实现后台运行。例如：\n\n1sh test.sh &amp;\n\n\n\n适合在后台运行的命令有find、费时的排序及一些shell脚本。\n\n需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。\n\n后台运行一样会将结果输出到屏幕上，干扰你的工作。\n\n如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中\n\n\n命令  &gt;  out.file  2&gt;&amp;1  &amp; 1\n这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。\n\n当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它\n(ps -ef | grep 进程号 或者 kill -9 进程号）\n\n\n\nnohup 可退出命令窗口使用\n\n\n使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用\n\n一但把当前控制台关掉(退出帐户时)，作业就会停止运行。\n\nnohup命令可以在你退出帐户之后继续运行相应的进程。\n\nnohup就是不挂起的意思( no hang up)。该命令的一般形式为：\n\n\n\n\n1nohup 命令 &amp;1\n\n如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：\n1nohup command &gt; myout.file 2&gt;&amp;1 &amp;1\n\n注意使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。\n\nctrl + z可以将一个正在前台执行的命令放到后台，并且处于暂停状态。\nctrl+c终止前台命令。\njobs查看当前有多少在后台运行的命令。jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。\n2&gt;&amp;1解析\n\n1command &gt;out.file 2&gt;&amp;1 &amp;1\n\n\ncommand&gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。\n2&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行。\n试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.\n\n","plink":"https://treeeeeeee.github.io/2019/10/03/linux后台运行程序/"},{"title":"错误记录：git: 'pull' is not a git command. See 'git --help'.  Did you mean one of these? \tpull","date":"2019-10-03T15:18:00.000Z","author":"Jon","updated":"2019-10-03T17:21:53.094Z","content":"在我将整个博客源码从windows转移到linux中时\n","plink":"https://treeeeeeee.github.io/2019/10/03/git-pull-is-not-a-git-command-See-git-help-Did-you-mean-one-of-these-pull/"},{"title":"错误记录：System limit for number of file watchers reached","date":"2019-10-03T14:49:00.000Z","author":"Jon","updated":"2019-10-03T17:18:45.320Z","content":"我在执行hexo server -d 时报错Error: ENOSPC: System limit for number of file watchers reached, watch ‘/root/blog/Treeeeeeee.github.io/blog/themes/inside/node_modules/hexo/lib/plugins/tag/index.js’    at FSWatcher.start (internal/fs/watchers.js:165:26)    at Object.watch (fs.js:1258:11)    at createFsWatchInstance (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:38:15)    at setFsWatchListener (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:81:15)    at FSWatcher.NodeFsHandler._watchWithNodeFs (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:233:14)    at FSWatcher.NodeFsHandler._handleFile (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:262:21)    at FSWatcher. (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:495:21)    at FSReqWrap.oncomplete (fs.js:154:5)\n文中说我达到文件监视程序数量的系统限制，不是很明白\n","plink":"https://treeeeeeee.github.io/2019/10/03/System-limit-for-number-of-file-watchers-reached-错误记录/"},{"title":"hexo+admin+windows+linux服务器的综合博客平台","date":"2019-10-03T08:43:00.000Z","author":"Jon","updated":"2019-10-03T17:18:24.392Z","content":"windows下的hexo+github博客搭建博客搭建不多说这里放上大神的知乎，点击自己按照流程来做就好了，下面我做一个归纳整理，也留作备份。\n安装Node.js\n\nwindows下载链接\n\n下载之后一路next就好，环境变量默认会把帮你配好\n\n最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。\n\n也有没有自动配的情况，可以手动配一下。\n\n\n\n添加国内镜像源\n如果没有K X S W(这是啥大家都明白吧)的话，可以使用阿里的国内镜像进行加速。\n12&gt; npm config set registry https://registry.npm.taobao.org&gt;\n\n安装Git\n\nGit的下载链接\n安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。\n安装完成后在命令提示符中输入git --version验证是否安装成功。\n同样如果没有找到版本号需要手动配置\n\n\n注册Github账号\n\n注册地址\n\n注册完成之后进入主页\n\n\n点击新建项目\n\n项目名称是你的github用户名加.github.io \n\n例如: XXXXX.github.io\n同时也可以勾选一下Redme.md\n\n![new p](C:\\data\\Treeeeeeee.github.io\\blog\\source_posts\\hexo-admin-windows-服务器的综合博客平台\\new p.png)\n\n然后按照下面的流程你就可以获得一个最简单的博客\n\n\n\n\n\n\n\n进去之后随便选一个\n\n\n\n\n\n安装Hexo在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在D:\\study\\program\\blog目录下。\n在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。\n定位到该目录下，输入npm i hexo-cli -g安装Hexo。会有几个报错，无视它就行。\n安装完后输入hexo -v验证是否安装成功。\n然后就要初始化我们的网站，输入hexo init初始化文件夹，接着输入npm install安装必备的组件。\n这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以看到我们的博客啦，效果如下：\n\n按ctrl+c关闭本地服务器。\n连接Github与本地首先右键打开git bash，然后输入下面命令：\n12git config --global user.name \"godweiyang\"git config --global user.email \"792321264@qq.com\"\n\n用户名和邮箱根据你注册github的信息自行修改。\n然后生成密钥SSH key：\n1ssh-keygen -t rsa -C \"792321264@qq.com\"\n\n打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。\ngit bash中输入\n1cat ~/.ssh/id_rsa.pub\n\n将输出的内容复制到框中，点击确定保存。\n输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了。\n打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。\n修改最后一行的配置：\n1234deploy:  type: git  repo:   branch: master\n\nrepository或者repo修改为你自己的github项目地址\n\n我这里默认的是使用ssh，如果想使用https点击更换就好了\n\n我推荐使用ssh，毕竟你已经在你的github中添加了你本机的ssh，免得再输密码\n如果不懂ssh可以先使用https，后面我们做服务器的自动git用ssh会更好，如果不需要，而且是在windows下使用的话那就https的吧，没啥关系，windows有记住密码的功能\n\n\n\n写文章、发布文章首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。\n然后输入hexo new post &quot;article title&quot;，新建一篇文章。\n\narticle title 替换成你要写的文章的名字，需要注意一下：\n\n最好使用英文，使用中文的话博客的url会非常长\n\n如果想插入图片的话，打开你的博客目录里面的_config.yml找到post_asset_folder:属性，并复制未true，这样生成一篇新文章时，会在\n12&gt;   \\source\\_posts&gt;\n\n\n\n\n  目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等。这样在文章中插入图片使用相对路径就可以即在本地书写的时候看到图片，又在生成的博客中看到，例如：\n  \n  在文章中直接这样插入，就可以完美插入图片。详细可以借鉴我另外一篇博客\n  \n\n这里推荐一个超好用加方便的markdown编辑软件Typora，而且恰好支持这种图片资源文件，设置一下可以把任意来源图片直接弄到对应文件夹\n\n\n\n\n这样设置以后你不管是从网络上来的图片还是任意地方拖动的进来的图片都会自动给你放到这个文件夹\n\n\n\n\n然后打开D:\\study\\program\\blog\\source\\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。\n编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。\n绑定域名现在默认的域名还是xxx.github.io，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。\n以我的百度云为例，如下图所示，添加两条解析记录：\n\n然后打开你的github博客项目，点击settings，拉到下面Custom domain处，填上你自己的域名，保存：\n\n这时候你的项目根目录应该会出现一个名为CNAME的文件了。如果没有的话，打开你本地博客/source目录，我的是D:\\study\\program\\blog\\source，新建CNAME文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行hexo g、hexo d上传到github。\n备份博客源文件有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。\n\n我的备份方法\n\n随便找个文件夹，右键打开git bash，依次执行以下命令\n123&gt; git clone 你的博客仓库地址&gt; git checkout -b backup&gt;\n\n\n然后删除你拉下来的所有东西文件夹，如果你开了隐藏文件夹也可见的话别把.git文件夹删除了，如果没开就放心删除所有文件吧（看见.git别动就对了）\n然后把你你的整个博客文件夹移动到这里，并删除你博客文件下里面所有叫.gitignore的文件，通常来说，博客源码根目录有一个，主题文件夹里面都有\n\n.gitignore文件是用来说明那些东西不被git push的，具体请自行百度\n\n然后继续依次执行以下命令\n1234&gt; git add .&gt; git commit -s -m &quot;backup&quot;&gt; git push&gt;\n\n\n等待完成就可以在任何地方直接拉下来使用了，在其他地方使用有以下几个要注意的：\n\n环境必须安装这个没得说\n\n如果你是使用shh来部署的项目需要把这台设备的生成的ssh添加到你的github账号里\n\n指的是你前面属性repo :是用的https的还是ssh的\n\n\n\n\n\n其他备份方法(该内容是粘贴复制)\n\n首先在github博客仓库下新建一个分支hexo，然后git clone到本地，把.git文件夹拿出来，放在博客根目录下。\n然后git branch -b hexo切换到hexo分支，然后git add .，然后git commit -m &quot;xxx&quot;，最后git push origin hexo提交就行了。\n\n\n\n博客源代码下载个性化设置（matery主题）常见问题及解答（FAQ）个性化设置|更换主题|效果图\n我的博客地址有什么问题可以在文章下评论留言\ninside主题\n直接下载源码放到你的博客源码目录的themes目录里面，并修改_config.yml文件中theme:属性，然后执行：\n12hexo ghexo s\n\n浏览器访问：localhost:4000 就能直接看到效果了\n\n具体配置我就不详细说明了可以去看主题制作者的博客：链接\n\n\n","plink":"https://treeeeeeee.github.io/2019/10/03/hexo-admin-windows-服务器的综合博客平台/"},{"title":"完美的hexo中插入图片的解决方案","date":"2019-10-01T15:13:00.000Z","updated":"2019-10-03T08:52:42.417Z","content":"完美的hexo中插入图片的解决方案以下内容来自ETRD的《hexo中完美插入本地图片》，摘录整理关键部分，留作备份。\nMarkdown编辑器\nTypora\n\n不需要关注太多markdown语法就能写出比较好看的markdown，支持实时转换\n\n\n\nHexo配置文件的设置 确保你的Hexo的配置文件_config.yml里面有个这个选项配置，并将其置为true\n1post_asset_folder: true\n\n 这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用\n1hexo new\n\n生成一篇新文章时，会在\n1\\source\\_posts\n\n目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等\n\n实际上我通常喜欢自己右键手动去建立一个md文件来写博客，而不使用hexo new命令，此时要达到同样的效果，我同样也需要手动去建立一个同名的文件夹去存放资源，我试过这样做是可行的，并且这样做虽然有点麻烦，但我似乎发现了它的一个优点，那就是当我的文章中没有图片时，我并不需要这个空的资源文件夹。\n有了上面的配置，Hexo在public文件下生成html文件时，会在相应的目录中把那文章对应的资源文件夹中的图片等附件复制过去，例如，这是我生成的一个例子：\n\n安装hexo-asset-image插件你需要安装一个图片路径转换的插件，这个插件名字是hexo-asset-image，我目前安装的是最新的0.03版本，使用如下命令安装插件\n1npm install https://github.com/CodeFalling/hexo-asset-image --save\n\n插件安装完以后，实际上是存放在下面的目录文件夹下\n1\\blog\\node_modules\\hexo-asset-image\n\n想要卸载这个插件怎么处理，我听说直接删掉这个文件夹，反正我这么试过了。\nmd文件的时间标签hexo-asset-image的原理应该是根据Hexo生成html后以时间的为目录的规则，将我们图片的相对地址转换成了生成后与时间对应目录的绝对地址，因此我认为md文件中应该要有时间标签，一来是为了让Hexo根据md的时间标签来确定文章的新旧排序，如果没有时间标签，Hexo会把md文件的修改时间作为发布时间，这显然是不合理的，再者这个时间标签，我想hexo-asset-image也会引用到，在一篇实际的博文中，我的md文件完整的开头是这样的：\n1---title: hexo中完美插入本地图片date: 2017-01-23 11:00:55categories: hexo使用tags: - hexo- 本地图片- hexo-asset-image---\n\n插入图片由于每个md文件都有对应的一个资源文件夹，因此，你首先要把需要插入的图片放到这个资源文件夹下，然后进行路径引用，这是上面插入图片时的实际引用代码\n1![QQ截图20170123114005](/hexo中完美插入本地图片/QQ截图20170123114005.png)\n\n使用Typora又有一个十分方便的地方在于，只需要将图片往这里一拖就插入了，但其实际拖入图片后的插入代码是绝对路径的引用，是这样的\n1![QQ截图20170123114005](K:\\FangCloudSync\\Github博客源码\\blog\\source\\_posts\\hexo中完美插入本地图片\\QQ截图20170123114005.png)\n\n对比上面的两个代码，我只需要将前面的那段绝对路径删掉K:\\FangCloudSync\\Github博客源码\\blog\\source_posts ，然后再将剩余的两个\\分别换成/ 就可以了\n这样子，Typora编辑时同时能够看到插入的图片。\n生成测试在很多网友的文章中，这么做就可以了，你可以尝试一下生成并本地测试，看看是否博客的首页及博文的正文页都能够正确显示图片，或者打开博文生成的html源文件，找到图片插入的地方看看src路径是否是对应public后的绝对路径，如下示例这样\n1&lt;p&gt;&lt;img src=&quot;/2017/01/22/Windows下远程桌面连接树莓派3代/QQ截图20170122163331.png&quot; alt=&quot;QQ截图20170122163331&quot;&gt;&lt;/p&gt;\n\n如果本地预览主页和博文正文页显示图片都没有问题，并且html源文件内的图片源地址是上面的格式，那你真幸运没有遇到什么麻烦。\n生成绝对路径不完整的问题我发现我做了上面的工作后，生成并本地测试查看，图片并不能正确显示，我查看了html文件，它生成的路径是这样的\n1&lt;p&gt;&lt;img src=&quot;/22/imagetest/500.jpg&quot; alt=&quot;500&quot;&gt;&lt;/p&gt;\n\n看起来hexo-asset-image的确起了点作用，但似乎有点问题，它生成的绝对路径不完整，仿佛只获取了日，年月没获取到，因为这个md文件的时间是2017-01-22，所以”/2017/01” 似乎没有生成啊，对比上面正确正常的绝对路径，我不明白这是什么原因导致的，也许有可能是我使用的hexo懒人包导致的，Google了一晚上好像就我一个人有这种情况，最后我也在Github上向该插件的作者递交了我遇到的麻烦，但估计等到作者回复不知道是何时了。\n今天早上，我受到自定义修改插件，更便捷的使用七牛空间 这篇文章的启发，决定自己也尝试修改插件代码试试能否解决。虽然完全不懂js代码，但还是尝试阅读了那段极其简练的代码，这是其中一段：\n1var link = data.permalink;var beginPos = getPosition(link, &apos;/&apos;, 3) + 1;// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.var endPos = link.lastIndexOf(&apos;/&apos;) + 1;   link = link.substring(beginPos, endPos);\n\n可以猜测出来这段点大概是在获取博文生成的绝对路径，然后最后与md文件中的相对路径做一个拼接，但这个函数中\n1var beginPos = getPosition(link, &apos;/&apos;, 3) + 1;\n\n为什么是寻找第3个’/‘？虽然我不知道，但这样做肯定有作者的意图，只是我不懂其中的原理不理解，不可能这个关键的数字是错的。但我假设如果完整的路径应该是/2017/01/22，那么第3个/似乎正好是日期里面的日，跟我的html生成的不完整的路径点似乎有点关联，因此如果这个数字修改为1，那么是不是就能将/2017/01补上了，试试看吧，然而，幸运的是，成功了！\n1var beginPos = getPosition(link, &apos;/&apos;, 1) + 1;//just by launcher\n\n小结需要插入本地图片，并让Hexo启用资源文件的功能，每个md文件对应一个资源文件夹，然而这只是方便了资源的管理，插入图片时不推荐使用hexo官方说的不伦不类的标签插入方法，因为编辑md文件时无法预览图片，而需要安装hexo-asset-image插件，这样正常使用markdown语法对图片的相对路径引用，即可实现编辑时可预览图片，且发布时插件自动将相对路径转为绝对路径。如果碰到与我同样的生成的绝对路径不完全的情况，尝试修改插件的js代码，但修改器建议先备份它，我认为我所解决我遇到问题的方法可能是一种巧合，但我暂时先这么使用了，最终的原因和处理方法可能还需要等待Github上该插件作者的官方回应。\n","plink":"https://treeeeeeee.github.io/2019/10/01/hexo下完美插入图片/"},{"title":"基于酷q平台的管理机器人","date":"2019-10-01T12:15:14.000Z","updated":"2019-10-03T08:52:42.418Z","content":"酷Q机器人\n自从samrtQQ下线之后，很多QQ机器人都失效了。\n但是最近又比较想用这样一个机器人来管理减轻自己的一些工作，于是千方百计的我发现了酷Q。\n这里附上官网链接\n开发以及注意事项\nSDK的选择酷q提供了多种SDK但是都是我不常用的，官方的支持的SDK是E语言，这语言emmmm好，都好，写，都可以写。虽然提供了java的sdk但是java版本始终不是正统，咬牙学了一天E语言，最后还是吐了。没办法，不习惯，没说E语言不好。害，最后还是选择的java版本。不过但是还没开始使用的时候我看到了更加好用的一个找到一个更加好用方便的SDK-PicqBotX，这是通过http的插件来与酷q的程序交互。虽然不能像官方网站上提供的那个那样可以直接打包成jar运行但是个人认为开发更加简单。\n\n环境以及配置细节\n这里讲得很清楚，以下说明几个坑：\n\n如果使用kotlin代替java进行开发，请最好使用Gradle对项目进行管理，它对kotlin有更加完美的支持。\n\n\n在介绍readme中的这个位置一定要看准，下载对应版本的工具，否则可能出问题，比较麻烦，而且没有提示难以排查。\n\n两个端口号一定要对应于你程序中的机器人的端口号否则会链接失败（建议直接用默认的31091 31092，也可自己选择）\n\n\n\n\n本人开发流程\n使用idea新建项目选择gradle管理项目java版本任意，需要kotlin开发勾选kotlin\n\n导包\n\n导入最新的sdk。\n\n根据需要复制示例代码更改\n1234567891011121314151617181920212223242526272829303132public class TestBot&#123;    public static void main(String[] args)    &#123;        // 创建机器人对象 ( 传入配置 )        PicqBotX bot = new PicqBotX(new PicqConfig(31092).setDebug(true));        // 添加一个机器人账户 ( 名字, 发送URL, 发送端口 )        bot.addAccount(\"Bot01\", \"127.0.0.1\", 31091);        // 注册事件监听器, 可以注册多个监听器        bot.getEventManager().registerListeners(                new TestListener(),                 new RequestListener(),                new ExceptionListener()        );        // 启用指令管理器        // 这些字符串是指令前缀, 比如指令\"!help\"的前缀就是\"!\"        bot.enableCommandManager(\"bot -\", \"!\", \"/\", \"~\");        // 注册指令, 可以注册多个指令        bot.getCommandManager().registerCommands(                new CommandSay(),                new CommandTest(),                new CommandVersion()        );        // 启动机器人, 不会占用主线程        bot.startBot();    &#125;&#125;\n\n\n\n个人实现效果和功能\n通知功能\n\n\n请假功能\n有学生请假则会以json格式文本保存在服务器（或者本地）\n\n\n导出请假表格文档，会直接给下载链接\n\n\n补登请假\n\n\n还有安卓端的管理app和网页版实时查看数据。\n\n\n部署机器人用到的库\n\n阿帕奇的表格框架\ngson\n\n通知管理机器人源代码地址：冷漠无情的机器人\n因为源代码中有不少私人数据，所以取消。\n","plink":"https://treeeeeeee.github.io/2019/10/01/基于酷q平台的管理机器人/"}]