{"title":"Android消息机制深入了解","date":"2020-03-08T11:53:47.000Z","link":"2020/03/08/Android消息机制深入了解","comments":true,"tags":["温故知新"],"categories":["Android"],"updated":"2020-03-09T06:48:29.886Z","content":"<h1 id=\"为什么消息机制这么重要呢\">为什么消息机制这么重要呢<a href=\"2020/03/08/Android消息机制深入了解#为什么消息机制这么重要呢\"></a></h1><p>其实一个安卓的app也是有自己的<strong>main</strong>方法的<img src=\"/2020/03/08/Android消息机制深入了解/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg\" alt=\"img\" style=\"zoom:50%;\">，跟一个普通的java程序并没有太大的区别，只不过用户接触不到这个方法，这个方法在<strong>ActivityThread</strong>这个类里面，这个也就是android中所说的<strong>UI线程</strong>。你可能在想一个问题，那么既然是一个有main方法的java程序，那么一整个安卓的app究竟是怎么来运行的呢，如何做到和用户交互并执行这些代码的呢？？（这里涉及到很多东西，本文只讲与<strong>消息机制相关</strong>的，文章<strong>末尾</strong>我会一一解释）<img src=\"/2020/03/08/Android消息机制深入了解/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<h1 id=\"消息机制重要的三大成员\">消息机制重要的三大成员<a href=\"2020/03/08/Android消息机制深入了解#消息机制重要的三大成员\"></a></h1><ul>\n<li><p><strong>MessageQueue</strong></p>\n</li>\n<li><p><strong>Looper</strong></p>\n</li>\n<li><p><strong>Handler</strong></p>\n<blockquote>\n<p>一个线程只能有一个Looper和MessageQueue，但是可以有多个handler，为什么呢？后面我们慢慢会讲到。</p>\n</blockquote>\n</li>\n</ul>\n<p>那么这三者是如何配合的呢，简单来说，<strong>MessageQueue</strong>就是一根<strong>运输消息管道</strong>，handler负责不断往里面<strong>放</strong>，<strong>Looper</strong>负责不断从里面<strong>取</strong>出来，又交给发送的这个handler去处理，那么就出现两个问题？</p>\n<ul>\n<li>那么为什么要这样子设计？这样子设计怎么实现的<strong>跨线程通信</strong></li>\n<li>为什么handler放进去最后looper又要交还给发送消息的这个handler去处理</li>\n</ul>\n<p>通过后面的源码解析，就能自己领会这两个问题</p>\n<h1 id=\"消息机制主要流程详解\">消息机制主要流程详解<a href=\"2020/03/08/Android消息机制深入了解#消息机制主要流程详解\"></a></h1><p>如果你要在一个线程中使用消息机制</p>\n<p>首先需要<code>Looper.prepare();</code>和<code>Looper.loop();</code>，然后你就可以使用你的<strong>handler发送消息</strong>了。</p>\n<blockquote>\n<p>主线程是不需要自己<code>Looper.prepare();</code>和<code>Looper.loop();</code>在ActivityThread的main方法里面就已经执行了类似代码<code>Looper.prepareMainLooper();</code>和<code>Looper.loop();</code></p>\n</blockquote>\n<p>下面我会逐一从<strong>源码层面</strong>来分析整个消息机制的主要流程<img src=\"/2020/03/08/Android消息机制深入了解/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">，会不会很难呢，要不要继续学下去，头发 - -。</p>\n<h2 id=\"Looper-prepare-；\">Looper.prepare()；<a href=\"2020/03/08/Android消息机制深入了解#Looper-prepare-；\"></a></h2><p>首先我们点进去看看代码是如何实现的</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个函数在ActivityThread的main方法里面执行,用户创建主线程的Looper对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        prepare(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The main Looper has already been prepared.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sMainLooper = myLooper();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通常我们在其他线程如果需要用到消息机制，会执行这个方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数重载，这个参数用于构造一个可以关闭或者无法关闭的Looper</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>最重要的方法就是第三个<code>prepare(boolean quitAllowed)</code>，我们可以看到代码很短，也很好理解。</p>\n<p>首先调用这个这个<strong>Looper类</strong>里面一个<strong>静态变量<code>sThreadLocal</code></strong></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></div></figure>\n\n<p>这是一个<strong><code>ThreadLocal&lt;Looper&gt;</code>类型</strong>的一个变量，而且是直接<strong><code>new</code>出来的</strong>,点击进去看</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadLocal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>查看<strong>ThreadLocal源代码里面的构造方法</strong>也没有做任何操作，说明本身这个变量是里是没有我们想要的东西的</p>\n<p>那么<strong>关键肯定是在<code>sThreadLocal.get()</code>里面</strong>，通过后面的抛出异常</p>\n<p><code>throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</code></p>\n<p>我们可以断定这个<strong>判断</strong>肯定<strong>是</strong>用来<strong>判断当前线程是否已经存在了一个Lopper对象</strong></p>\n<p>接下来我们来看<code>get()</code>方法内部</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码不是很多，我们一步步分析</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();<span class=\"comment\">//获得当前的线程对象</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);<span class=\"comment\">//从当前线程拿到一个ThreadLocalMap</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果这个ThreadLocalMap不为空</span></span><br><span class=\"line\">      \t<span class=\"comment\">//从里面取得Looper（这里做了一个包装，稍后会讲到）</span></span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果Lopper不为空</span></span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;<span class=\"comment\">//直接返回Looper</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();<span class=\"comment\">//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>可能虽然有注释还是有些疑惑，下面我们一一来讲解一下 Why<img src=\"/2020/03/08/Android消息机制深入了解/v2-639605533bdb1ecf1c6562677a430554_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<p>首先我们来看看<strong><code>ThreadLocalMap map = getMap(t);</code>中<code>get(t)</code>的代码</strong></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>可以看到，是直接返回了<strong>当前线程对象</strong>的一个<strong>成员变量<code>threadLocals</code></strong>，那么这个<code>threadLocals</code>究竟是个什么东西呢？</p>\n<h3 id=\"ThreadLocal和ThreadLocalMap\">ThreadLocal和ThreadLocalMap<a href=\"2020/03/08/Android消息机制深入了解#ThreadLocal和ThreadLocalMap\"></a></h3><p>首先我们来看<code>ThreadLocal</code>，顾名思义，直接翻译过来就是 “线程本地” ？？<img src=\"/2020/03/08/Android消息机制深入了解/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<p>我们来看看这个类的介绍注释</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * This class provides thread-local variables.  These variables differ from</span></span><br><span class=\"line\"><span class=\"comment\"> * their normal counterparts in that each thread that accesses one (via its</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> get&#125; or &#123;<span class=\"doctag\">@code</span> set&#125; method) has its own, independently initialized</span></span><br><span class=\"line\"><span class=\"comment\"> * copy of the variable.  &#123;<span class=\"doctag\">@code</span> ThreadLocal&#125; instances are typically private</span></span><br><span class=\"line\"><span class=\"comment\"> * static fields in classes that wish to associate state with a thread (e.g.,</span></span><br><span class=\"line\"><span class=\"comment\"> * a user ID or Transaction ID).</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 谷歌翻译版本:</span></span><br><span class=\"line\"><span class=\"comment\">* 此类提供线程局部变量</span></span><br><span class=\"line\"><span class=\"comment\">* 这些变量不同于它们的普通副本，</span></span><br><span class=\"line\"><span class=\"comment\">* 因为每个访问一个变量的线程（通过其&#123;<span class=\"doctag\">@code</span> get&#125;或&#123;<span class=\"doctag\">@code</span> set&#125;方法）</span></span><br><span class=\"line\"><span class=\"comment\">* 都有自己的、独立的变量副本。</span></span><br><span class=\"line\"><span class=\"comment\">* &#123;<span class=\"doctag\">@code</span> ThreadLocal&#125;实例通常是类中的私有静态字段，希望将状态与线程关联（例如，*用户ID或事务ID）。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></div></figure>\n\n<p>通过注释我们可以很轻松的理解到，原来这个东西就是为每一个线程创建一个单独的变量副本的呀<img src=\"/2020/03/08/Android消息机制深入了解/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">。</p>\n<p>我们来看看到底怎么使用</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ThreadLocal&lt;Integer&gt; integerThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;()&#123;</span><br><span class=\"line\">            <span class=\"comment\">//这个方法专门用来提供开发者复写，提供副本默认值</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">2333</span>;<span class=\"comment\">//默认值我们这设置为</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//为这个ThreadLocal&lt;Integer&gt;在当前线程存一个副本，值为3222</span></span><br><span class=\"line\">                    <span class=\"comment\">//如果不是基本数据类型，注意值传递和引用传递的区别，这里需要new一个新的放进去</span></span><br><span class=\"line\">                    <span class=\"comment\">//例如：ThreadLocal的泛型是Runnable,</span></span><br><span class=\"line\">                    <span class=\"comment\">//那么就需要新建一个独立的Runnable实现类的对象</span></span><br><span class=\"line\">                    <span class=\"comment\">//runnableThreadLocal.set(new Runnable() &#123;</span></span><br><span class=\"line\">                    <span class=\"comment\">//            @Override</span></span><br><span class=\"line\">                    <span class=\"comment\">//            public void run() &#123;</span></span><br><span class=\"line\">                    <span class=\"comment\">//</span></span><br><span class=\"line\">                    <span class=\"comment\">//            &#125;</span></span><br><span class=\"line\">                    <span class=\"comment\">//        &#125;;)</span></span><br><span class=\"line\">                    integerThreadLocal.set(<span class=\"number\">3222</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//获取当前线程的副本，如果之前没有set()，那么默认值为2333</span></span><br><span class=\"line\">                  \t<span class=\"comment\">//如果之前set()了，就会取得set()的那个对象</span></span><br><span class=\"line\">                    integerThreadLocal.get();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                     * 通过以上代码，在这5个线程里都有了一个与integerThreadLocal对应</span></span><br><span class=\"line\"><span class=\"comment\">                     * 变量副本，这个副本是Integer类型的，每个线程通过integerThreadLocal.get()</span></span><br><span class=\"line\"><span class=\"comment\">                     * 取到的都是线程独有的，与其他线程完全隔离的一个副本</span></span><br><span class=\"line\"><span class=\"comment\">                     */</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>通过上面的注释就足以理解这个东西的用法，这时候我们回到安卓来看看消息机制这里的设计，是不是就一下子恍然大悟了<img src=\"/2020/03/08/Android消息机制深入了解/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">，我这再梳理一下</p>\n<ul>\n<li><p>首先Lopper中是有一个<code>sThreadLocal</code></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></div></figure>\n\n<p>理解了上面小Demo,就能知道这个<code>sThreadLocal</code>的存在是为了方便在每一个线程存一个Looper副本</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>看，这是不是就很清晰了<img src=\"/2020/03/08/Android消息机制深入了解/v2-8312b637ba6407992515ffa42b56391d_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n</li>\n</ul>\n<p>然后我们来看看<code>ThreadLocalMap</code>，前面我们看到<code>ThreadLocal.get()</code>的<code>get()</code>方法,这里再把代码贴一下</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();<span class=\"comment\">//获得当前的线程对象</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);<span class=\"comment\">//从当前线程拿到一个ThreadLocalMap</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果这个ThreadLocalMap不为空</span></span><br><span class=\"line\">      \t<span class=\"comment\">//从里面取得Looper（这里做了一个包装，稍后会讲到）</span></span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果Lopper不为空</span></span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;<span class=\"comment\">//直接返回Looper</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();<span class=\"comment\">//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>从上面的代码可以知道，一个线程对象里面是有一个<code>threadLocals</code>属性的，它是一个<code>ThreadLocalMap</code>类型的变量。就是它用来储存各种存在当前线程的副本。他是一个键值对存储的形式,下面是<code>ThreadLocalMap</code>的set（）方法的声明</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set(ThreadLocal&lt;?&gt; key, Object value)</span><br></pre></td></tr></table></div></figure>\n\n<p>具体实现是比较复杂的，用到哈希表来储存，这里不展开讲了，有兴趣可以去了解一下，文章后面会有超链接。</p>\n<p>然后我们来看看<code>ThreadLocalMap.Entry e = map.getEntry(this);</code>这个行代码，肯定很多人都会有疑惑，首先我们需要看一下ThreadLocalMap.Entry这个静态内部类</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">    Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>这里你可以看到这里是直接继承WeakReference弱引用这个类的，那为什么要这么设计呢？<img src=\"/2020/03/08/Android消息机制深入了解/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<p>这里我大致的说一下，ThreadLocal是为了每个线程中的对象副本服务的，一旦我不需要使用ThreadLocal这个对象了，那么我肯定会将ThreadLocal对象的强引用去掉，以防止内存泄漏，但是这个如果不这么设计，如果有一个线程的生命周期比ThreadLocal长，那么必定会持有ThreadLocal的引用，这样就会导致内存泄漏，ThreadLocal没有被使用但是却无法被GC回收。相比之下，这样设计就不会出现这个问题。</p>\n<h3 id=\"Looper的构造方法\">Looper的构造方法<a href=\"2020/03/08/Android消息机制深入了解#Looper的构造方法\"></a></h3><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);<span class=\"comment\">//生成一个MessageQueue，并作为成员保存在Looper中</span></span><br><span class=\"line\">    mThread = Thread.currentThread();<span class=\"comment\">//绑定当前线程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>从上面的代码也印证了Looper和MessageQueue一般都是同时出现的，而且都只能有一个的言论（因为prepare方法在一个线程调用一次，前面代码提到过）。</p>\n<h2 id=\"Looper-loop\">Looper.loop<a href=\"2020/03/08/Android消息机制深入了解#Looper-loop\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//因为方便，我只选择了关键代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Looper me = myLooper();<span class=\"comment\">//取得当前线程的Looper，当然实际上也是通过sThreadLocal.get()</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果没有说明没有调用prepare(),抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;<span class=\"comment\">//从当前的Looper对象里取得对应的MessageQueue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//do something............</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; ; ) &#123;</span><br><span class=\"line\">            Message msg = queue.next(); <span class=\"comment\">// 取出消息，这里可能会堵塞，直到重新取到消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              \t<span class=\"comment\">//如果返回为空，则表示MessageQueue正在退出，所以这里也直接退出无限循环</span></span><br><span class=\"line\">              \t<span class=\"comment\">//这里是只有MessageQueue调用quit(boolean safe)方法才会退出</span></span><br><span class=\"line\">              \t<span class=\"comment\">//下面会有详细解释</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//do something.............</span></span><br><span class=\"line\"></span><br><span class=\"line\">          \t<span class=\"comment\">//这个target是发送这个消息的handler，取得消息之后让发送的这个handler去处理</span></span><br><span class=\"line\">          \t<span class=\"comment\">//后面我们会讲到，handler是如何把这个消息发送到当前这个MessageQueue中，并且target的赋值</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//do something.............</span></span><br><span class=\"line\">            msg.recycleUnchecked();<span class=\"comment\">//回收这个消息</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>通过代码应该很清晰就能展现出关键点，这里就不再赘述</p>\n<p>因为这里涉及到Looper.loop退出的情况，下面我们用代码类分析一下，关键就在<code>queue.next()</code>，为了便于理解还是只凸显出主要代码，还有很多MessageQueue的消息处理的一些代码就不赘述了，下面代码重点看那个返回值为空的判断语句</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//do something..........</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; ; ) &#123;<span class=\"comment\">//next中也是一个无限循环着也就很好的说明为什么next()是一个可堵塞的方法啦</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//do something..........</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                prevMsg = msg;</span><br><span class=\"line\">                msg = msg.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">//这里是后面handler的sendMessage方法会给message添加一个时间的处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//do something..........</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//do something..........</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> msg;<span class=\"comment\">//如果所有条件都满足，就可以直接返回这个message了</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">            nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Process the quit message now that all pending messages have been handled.</span></span><br><span class=\"line\">      \t<span class=\"comment\">// 前面没有返回，这里如果为true只就直接返回null，前面Looper.loop就退出了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            dispose();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//do something..........</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class=\"line\">            mBlocked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//do something..........</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>我们来看看<code>mQuitting</code>这个变量是在哪被赋值为true的</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">(<span class=\"keyword\">boolean</span> safe)</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">//mQuitAllowed这个其实在前文多次提到了，Looper和MessageQueue的构造方法都需要</span></span><br><span class=\"line\">  \t<span class=\"comment\">//用来设定是否可以被退出</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mQuitAllowed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Main thread not allowed to quit.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mQuitting = <span class=\"keyword\">true</span>;<span class=\"comment\">//关键代码，这里赋值为true</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (safe) &#123;</span><br><span class=\"line\">            removeAllFutureMessagesLocked();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            removeAllMessagesLocked();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class=\"line\">        nativeWake(mPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>从上面分析我们可以知道一旦调用了MessageQueue的quit的方法那么MessageQueue下一个利用next方法去取消息就会返回null，返回null就导致Looper的loop(也就是无限取消息的循环退出了),那么就有一个问题了，Looper也有一个quit方法，怎么实现的呢？</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>恍然大悟！！！！！！！<img src=\"/2020/03/08/Android消息机制深入了解/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<h2 id=\"handler-sendMessage\">handler.sendMessage()<a href=\"2020/03/08/Android消息机制深入了解#handler-sendMessage\"></a></h2><p>看发送消息之前我们需要先看看Handler的构造方法</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//无参构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(@Nullable Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//do something............</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  \t<span class=\"comment\">//获取当前线程的Looper</span></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//同样如果没有Looper会报错（没有Looper.prepare()）</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread \"</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">\" that has not called Looper.prepare()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    mQueue = mLooper.mQueue;<span class=\"comment\">//绑定当前线程的MessageQueue</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//do something............</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>可以看出Handler在那个线程创建，它就会直接绑定哪个线程的MessageQueue，之后它<code>sendMessage()</code>就可以直接放到这个MessageQueue里面</p>\n<p>还是直接来看<code>sendMessage()</code>的代码</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//点进来第一个方法是这个</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessage</span><span class=\"params\">(@NonNull Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送延迟处理的消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageDelayed</span><span class=\"params\">(@NonNull Message msg, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        delayMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(@NonNull Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;<span class=\"comment\">//拿到创建Handler时绑定的那个MessageQueue</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(@NonNull MessageQueue queue, @NonNull Message msg,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    msg.target = <span class=\"keyword\">this</span>;<span class=\"comment\">//【发送的消息】绑定【发送消息的这个handler】</span></span><br><span class=\"line\">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"comment\">//把消息交给MessageQueue去排序消息，这里是根据uptimeMillis转成具体时刻来排序的</span></span><br><span class=\"line\">  \t<span class=\"comment\">//这里要注意，发送的延迟消息，只能保持设置的时间前这个消息不被处理</span></span><br><span class=\"line\">  \t<span class=\"comment\">//但是无法保证这个消息具体在设置的时间之后的那个时候被处理</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"handler-post\">handler.post()<a href=\"2020/03/08/Android消息机制深入了解#handler-post\"></a></h3><p>还是直接看代码，如果上面的理解了这个就非常简单了<img src=\"/2020/03/08/Android消息机制深入了解/v2-8312b637ba6407992515ffa42b56391d_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">，只有一些区别</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">post</span><span class=\"params\">(@NonNull Runnable r)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//这里仍然还是调用的发送延时消息的方法，区别是下面那个方法</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span>  sendMessageDelayed(getPostMessage(r), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将Runnable包装成Message，那么这个Runnable在哪会被调用呢</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Message <span class=\"title\">getPostMessage</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">    Message m = Message.obtain();</span><br><span class=\"line\">    m.callback = r;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>还记得前面讲到的Looper.loop吗，它会把消息交给与他绑定的Handler去处理来看看这个方法</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(@NonNull Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//优先优先判断callback是不是空</span></span><br><span class=\"line\">        handleCallback(msg);<span class=\"comment\">//不为空直接调用方法处理callback</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handleCallback</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">    message.callback.run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"结尾\">结尾<a href=\"2020/03/08/Android消息机制深入了解#结尾\"></a></h1><p>文章开头留下的悬念我想这下已经很清晰了，主线程中的main方法调用了Looper.loop,正是有这个无限循环的存在才会不会想一个简单的java程序一样，执行完了main里面的代码程序就结束了，而<code>prepareMainLooper</code>,正是为主线程（UI线程）准备了一个不可以退出的Looper。而这就可以说明Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞它。<strong>也就说我们的代码其实就是在这个循环里面去执行的</strong>，所以你在你的子线程要使用消息机制接受消息的话，最好将Looper.loop()放到你要直接执行的所有代码后面，不然没有执行qiut方法，后面的代码就不会执行。<img src=\"/2020/03/08/Android消息机制深入了解/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg\" alt=\"img\" style=\"zoom: 67%;\">真逊，原来这么简单，是吧。</p>\n","next":{"title":"git常用命令以及如何在idea上可视化操作git","link":"2019/12/30/git常用命令以及如何在idea上可视化操作git"},"plink":"https://treeeeeeee.github.io/2020/03/08/Android消息机制深入了解/","toc":[{"title":"为什么消息机制这么重要呢","id":"为什么消息机制这么重要呢","index":"1"},{"title":"消息机制重要的三大成员","id":"消息机制重要的三大成员","index":"2"},{"title":"消息机制主要流程详解","id":"消息机制主要流程详解","index":"3","children":[{"title":"Looper.prepare()；","id":"Looper-prepare-；","index":"3.1","children":[{"title":"ThreadLocal和ThreadLocalMap","id":"ThreadLocal和ThreadLocalMap","index":"3.1.1"},{"title":"Looper的构造方法","id":"Looper的构造方法","index":"3.1.2"}]},{"title":"Looper.loop","id":"Looper-loop","index":"3.2"},{"title":"handler.sendMessage()","id":"handler-sendMessage","index":"3.3","children":[{"title":"handler.post()","id":"handler-post","index":"3.3.1"}]}]},{"title":"结尾","id":"结尾","index":"4"}]}