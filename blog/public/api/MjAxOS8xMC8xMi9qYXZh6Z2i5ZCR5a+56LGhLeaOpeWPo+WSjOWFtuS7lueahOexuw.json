{"title":"java面向对象-接口和其他的类","date":"2019-10-12T06:34:00.000Z","author":"Jon","link":"2019/10/12/java面向对象-接口和其他的类","comments":true,"tags":["java","课件"],"categories":["java"],"updated":"2019-10-21T13:58:04.626Z","content":"<p><strong>万物皆可为对象那么对象与对象之间肯定不是独立的，上节课谢磊学长讲了类的继承，那是一种最广泛的关系。今天我们了解一点更加抽象一点的东西，但是只要大家认真听我想还是会有所明白。</strong></p>\n<h1 id=\"先来吹吹概念\">先来吹吹概念 <img src=\"/2019/10/12/java面向对象-接口和其他的类/6af89bc8gw1f8tzvsvn8gj20a00a00tp.jpg\" alt=\"这和吃饭时扶碗是一个概念\" style=\"zoom:25%;\"><a href=\"2019/10/12/java面向对象-接口和其他的类#先来吹吹概念\"></a></h1><h2 id=\"接口\">接口<a href=\"2019/10/12/java面向对象-接口和其他的类#接口\"></a></h2><h3 id=\"什么是接口？\">什么是接口？<a href=\"2019/10/12/java面向对象-接口和其他的类#什么是接口？\"></a></h3><blockquote>\n<p>接口最通俗的来讲就是一种统一的规范或者叫做协议，接口这个名称有点晦涩难懂，但是其实接口就是一个基于双方或者多方的协议</p>\n<p>下面举几个例子：</p>\n<ul>\n<li>你们用的插座的插孔可以被叫做接口（协议），因为这个规范存在，在中国无论你是什么充电器，只要是这个充电口，那么我就会给你输出电流，至于你充什么，干什么我都不管。</li>\n<li>你去面试，他说你必须有本科及以上的文凭且必须过了四级才能有面试资格，这也算事接口（协议），因为如果你没有这些东西，就不能去面试，至于你是怎么努力学习拿到本科文凭和怎么努力拿到四级证书的，一律不管。</li>\n<li>我今天布置了作业，我要收的是我布置的这些作业，至于你们每个人怎么去做出来我是不管的，那我布置的作业就是接口（协议），你们按照题目实现相应的功能就好，最后验收我也只会根据我布置的作业的应该输出的结果来看你是不是完成作业。（当然，当然我在作业文件中指出你不能用啥，我还是会看的具体细节的）</li>\n</ul>\n<p>现在，接口你们应该都应该大致明白是什么了吧。</p>\n</blockquote>\n<h3 id=\"接口有什么作用？或者接口存在的必要性？\">接口有什么作用？或者接口存在的必要性？<a href=\"2019/10/12/java面向对象-接口和其他的类#接口有什么作用？或者接口存在的必要性？\"></a></h3><blockquote>\n<p>还是上一节的例子，如果国家没有规定这个插座的标准，那每个厂家的有自己的一套，你买公牛的插座就得买支持公牛插座的电器。出去在中国其他地方旅游你就只有背着各式各样的转接头。嗯，锻炼身体也是好事嘛。</p>\n<p>所以国家就制定了标准。</p>\n<p>所以编程中接口的重要性也就凸显出来了</p>\n</blockquote>\n<h3 id=\"编程中的接口？\">编程中的接口？<a href=\"2019/10/12/java面向对象-接口和其他的类#编程中的接口？\"></a></h3><blockquote>\n<p><strong>场景</strong>：</p>\n<p>假设你已经是精通java的能人异士，这一天你的老板要你做个实现一个类，但是你的老板马上就要出差了，而且你老板还买不起手机，无法跟你交流。那么该怎么办呢？</p>\n<p>答案：</p>\n<p>老板设计一个接口，然后让员工实现这个接口。那么老板回来之后直接用员工写的东西就好。因为员工写的类实现老板设计的接口，那么就必须要有那些实现，至于员工到底怎么实现的，老板根本不用在意。</p>\n</blockquote>\n<h2 id=\"抽象类\">抽象类<a href=\"2019/10/12/java面向对象-接口和其他的类#抽象类\"></a></h2><p><strong>我都叫抽象类了，你说我抽象不抽象，我觉得我比上面那玩意儿抽象，你说呢？</strong></p>\n<h3 id=\"黄坤坤告诉你到底有多抽象？\"><img src=\"/2019/10/12/java面向对象-接口和其他的类/164336559DA3C001F7D365CBC0A67998.jpg\" alt=\"164336559DA3C001F7D365CBC0A67998\" style=\"zoom:25%;\">  黄坤坤告诉你到底有多抽象？<a href=\"2019/10/12/java面向对象-接口和其他的类#黄坤坤告诉你到底有多抽象？\"></a></h3><p><strong>抽象？我叫抽象类我就抽象啦？那hljj是jj吗？</strong></p>\n<ul>\n<li><p><strong>听听抽象类的自白</strong></p>\n<p><strong>（抽象类独白）</strong>：</p>\n<p>​        天生就是用来被别人来继承的，简而言之，只有当爸爸的命，从不当儿子。可能有些事，必须得儿子去做，别直接叫我去做事。</p>\n</li>\n<li><p>”<strong>只当爸爸</strong>“</p>\n<p>说明被继承是绝对需要，大部分抽象类都是没有完整实现类功能的类，等待子类继承去实现，所以它是不可以被实例化成对像的。</p>\n</li>\n<li><p>“<strong>有些事必须得儿子去做</strong>”</p>\n<p>说明它可能存在方法是抽象的，必须得子类去具体实现。</p>\n</li>\n<li><p>“<strong>别直接叫我做事</strong>”  </p>\n<p>说明它是不可以直接示例化的。</p>\n</li>\n</ul>\n<h3 id=\"好了，说完上面牵强的解释，现在我们来看看例子：\">好了，说完上面牵强的解释，现在我们来看看例子：<a href=\"2019/10/12/java面向对象-接口和其他的类#好了，说完上面牵强的解释，现在我们来看看例子：\"></a></h3><p><img src=\"/2019/10/12/java面向对象-接口和其他的类/ceeb653ejw1fai8r9ct23j205c05q3yn.jpg\" alt=\"爸爸在呢 有事快说 - 和爸爸斗图 斗图+表情_爸爸_斗图表情\" class=\"article-img\"></p>\n<h1 id=\"好了，开始开飞机了\">好了，开始开飞机了<a href=\"2019/10/12/java面向对象-接口和其他的类#好了，开始开飞机了\"></a></h1><h2 id=\"接口-1\">接口<a href=\"2019/10/12/java面向对象-接口和其他的类#接口-1\"></a></h2><p> 接口，英文称作<strong>interface</strong>，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对<strong>行为</strong>的抽象。在Java中，定一个接口的形式如下： </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InterfaceName</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>需要注意的是:</p>\n<ul>\n<li><p>接口中的变量会被隐式地指定为public static final变量 </p>\n<blockquote>\n<p>用其他关键词修饰会报错：</p>\n<ul>\n<li><code>public static final</code>，<code>private</code></li>\n</ul>\n</blockquote>\n</li>\n<li><p>方法会被隐式地指定为public abstract方法且只能是public abstract方法 </p>\n<blockquote>\n<p>用其他关键词会报错：</p>\n<ul>\n<li><code>private</code>、<code>protected</code>、<code>static</code>、 <code>final</code></li>\n</ul>\n</blockquote>\n<p>接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。 </p>\n</li>\n</ul>\n<p> 可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。 </p>\n<h2 id=\"抽象类-1\">抽象类<a href=\"2019/10/12/java面向对象-接口和其他的类#抽象类-1\"></a></h2><h3 id=\"定义\">定义<a href=\"2019/10/12/java面向对象-接口和其他的类#定义\"></a></h3><ul>\n<li>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</li>\n<li>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</li>\n<li>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</li>\n<li>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</li>\n<li>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>\n</ul>\n<h3 id=\"怎么使用\">怎么使用<a href=\"2019/10/12/java面向对象-接口和其他的类#怎么使用\"></a></h3><h4 id=\"抽象类声明\">抽象类声明<a href=\"2019/10/12/java面向对象-接口和其他的类#抽象类声明\"></a></h4><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 普通的类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 抽象类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>声明一个java抽象类只需要在正常的类的class之前加上<code>abstract</code></p>\n<p><a href=\"2019/10/12/java面向对象-接口和其他的类#实际的例子\">跳转到</a></p>\n<h4 id=\"抽象方法声明\">抽象方法声明<a href=\"2019/10/12/java面向对象-接口和其他的类#抽象方法声明\"></a></h4><h3 id=\"使用时需要注意的：\">使用时需要注意的：<a href=\"2019/10/12/java面向对象-接口和其他的类#使用时需要注意的：\"></a></h3><ul>\n<li><p>抽象类<strong>不能被实例化</strong>，实例化的工作应该交<strong>由它的子类来完成</strong>，它<strong>只需要有一个引用即可</strong>。</p>\n</li>\n<li><p><strong>抽象方法</strong>必须<strong>由子类来进行重写</strong>。</p>\n</li>\n<li><p>只要<strong>包含一个抽象方法的抽象类</strong>，该方法<strong>必须要定义成抽象类</strong>，不管是否还包含有其他方法。</p>\n</li>\n<li><p>抽象类中<strong>可以包含具体的方法</strong>，当然<strong>也可以不包含抽象方法</strong>。</p>\n</li>\n<li><p>子类中的抽象方法<strong>不能</strong>与父类的抽象方法<strong>同名</strong>。</p>\n</li>\n<li><p><code>abstract</code>不能与<code>final</code>并列修饰同一个类。</p>\n</li>\n<li><p><code>abstract</code> 不能与<code>private</code>、<code>static</code>、<code>final</code>或<code>native</code>并列修饰同一个方法。</p>\n</li>\n</ul>\n<h2 id=\"抽象类和接口的区别\">抽象类和接口的区别<a href=\"2019/10/12/java面向对象-接口和其他的类#抽象类和接口的区别\"></a></h2><h3 id=\"语法层面上的区别\">语法层面上的区别<a href=\"2019/10/12/java面向对象-接口和其他的类#语法层面上的区别\"></a></h3><ul>\n<li><strong>抽象类</strong>可以提供<strong>成员方法的实现细节</strong>，而<strong>接口</strong>中只能存在<strong>public abstract 方法</strong>；</li>\n<li><strong>抽象类</strong>中的成员变量可以是<strong>各种类型</strong>的，而<strong>接口</strong>中的成员变量只能是<strong>public static final类型</strong>的；</li>\n<li><strong>接口</strong>中<strong>不能含有静态代码块</strong>以及<strong>静态方法</strong>，而<strong>抽象类</strong>可以有<strong>静态代码块</strong>和<strong>静态方法</strong>；</li>\n<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>\n</ul>\n<h3 id=\"设计层面上的区别\">设计层面上的区别<a href=\"2019/10/12/java面向对象-接口和其他的类#设计层面上的区别\"></a></h3><ul>\n<li><p>抽象类是对一种<strong>事物的抽象</strong>，即<strong>对类抽象</strong>，而接口是<strong>对行为的抽象</strong>。</p>\n</li>\n<li><p>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</p>\n</li>\n<li><p>举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，<strong>继承</strong>是一个 “<strong>是不是</strong>“的关系，而 <strong>接口</strong> 实现则是 “<strong>有没有</strong>“的关系。</p>\n</li>\n<li><p>如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而<strong>接口实现则是有没有</strong>、<strong>具备不具备的关系</strong>，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>\n</li>\n<li><p>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种模板式设计。什么是模板式设计？</p>\n<blockquote>\n<p> 最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"实际的例子\">实际的例子<a href=\"2019/10/12/java面向对象-接口和其他的类#实际的例子\"></a></h3><p>下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`<span class=\"keyword\">abstract</span>` `<span class=\"class\"><span class=\"keyword\">class</span>` `<span class=\"title\">Door</span> </span>&#123;``  ``<span class=\"keyword\">public</span>` `<span class=\"keyword\">abstract</span>` `<span class=\"keyword\">void</span>` `open();``  ``<span class=\"keyword\">public</span>` `<span class=\"keyword\">abstract</span>` `<span class=\"keyword\">void</span>` `close();``&#125;`</span><br></pre></td></tr></table></div></figure>\n\n<p>　　或者：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`<span class=\"class\"><span class=\"keyword\">interface</span>` `<span class=\"title\">Door</span> </span>&#123;``  ``<span class=\"keyword\">public</span>` `<span class=\"keyword\">abstract</span>` `<span class=\"keyword\">void</span>` `open();``  ``<span class=\"keyword\">public</span>` `<span class=\"keyword\">abstract</span>` `<span class=\"keyword\">void</span>` `close();``&#125;`</span><br></pre></td></tr></table></div></figure>\n\n<p>但是现在如果我们需要门具有<strong>报警alarm( )</strong>的功能，那么该如何实现？下面提供两种思路：</p>\n<ul>\n<li>将这三个功能都放在抽象类里面，但是这样一来<strong>所有继承于这个抽象类的子类都具备了报警功能</strong>，但是有的门并不一定具备报警功能；</li>\n<li>将这三个功能都放在接口里面，需要用到<strong>报警功能的类就需要实现这个接口中的open( )和close( )</strong>，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</li>\n</ul>\n<p>很明显这个属性放到以上任何一个的当中都是不合适的，但是报警又是一个比较广泛的属性，java不支持多继承，所以最好将这个方法抽象到一个接口里面，这就是所谓的对行为抽象：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 报警的接口，所有实现了这个接口的类都是有报警这个功能</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alarm</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>然后在对这个可以报警的们进行封装：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以报警的门</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">DoorAbstract</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p><strong>这里其中有个注解<code>@Override</code>我简单说明一下（至于注解是啥，不详细的讲解了下节课会讲到）：</strong></p>\n<p><code>@Override</code>是伪代码,表示重写可以不写，不过写上有如下好处: </p>\n<ul>\n<li>可以当注释用,方便阅读，可以很明显的看到哪些方法是重写的方法；</li>\n<li>编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了，这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)。</li>\n</ul>\n<p>对于这里而言第二个作用是没有作用的，因为如果继承了抽象类，如果抽象类中含有抽象方法，必须实现这个方法不然编译器也会报错，接口也是同样的，前面说到接口中的方法默认是<code>public abstract</code>。</p>\n","next":{"title":"ssh用法及命令","link":"2019/10/07/ssh用法及命令"},"plink":"https://treeeeeeee.github.io/2019/10/12/java面向对象-接口和其他的类/","toc":[{"title":"先来吹吹概念 <img src=\"/2019/10/12/java面向对象-接口和其他的类/6af89bc8gw1f8tzvsvn8gj20a00a00tp.jpg\" alt=\"这和吃饭时扶碗是一个概念\" style=\"zoom:25%;\">","id":"先来吹吹概念","index":"1","children":[{"title":"接口","id":"接口","index":"1.1","children":[{"title":"什么是接口？","id":"什么是接口？","index":"1.1.1"},{"title":"接口有什么作用？或者接口存在的必要性？","id":"接口有什么作用？或者接口存在的必要性？","index":"1.1.2"},{"title":"编程中的接口？","id":"编程中的接口？","index":"1.1.3"}]},{"title":"抽象类","id":"抽象类","index":"1.2","children":[{"title":"<img src=\"/2019/10/12/java面向对象-接口和其他的类/164336559DA3C001F7D365CBC0A67998.jpg\" alt=\"164336559DA3C001F7D365CBC0A67998\" style=\"zoom:25%;\">  黄坤坤告诉你到底有多抽象？","id":"黄坤坤告诉你到底有多抽象？","index":"1.2.1"},{"title":"好了，说完上面牵强的解释，现在我们来看看例子：","id":"好了，说完上面牵强的解释，现在我们来看看例子：","index":"1.2.2"}]}]},{"title":"好了，开始开飞机了","id":"好了，开始开飞机了","index":"2","children":[{"title":"接口","id":"接口-1","index":"2.1"},{"title":"抽象类","id":"抽象类-1","index":"2.2","children":[{"title":"定义","id":"定义","index":"2.2.1"},{"title":"怎么使用","id":"怎么使用","index":"2.2.2"},{"title":"使用时需要注意的：","id":"使用时需要注意的：","index":"2.2.3"}]},{"title":"抽象类和接口的区别","id":"抽象类和接口的区别","index":"2.3","children":[{"title":"语法层面上的区别","id":"语法层面上的区别","index":"2.3.1"},{"title":"设计层面上的区别","id":"设计层面上的区别","index":"2.3.2"},{"title":"实际的例子","id":"实际的例子","index":"2.3.3"}]}]}]}