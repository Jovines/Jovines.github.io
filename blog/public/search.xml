<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android事件分发整理和ViewGroup分发方法深入分析]]></title>
    <url>%2F2020%2F04%2F04%2FAndroid%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%95%B4%E7%90%86%E5%92%8CViewGroup%E5%88%86%E5%8F%91%E6%96%B9%E6%B3%95%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[事件传递流程事件向下依次传递顺序ActivityPhoneWindowViewGroupView主要方法dispatchTouchEvent返回true表示下层消耗了事件返回false表示下层消耗了事件onInterceptTouchEvent（View没有这个方法）返回true表示拦截事件返回false表示放行事件如果当前ViewGroup拦截了一个事件序列中的任意一个事件后，那么在同一个事件序列当中，此方法不会被再次调用，并且，后续事件不会传递下去，返回结果表示是否拦截当前事件。onTouchEvent点击事件处理的主要方法由于View没有拦截方法，所以一旦分发到它会直接调用此方法，View会默认消耗掉事件ViewGroup主要Tag说明mFirstTouchTargetmFirstTouchTarget 为null, 那么ViewGroup 就默认拦截接下来同一序列中所有的点击事件mFirstTouchTarget 不为null, 就说明找到子View来处理这个事件，并且不会再询问onInterceptTouchEvent是否要拦截事件，将后续事件交于这个View去处理源码证明android.view.ViewGroup#dispatchTouchEvent 1234567891011121314151617if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123;//观点二中的不会再调用onInterceptTouchEvent的证据 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; //观点一证据 //当一个事件不是ACTION_DOWN而且mFirstTouchTarget为空 //说明找不到一个子View来处理这个事件，那就默认拦截 // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125;哪些情况mFirstTouchTarget会为空？ViewGroup 没有子元素子元素处理了点击点击事件，但是在dispatchTouchEvent 中返回了false, 这一般是因为子元素在onTouchEvent 中返回了falseFLAG_DISALLOW_INTERCEPT该tag会对ViewGroup的拦截逻辑进行影响 调用requestDisallowInterceptTouchEvent方法之后，会改变该tag的值 整个ViewGroup的dispatchTouchEvent详细分析这是最复杂的部分也是解决滑动冲突的关键部分，代码很长，一步步看， 其中以$$$开头的注释与事件分发无关 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false;//这个变量就是要返回的boolean类型的值 //$$$对点击事件进行过滤，这里是方便应用对应的安全策略 if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction();//获取当前点击事件 //$$$对当前点击事件进行 与 操作，这里是对多点触控的处理ACTION_MASK是0xff final int actionMasked = action &amp; MotionEvent.ACTION_MASK; //判断当前点击事件是不是Down，是的话就会重置一些状态，开启新的一轮点击事件 //其中包括将FLAG_DISALLOW_INTERCEPT和mFirstTouchTarget重置 if (actionMasked == MotionEvent.ACTION_DOWN) &#123; cancelAndClearTouchTargets(ev); resetTouchState(); &#125; //这个变量会根据onInterceptTouchEvent的调用状态或者返回值确定 //也就是 是否拦截 final boolean intercepted; //如果当前事件是Down，说明开启了新的一轮的事件序列，那么进入条件判断 if (actionMasked == MotionEvent.ACTION_DOWN //如果不是Down，那么如果mFirstTouchTarget不为空的话也满足要求 || mFirstTouchTarget != null) &#123; //查看子元素是否要求父元素不要拦截事件，也就是在子元素中调用了父元素的 //requestDisallowInterceptTouchEvent方法之后，会在这里根据结果生效 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; //如果子元素要求父元素不要拦截 //那么父元素就不会执行onInterceptTouchEvent询问自己是否要拦截 if (!disallowIntercept) &#123; //如果子元素没有要求父元素不要拦截，这里则会调用 intercepted = onInterceptTouchEvent(ev); //$$$恢复操作，以防它被更改 ev.setAction(action); &#125; else &#123; //被要求不拦截，默认赋值false，表示不拦截 intercepted = false; &#125; &#125; else &#123; //没有找到子元素处理（即mFirstTouchTarget == null），也并非是Down事件，则默认拦截 intercepted = true; &#125; //如果被拦截，启动正常的事件分发。 //或者如果已经有一个处理手势的视图，则执行正常的事件分发。 if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; //新建一个TouchTarget TouchTarget newTouchTarget = null; //有没有获取到最新的TouchTarget，这里也是一个标志 boolean alreadyDispatchedToNewTouchTarget = false; //没有取消，并且没有被拦截的话就找子元素处理 if (!canceled &amp;&amp; !intercepted) &#123; View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; //如果当前ViewGroup有子控件，则开始寻找 if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; //获取位置 final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; //倒叙开始寻找 for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; //这里判断当前遍历到的这个子元素能不能接收点击事件， //如果不能进行下一次 if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; //从mFirstTouchTarget序列中（其实这里是一个单链表） //找与这个child对应的TouchTarget,没有 newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; //如果能够找到对应的，说明该view已经处理过当前点击事件序列前面一点的事件 //已经在其范围内接受触摸,除开它正在处理的再给它新的位置指针 newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); //如果能够运行到这里说明该子元素满足要求，可以接收点击事件 //dispatchTransformedTouchEvent中会执行子元素的dispatchTouchEvent //如果该子元素将事件消耗，则进入判断语句 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //如果这个事件消耗了，则生成一个对应的TouchTarget //并赋值给newTouchTarget //并且在addTouchTarget方法里也将这个赋值给了mFirstTouchTarget newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; //停止在子元素中寻找子元素去处理 break; &#125; ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; //mFirstTouchTarget == null如果这里为空说明没有找到子元素能够处理或者消耗了 if (mFirstTouchTarget == null) &#123; //直接传null进去，那么这个方法内部就会直接调用该ViewGroup的 //super.dispatchTouchEvent(event) handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); //---------------------------------------------------------- //后面代码对事件分发流程理解应该影响不大，就不看了 &#125; else &#123; TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled;&#125;呼~~好累，这么一分析啥原理不久都来了，什么解决滑动冲突的方法还不是信手拈来，什么外部拦截或者内部拦截的原理不久一下子清晰了。累了，去泡杯茶再来。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>干货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM 操作指令记录一览]]></title>
    <url>%2F2020%2F04%2F03%2FJVM-%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95%E4%B8%80%E8%A7%88%2F</url>
    <content type="text"><![CDATA[栈和局部变量操作将常量压入栈的指令aconst_null 将null对象引用压入栈iconst_m1 将int类型常量-1压入栈iconst_0 将int类型常量0压入栈iconst_1 将int类型常量1压入栈iconst_2 将int类型常量2压入栈iconst_3 将int类型常量3压入栈iconst_4 将int类型常量4压入栈iconst_5 将int类型常量5压入栈lconst_0 将long类型常量0压入栈lconst_1 将long类型常量1压入栈fconst_0 将float类型常量0压入栈fconst_1 将float类型常量1压入栈dconst_0 将double类型常量0压入栈dconst_1 将double类型常量1压入栈bipush 将一个8位带符号整数压入栈sipush 将16位带符号整数压入栈ldc 把常量池中的项压入栈ldc_w 把常量池中的项压入栈（使用宽索引）ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）从栈中的局部变量中装载值的指令iload 从局部变量中装载int类型值lload 从局部变量中装载long类型值fload 从局部变量中装载float类型值dload 从局部变量中装载double类型值aload 从局部变量中装载引用类型值（refernce）iload_0 从局部变量0中装载int类型值iload_1 从局部变量1中装载int类型值iload_2 从局部变量2中装载int类型值iload_3 从局部变量3中装载int类型值lload_0 从局部变量0中装载long类型值lload_1 从局部变量1中装载long类型值lload_2 从局部变量2中装载long类型值lload_3 从局部变量3中装载long类型值fload_0 从局部变量0中装载float类型值fload_1 从局部变量1中装载float类型值fload_2 从局部变量2中装载float类型值fload_3 从局部变量3中装载float类型值dload_0 从局部变量0中装载double类型值dload_1 从局部变量1中装载double类型值dload_2 从局部变量2中装载double类型值dload_3 从局部变量3中装载double类型值aload_0 从局部变量0中装载引用类型值aload_1 从局部变量1中装载引用类型值aload_2 从局部变量2中装载引用类型值aload_3 从局部变量3中装载引用类型值iaload 从数组中装载int类型值laload 从数组中装载long类型值faload 从数组中装载float类型值daload 从数组中装载double类型值aaload 从数组中装载引用类型值baload 从数组中装载byte类型或boolean类型值caload 从数组中装载char类型值saload 从数组中装载short类型值 将操作数栈中的值存入局部变量的指令istore 将int类型值存入局部变量lstore 将long类型值存入局部变量fstore 将float类型值存入局部变量dstore 将double类型值存入局部变量astore 将将引用类型或returnAddress类型值存入局部变量istore_0 将int类型值存入局部变量0istore_1 将int类型值存入局部变量1istore_2 将int类型值存入局部变量2istore_3 将int类型值存入局部变量3lstore_0 将long类型值存入局部变量0lstore_1 将long类型值存入局部变量1lstore_2 将long类型值存入局部变量2lstore_3 将long类型值存入局部变量3fstore_0 将float类型值存入局部变量0fstore_1 将float类型值存入局部变量1fstore_2 将float类型值存入局部变量2fstore_3 将float类型值存入局部变量3dstore_0 将double类型值存入局部变量0dstore_1 将double类型值存入局部变量1dstore_2 将double类型值存入局部变量2dstore_3 将double类型值存入局部变量3astore_0 将引用类型或returnAddress类型值存入局部变量0astore_1 将引用类型或returnAddress类型值存入局部变量1astore_2 将引用类型或returnAddress类型值存入局部变量2astore_3 将引用类型或returnAddress类型值存入局部变量3iastore 将int类型值存入数组中lastore 将long类型值存入数组中fastore 将float类型值存入数组中dastore 将double类型值存入数组中aastore 将引用类型值存入数组中bastore 将byte类型或者boolean类型值存入数组中castore 将char类型值存入数组中sastore 将short类型值存入数组中 wide指令wide 使用附加字节扩展局部变量索引 通用(无类型）栈操作nop 不做任何操作pop 弹出栈顶端一个字长的内容pop2 弹出栈顶端两个字长的内容dup 复制栈顶部一个字长内容dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈dup2 复制栈顶部两个字长内容dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈swap 交换栈顶部两个字长内容 类型转换i2l 把int类型的数据转化为long类型i2f 把int类型的数据转化为float类型i2d 把int类型的数据转化为double类型l2i 把long类型的数据转化为int类型l2f 把long类型的数据转化为float类型l2d 把long类型的数据转化为double类型f2i 把float类型的数据转化为int类型f2l 把float类型的数据转化为long类型f2d 把float类型的数据转化为double类型d2i 把double类型的数据转化为int类型d2l 把double类型的数据转化为long类型d2f 把double类型的数据转化为float类型i2b 把int类型的数据转化为byte类型i2c 把int类型的数据转化为char类型i2s 把int类型的数据转化为short类型 整数运算iadd 执行int类型的加法ladd 执行long类型的加法isub 执行int类型的减法lsub 执行long类型的减法imul 执行int类型的乘法lmul 执行long类型的乘法idiv 执行int类型的除法ldiv 执行long类型的除法irem 计算int类型除法的余数lrem 计算long类型除法的余数ineg 对一个int类型值进行取反操作lneg 对一个long类型值进行取反操作iinc 把一个常量值加到一个int类型的局部变量上 逻辑运算移位操作ishl 执行int类型的向左移位操作lshl 执行long类型的向左移位操作ishr 执行int类型的向右移位操作lshr 执行long类型的向右移位操作iushr 执行int类型的向右逻辑移位操作lushr 执行long类型的向右逻辑移位操作 按位布尔运算iand 对int类型值进行“逻辑与”操作land 对long类型值进行“逻辑与”操作ior 对int类型值进行“逻辑或”操作lor 对long类型值进行“逻辑或”操作ixor 对int类型值进行“逻辑异或”操作lxor 对long类型值进行“逻辑异或”操作 浮点运算fadd 执行float类型的加法dadd 执行double类型的加法fsub 执行float类型的减法dsub 执行double类型的减法fmul 执行float类型的乘法dmul 执行double类型的乘法fdiv 执行float类型的除法ddiv 执行double类型的除法frem 计算float类型除法的余数drem 计算double类型除法的余数fneg 将一个float类型的数值取反dneg 将一个double类型的数值取反 对象和数组对象操作指令new 创建一个新对象checkcast 确定对象为所给定的类型getfield 从对象中获取字段putfield 设置对象中字段的值getstatic 从类中获取静态字段putstatic 设置类中静态字段的值instanceof 判断对象是否为给定的类型 数组操作指令newarray 分配数据成员类型为基本上数据类型的新数组anewarray 分配数据成员类型为引用类型的新数组arraylength 获取数组长度multianewarray 分配新的多维数组 控制流条件分支指令ifeq 如果等于0，则跳转ifne 如果不等于0，则跳转iflt 如果小于0，则跳转ifge 如果大于等于0，则跳转ifgt 如果大于0，则跳转ifle 如果小于等于0，则跳转if_icmpcq 如果两个int值相等，则跳转if_icmpne 如果两个int类型值不相等，则跳转if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转ifnull 如果等于null，则跳转ifnonnull 如果不等于null，则跳转if_acmpeq 如果两个对象引用相等，则跳转if_acmpnc 如果两个对象引用不相等，则跳转 比较指令lcmp 比较long类型值fcmpl 比较float类型值（当遇到NaN时，返回-1）fcmpg 比较float类型值（当遇到NaN时，返回1）dcmpl 比较double类型值（当遇到NaN时，返回-1）dcmpg 比较double类型值（当遇到NaN时，返回1） 无条件转移指令goto 无条件跳转goto_w 无条件跳转（宽索引） 表跳转指令tableswitch 通过索引访问跳转表，并跳转lookupswitch 通过键值匹配访问跳转表，并执行跳转操作 异常athrow 抛出异常或错误finally子句jsr 跳转到子例程jsr_w 跳转到子例程（宽索引）rct 从子例程返回方法调用与返回 方法调用指令invokcvirtual 运行时按照对象的类来调用实例方法invokespecial 根据编译时类型来调用实例方法invokestatic 调用类（静态）方法invokcinterface 调用接口方法 方法返回指令ireturn 从方法中返回int类型的数据lreturn 从方法中返回long类型的数据freturn 从方法中返回float类型的数据dreturn 从方法中返回double类型的数据areturn 从方法中返回引用类型的数据return 从方法中返回，返回值为void 线程同步montiorenter 进入并获取对象监视器monitorexit 释放并退出对象监视器 JVM指令助记符变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_加：iadd,ladd,fadd,dadd减：isub,lsub,fsub,dsub乘：imul,lmul,fmul,dmul除：idiv,ldiv,fdiv,ddiv余数：irem,lrem,frem,drem取负：ineg,lneg,fneg,dneg移位：ishl,lshr,iushr,lshl,lshr,lushr按位或：ior,lor按位与：iand,land按位异或：ixor,lxor类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)创建类实便：new创建新数组：newarray,anewarray,multianwarray访问类的域和类实例域：getfield,putfield,getstatic,putstatic把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore获取数组长度：arraylength检相类实例或数组属性：instanceof,checkcast操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmplfcmpg,dcmpl,dcmpg复合条件转移：tableswitch,lookupswitch无条件转移：goto,goto_w,jsr,jsr_w,ret调度对象的实便方法：invokevirtual调用由接口实现的方法：invokeinterface调用需要特殊处理的实例方法：invokespecial调用命名类中的静态方法：invokestatic方法返回：ireturn,lreturn,freturn,dreturn,areturn,return异常：athrowfinally关键字的实现使用：jsr,jsr_w,ret]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-内存管理和垃圾回收]]></title>
    <url>%2F2020%2F04%2F01%2FJVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[内存管理 方法区 （元空间/持久代）线程共享，存放类加载之后存放类的数据结构，静态常量，JIT(即时编译器)编译后代码也在方法区存放 堆区线程共享，对象所在的区域，也是垃圾回收的主要场所 虚拟机栈按照方法执行的顺序，先进后出 栈帧局部变量表操作数栈动态链接方法出口来看看一段简单的代码，主要分析demo()方法 12345678910111213public class Main &#123; public static void main(String[] args)&#123; demo(); &#125; public static int demo()&#123; int a = 20; int b = 30; int c = (a + b) * 100; return c; &#125;&#125;这里的demo（）方法会有一个局部变量表 赋默认值，真正使用的时候才会对其进行初始化。 我们把编译好了的java文件利用javap命令对class文件进行反汇编 javap -c Main.class 123456789101112131415161718192021222324252627282930313233Compiled from "Main.java"public class Main &#123; public Main(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return public static void main(java.lang.String[]); Code: //后面的#加数字代表动态链接，不然程序无法准确的找到 // (执行静态方法#2【#2就代表一个静态方法，通过#2就可以准确找到所要执行的方法】) 0: invokestatic #2 3: pop //将栈顶一个字长的数据弹出来 4: return public static int demo(); Code: 0: bipush 20 //将一个8位带符号整数（20）压入栈 2: istore_0 //将操作数栈中栈顶int类型的值存入局部变量0 3: bipush 30 //将一个8位带符号整数（30）压入栈 5: istore_1 //将操作数栈中栈顶int类型的值存入局部变量1 6: iload_0 //将局部变量0中的int类型值装载到操作数栈 7: iload_1 //将局部变量1中的int类型值装载到操作数栈 8: iadd //操作数栈中的前两个int弹出并相加，并将结果压入操作数栈顶 9: bipush 100 //将一个8位带符号整数（100）压入栈 11: imul //操作数栈中的前两个int弹出并相乘，并将结果压入操作数栈顶 12: istore_2 //将操作数栈中栈顶int类型的值存入局部变量2 13: iload_2 //将局部变量2中的int类型值装载到操作数栈 14: ireturn //将操作数栈中的int值返回 //那么前面的序号什么意思呢，这里就是程序计数器为了保证指令的正确执行所需要的序号&#125;从注释可以很清晰的看出来没一步都在做什么，至于JVM指令都代表什么可以看一下这个记录文档JVM指令一览收藏 至于动态上面的动态链接，这里重新给一个例子。 123456789class Demo&#123;&#125;public class Main &#123; public static void main(String[] args)&#123; Demo demo = new Demo(); &#125;&#125;这次我们使用输出信息更加精确的javap -v Main.class 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Compiled from "Main.java"public class Main minor version: 0 major version: 56 flags: (0x0021) ACC_PUBLIC, ACC_SUPER this_class: #4 // Main super_class: #5 // java/lang/Object interfaces: 0, fields: 0, methods: 2, attributes: 1Constant pool://这里声明一些映射，方便下面链接 #1 = Methodref #5.#21 // java/lang/Object."&lt;init&gt;":()V #2 = Class #22 // Demo #3 = Methodref #2.#21 // Demo."&lt;init&gt;":()V #4 = Class #23 // Main #5 = Class #24 // java/lang/Object #6 = Utf8 &lt;init&gt; #7 = Utf8 ()V #8 = Utf8 Code #9 = Utf8 LineNumberTable #10 = Utf8 LocalVariableTable #11 = Utf8 this #12 = Utf8 LMain; #13 = Utf8 main #14 = Utf8 ([Ljava/lang/String;)V #15 = Utf8 args #16 = Utf8 [Ljava/lang/String; #17 = Utf8 demo #18 = Utf8 LDemo; #19 = Utf8 SourceFile #20 = Utf8 Main.java #21 = NameAndType #6:#7 // "&lt;init&gt;":()V #22 = Utf8 Demo #23 = Utf8 Main #24 = Utf8 java/lang/Object&#123; public Main(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 5: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this LMain; public static void main(java.lang.String[]);//main方法 descriptor: ([Ljava/lang/String;)V flags: (0x0009) ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=1 //new 指令在堆中创建一个Java对象，并将该对象的地址压入操作数栈 0: new #2 // class Demo //复制栈顶一个字长的数据（这里是上面创建的java对象的地址，此时操作数栈中有两个地址） 3: dup //使用栈顶的地址调用方法并弹出栈顶 4: invokespecial #3 // Method Demo."&lt;init&gt;":()V //将引用类型或returnAddress类型值存入局部变量1(这里将剩下的一份地址存到局部变量里面去了) 7: astore_1 8: return LineNumberTable: line 7: 0 line 8: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String; 8 1 1 demo LDemo;&#125;程序计数器当前线程执行的字节码的位置指示器 本地方法栈为JVM提供使用native方法的服务大致结构和虚拟机栈差不多 垃圾回收STW（stop the world）：停止其他所有工作 Minor GC：轻量级，耗时短，会出现STW Full GC：重量级，耗时长，会出现STW 判断是否可回收引用计数根搜索算法所谓的GC根对象包括： 虚拟机栈中引用的对象（栈帧中的本地变量表）；方法区中的常量引用的对象；方法区中的类静态属性引用的对象；本地方法栈中JNI（Native方法）的引用对象。活跃线程。从根对象开始向下寻找，能够在引用链上找到这个对象就说明这个对象是可以存活的。 在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程： 如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize（）方法（可看作析构函数）。当对象没有覆盖finalize（）方法，或finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。如果该对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize（）方法。finalize（）方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize（）方法最多只会被系统自动调用一次），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize（）方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。分代垃圾回收新生代对象会被优先被分配到这个地方 老年代当对象满足一定条件之后会被放到老年代 注意：java8之后老年代在Full GC之前是会执行一次Minor GC的，如果内存依然不足，才会执行Full GC 算法标记清除优点：快缺点：会出现内存碎片，导致大对象进来会直接进入老年代 标记整理（老年代回收算法）解决上面的的内存碎片问题，合并内存碎片，也就是将仍存在的对象移动到一起，比较耗时复制From区和To区来实现这个算法，这两个区域分别是Survivor 0和Survivor 1这也是为什么需要交换的原因，To区永远保持空白]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>干货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类加载和类加载器]]></title>
    <url>%2F2020%2F04%2F01%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[类加载流程链接和加载时并行的，没有谁先再后的先后顺序，涉及到源码中对链接的方法的调用 加载”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事： 通过一个类的全限定名来获取其定义的二进制字节流将这个字节流所代表的的静态存储结构转化为方法区中的运行时数据结构（初始化）在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。至于JVM的内存管理和分区结构大致是以下 相对于类加载的其他阶段而言，加载阶段是可控性最强的阶段，因为程序员可以使用系统的类加载器加载，还可以使用自己的类加载器加载（从网络，本地，或者任意地方加载字节码文件）。 类加载器的作用就是上面虚拟机需要完成的三件事，我们定义的类加载器也是一样 链接验证保证格式正确，符合java语法规范，不会对jvm造成危害文件格式验证，是否符合class文件的格式的规范元数据验证，对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求字节码验证，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。符号引用验证，发生在虚拟机将符号引用转化为直接引用的时候。主要是对类自身以外的信息进行校验。目的是确保解析动作能够完成。准备准备类变量（静态变量），赋默认值解析解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。什么是符号应用和直接引用呢？符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）直接引用：是可以指向目标的指针、相对偏移量或者是一个能直接或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。初始化执行类构造器 有父类，但是父类还没有被初始化先执行父类的初始化同一个命名空间只会初始化一次类加载器的命名空间是由类加载器本身以及所有父加载器所加载出来的binary name(full class name)组成.在同一个命名空间里，不允许出现二个完全-样的binary name。在不同的命名空间种，可以出现二个相同的binary name。当时二者对应的Class对象是相互不能感知到的，也就是说Class对象的类型是不一样的。子加载器的命名空间中的binary name对应的类中可以访问父加载器命名空间中binary name对应的类，反之不行两个重要的init方法init是instance实例构造器，对非静态变量解析初始化 clinit是class类构造器对静态变量，静态代码块进行初始化 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的， 静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不可以使用，会报非法前置引用的错误。 例如： 12345static &#123; a = 0;//可以，因为在链接中的准备阶段就已经准备好了这个变量，这里相当于重新赋值 System.out.println(a);//不可以，会被提示非法前置引用&#125;static int a = 0;//真正对程序员所期望的初始值进行初始化相关例子经典面试题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Person&#123; static int a; static int b = 0; static Person instance = new Person(); Person()&#123; a++; b++; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Person person = Person.instance; System.out.println(Person.a); System.out.println(Person.b); &#125;&#125;************************************输出： 1 1************************************ /*** 将Person类中的* static Person instance = new Person();* 提到最前面*/class Person&#123; static Person instance = new Person(); static int a; static int b = 0; Person()&#123; a++; b++; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Person person = Person.instance; System.out.println(Person.a); System.out.println(Person.b); &#125;&#125;************************************输出： 1 0************************************原因： 原因在准备 类加载器BootstrapClassLoader由C实现ExtensionClassLoader由java实现，继承于ClassLoaderApplicationClassLoader由java实现，继承于ClassLoader自定义加载器必须继承ClassLoader，默认父加载器为ApplicationClassLoader，可通过重写构造器自定义父加载器源码中给出的Demo注意：有层级关系，相互没有继承关系 双亲委派模型简单来说，一个类似于“android中的事件分发的流程” 加载类时依次向上层层调用，请求上层查找并加载，若上层不能查找或者加载到，自己加载或者查找 java.lang.ClassLoader.java加载类关键代码 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized(this.getClassLoadingLock(name)) &#123; Class&lt;?&gt; c = this.findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; //判断父加载器是否为空 if (this.parent != null) &#123; //有，则优先调用父加载器的loadClass加载方法，层层调用 //上面一层的也会这样要父加载器加载 c = this.parent.loadClass(name, false); &#125; else &#123; //父加载器为空，则使用启动类加载器来加载 c = this.findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException var10) &#123; &#125; //判断c是否为空 //为空？表示当前类加载器的所有上层加载器都不能找到或者加载此类 //不为空？表示当前类加载器的某个上层加载器已经找到或者加载此类，并返回了Class对象 if (c == null) &#123; long t1 = System.nanoTime(); c = this.findClass(name); PerfCounter.getParentDelegationTime().addTime(t1 - t0); PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; this.resolveClass(c); &#125; return c; &#125;&#125;优点避免类的重复加载保护程序安全，防止核心API随意篡改如何保护？例如：自定义类:java.lang. String自己建一个全类名跟String一样的类，如果这个类在java中的String类之前被加载，那么Java Api中的String会被我这个String替换，并且不再加载java自己的String。加载时机必须要有类去主动使用该 Class。使用 new 关键字、反射、克隆、反序列化；调用类的静态方法调用一个类的子类的时候会初始化其父类包含 main() 方法的类（相当于第二条）。被动使用则不会去装载 Class。调用了其父类的静态方法123456public class Main &#123; public static void main(String[] args)&#123; ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); Class mClass = classLoader.loadClass("People"); &#125;&#125;12输出：People静态代码块没有执行，说明此时方法还没有被调用，说明只加载没有初始化，原因在哪？ java.lang.ClassLoader#loadClass(java.lang.String, boolean)，这个方法的第二个参数，就是控制链接的默认调用loadClass传入的时false，如果传入true最后会调用native方法进行链接 123public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false);&#125;既加载又初始化上面举了很多例子，我们看一个关键的 还是下面这一些代码 12345public class People &#123; static &#123; System.out.println("PeopleLoad"); &#125;&#125;123456public class Main &#123; public static void main(String[] args) &#123; ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); Class.forName("People", true, classLoader); &#125;&#125;12输出：PeopleLoad]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>干货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当Activity异常销毁FragmentManager做了什么]]></title>
    <url>%2F2020%2F03%2F27%2F%E5%BD%93Activity%E5%BC%82%E5%B8%B8%E9%94%80%E6%AF%81FragmentManager%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[最近在做项目的时候因为Activity和FragmentManager，使项目遇到了一些问题，Activity异常销毁重启之后，上次加载进去的Fragment也依然存在FragmentManager当中，但是在Activity中的初始化函数仍然会生成新的fragment进去。以此导致了界面出现了重复加载的问题。 下面的分析都是基于Androidx的源码，和support有些区别 问题出现可能的原因FragmentManager生命周期更长销毁之前恢复机制将这些fragment数据进行了保存，重新创建时恢复了FragmentManager生命周期更长？？？Activity异常销毁（或者配置更改）时FragmentManager会像ViewModel一样自动保存下来？以便于下次加载使用吗 证明一下 123456789101112class MainActivity : AppCompatActivity() &#123; companion object&#123; const val TAG = "MainActivityDemo" &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) Log.d(TAG, "$&#123;supportFragmentManager&#125;") &#125;&#125;接下来我们开启分屏 很明显这里不是同一个对象，这个原因pass。 被恢复了？？我们来看看FragmentActivity中onSaveInstanceState干了什么 12345678910protected void onSaveInstanceState(@NonNull Bundle outState) &#123; super.onSaveInstanceState(outState); markFragmentsCreated();//标记已经创建的fragment mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP); Parcelable p = mFragments.saveAllState();//保存状态 if (p != null) &#123; outState.putParcelable(FRAGMENTS_TAG, p);//放到Bundle &#125; // do something..................&#125;这里的确做了保存，那么我们看看在哪里用到了FRAGMENTS_TAG这个标志位 12345678910111213protected void onCreate(@Nullable Bundle savedInstanceState) &#123; mFragments.attachHost(null /*parent*/); if (savedInstanceState != null) &#123; Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);//获取保存的数据 mFragments.restoreSaveState(p);//对数据进行了恢复 // do something............ &#125; // do something............ mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE); mFragments.dispatchCreate();&#125;具体保存操作是怎么操作的这个，自己去研究，不在本篇文章讨论范围 涉及到FragmentManager对fragment的onSaveInstanceState和onRestoreInstanceState的层层调用 我们来看看一个Fragment到底保存了一些什么东西（以下我只保留了关键函数） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980final class FragmentState implements Parcelable &#123; final String mClassName; final String mWho; final boolean mFromLayout; final int mFragmentId; final int mContainerId; final String mTag; final boolean mRetainInstance; final boolean mRemoving; final boolean mDetached; final Bundle mArguments; final boolean mHidden; final int mMaxLifecycleState; Bundle mSavedFragmentState; Fragment mInstance; //传入fragment对数据进行构造 FragmentState(Fragment frag) &#123; mClassName = frag.getClass().getName();//类名 mWho = frag.mWho;//这个fragment对象独有的id mFromLayout = frag.mFromLayout;//是否是直接从布局实例化的（boolean） mFragmentId = frag.mFragmentId;//若是动态添加的，则为容器id，从视图添加则为布局中的id mContainerId = frag.mContainerId;//动态添加时，容器的id mTag = frag.mTag; //这个属性有些复杂，如果fragment设置这个属性那么 //这个fragment会被存到FragmentManagerViewModel里， //这个viewModel的owner是FragmentManager依附的Activity //由于ViewModel的特性，activity配置更改后viewModel会自动保存 //下一次FragmentManager恢复数据时会优先判断判断FragmentManagerViewModel //里是否保存，如果保存了就不调用下面的instantiate创建新的Fragment对象 mRetainInstance = frag.mRetainInstance; mRemoving = frag.mRemoving;//是否从activity中移除 mDetached = frag.mDetached;//是否被禁用，当被detach时会被设置为false mArguments = frag.mArguments;//这个是个Bundle，用来传递东西的 mHidden = frag.mHidden;//当前Fragment是否时隐藏状态 mMaxLifecycleState = frag.mMaxState.ordinal(); &#125; //通过保存的信息恢复一个完整的Fragment public Fragment instantiate(@NonNull ClassLoader classLoader, @NonNull FragmentFactory factory) &#123; if (mInstance == null) &#123; if (mArguments != null) &#123; mArguments.setClassLoader(classLoader); &#125; mInstance = factory.instantiate(classLoader, mClassName); mInstance.setArguments(mArguments); if (mSavedFragmentState != null) &#123; mSavedFragmentState.setClassLoader(classLoader); mInstance.mSavedFragmentState = mSavedFragmentState; &#125; else &#123; // When restoring a Fragment, always ensure we have a // non-null Bundle so that developers have a signal for // when the Fragment is being restored mInstance.mSavedFragmentState = new Bundle(); &#125; mInstance.mWho = mWho; mInstance.mFromLayout = mFromLayout; mInstance.mRestored = true; mInstance.mFragmentId = mFragmentId; mInstance.mContainerId = mContainerId; mInstance.mTag = mTag; mInstance.mRetainInstance = mRetainInstance; mInstance.mRemoving = mRemoving; mInstance.mDetached = mDetached; mInstance.mHidden = mHidden; mInstance.mMaxState = Lifecycle.State.values()[mMaxLifecycleState]; if (FragmentManagerImpl.DEBUG) &#123; Log.v(FragmentManagerImpl.TAG, "Instantiated fragment " + mInstance); &#125; &#125; return mInstance; &#125;&#125;从上面的代码注释就可以看出，保存了哪些东西 看来这个解答时正解，哦耶]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>查漏补缺</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin的let、with、run、apply、also系列方法记录]]></title>
    <url>%2F2020%2F03%2F27%2Fkotlin%E7%9A%84let%E3%80%81with%E3%80%81run%E3%80%81apply%E3%80%81also%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[let使用场景场景一: 最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理。场景二: 然后就是需要去明确一个变量所处特定的作用域范围内可以使用提醒在函数块内可以通过 it 指代该对象。返回值为函数块的最后一行或指定return表达式 示例123Any().let &#123; it: Any -&gt;&#125;with提醒在函数块内可以通过 this 指代该对象。返回值为函数块的最后一行或指定return表达式 示例123with(Any())&#123; &#125;run解释let和with的结合，函数块内，可以通过this代指该对象，返回值为函数块的最后一行或指定return表达式 示例123Any().run &#123; &#125;apply与run类似，唯一的不同是apply始终返回该对象 示例123Any().apply &#123;&#125;also结合apply和let 函数始终返回该对象，函数类可以通过it访该对象 示例123Any().also &#123; it: Any -&gt;&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fitsSystemWindows相关总结]]></title>
    <url>%2F2020%2F03%2F18%2FfitsSystemWindows%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[先上结论1android:fitsSystemWindows="true"默认情况下，设置它的view会添加一些内边距，用来留出一些系统的window的区域，例如状态栏或者底部的虚拟键盘日常我们最常见的就只有这两个，但不排除其他或者后面会出现的一些新的系统window要留出，所以一旦设置这个属性之后你自己设置的所有的padding都会失效，上下左右全部，记住是全部另外在xml文件里，配置了这个属性为true的，哪个控件写在前面谁的就生效，而且只能生效一个，在它之后的后不会生效。View是可以对fitsSystemWindows进行个性化的，也就是说可以替换默认的添加Padding预留系统视窗的操作，最好的例子我们在下面会讲]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>归纳总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解volatile和并发编程的三大特性]]></title>
    <url>%2F2020%2F03%2F11%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[一切之前早期计算机中CPU和内存的速度是差不多的，但在现代计算机中，CPU的指令速度远超内存的存取速度,由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。 JMM抽象结构模型JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。 从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。 本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。 下面这个图很好的说明了JMM的工作方式 那么高速缓存弥补了CPU和内存之间的发展差异，带来了好处，自然就会带来一些问题。 可见性多个线程同时对共享变量进行操作，但是实际的运算是与本地内存和CPU交互，运算结果是线程之间不可见的，只有操作之后将本地内存副本刷新到主存，其他线程再去读取才是最新的值，如果操作完成，还没来得及刷新到主内存，其他线程就会拿到旧值，这样就会对结果造成影响。 在Java中我们就可以使用volatile关键字或者是加锁来保证可见性 被volatile修饰的变量一旦被更改就会立即把结果刷新到主内存，保证了变量的可见性。 原子性原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。 有序性重排序根据Java内存模型中的规定，可以总结出以下几条happens-before规则8。Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。 程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于Cvolatilevolatile可以保证可见性，数据一旦修改可以及时更新到主存，可以杜绝更改之后没来得及刷新到主存而其他线程读取旧值而造成的异步问题volatile可以一定程度上保证有序性所有在 volatile 修饰的变量写操作之前的写操作，将会对随后该 volatile 修饰的变量读操作之后的语句可见。禁止 JVM 重排序：volatile 修饰的变量的读写指令不能和其前后的任何指令重排序，其前后的指令可能会被重排序。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android消息机制深入了解]]></title>
    <url>%2F2020%2F03%2F08%2FAndroid%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[为什么消息机制这么重要呢其实一个安卓的app也是有自己的main方法的，跟一个普通的java程序并没有太大的区别，只不过用户接触不到这个方法，这个方法在ActivityThread这个类里面，这个也就是android中所说的UI线程。你可能在想一个问题，那么既然是一个有main方法的java程序，那么一整个安卓的app究竟是怎么来运行的呢，如何做到和用户交互并执行这些代码的呢？？（这里涉及到很多东西，本文只讲与消息机制相关的，文章末尾我会一一解释） 消息机制重要的三大成员MessageQueueLooperHandler一个线程只能有一个Looper和MessageQueue，但是可以有多个handler，为什么呢？后面我们慢慢会讲到。那么这三者是如何配合的呢，简单来说，MessageQueue就是一根运输消息管道，handler负责不断往里面放，Looper负责不断从里面取出来，又交给发送的这个handler去处理，那么就出现两个问题？ 那么为什么要这样子设计？这样子设计怎么实现的跨线程通信为什么handler放进去最后looper又要交还给发送消息的这个handler去处理通过后面的源码解析，就能自己领会这两个问题 消息机制主要流程详解如果你要在一个线程中使用消息机制 首先需要Looper.prepare();和Looper.loop();，然后你就可以使用你的handler发送消息了。 主线程是不需要自己Looper.prepare();和Looper.loop();在ActivityThread的main方法里面就已经执行了类似代码Looper.prepareMainLooper();和Looper.loop(); 下面我会逐一从源码层面来分析整个消息机制的主要流程，会不会很难呢，要不要继续学下去，头发 - -。 Looper.prepare()；首先我们点进去看看代码是如何实现的 1234567891011121314151617181920212223//这个函数在ActivityThread的main方法里面执行,用户创建主线程的Looper对象public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125;//通常我们在其他线程如果需要用到消息机制，会执行这个方法public static void prepare() &#123; prepare(true);&#125;//函数重载，这个参数用于构造一个可以关闭或者无法关闭的Looperprivate static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;最重要的方法就是第三个prepare(boolean quitAllowed)，我们可以看到代码很短，也很好理解。 首先调用这个这个Looper类里面一个静态变量sThreadLocal 1static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();这是一个ThreadLocal&lt;Looper&gt;类型的一个变量，而且是直接new出来的,点击进去看 12public ThreadLocal() &#123;&#125;查看ThreadLocal源代码里面的构造方法也没有做任何操作，说明本身这个变量是里是没有我们想要的东西的 那么关键肯定是在sThreadLocal.get()里面，通过后面的抛出异常 throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); 我们可以断定这个判断肯定是用来判断当前线程是否已经存在了一个Lopper对象 接下来我们来看get()方法内部 123456789101112131415//代码不是很多，我们一步步分析public T get() &#123; Thread t = Thread.currentThread();//获得当前的线程对象 ThreadLocalMap map = getMap(t);//从当前线程拿到一个ThreadLocalMap if (map != null) &#123;//如果这个ThreadLocalMap不为空 //从里面取得Looper（这里做了一个包装，稍后会讲到） ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123;//如果Lopper不为空 @SuppressWarnings("unchecked") T result = (T)e.value; return result;//直接返回Looper &#125; &#125; return setInitialValue();//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作&#125;可能虽然有注释还是有些疑惑，下面我们一一来讲解一下 Why 首先我们来看看ThreadLocalMap map = getMap(t);中get(t)的代码 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;可以看到，是直接返回了当前线程对象的一个成员变量threadLocals，那么这个threadLocals究竟是个什么东西呢？ ThreadLocal和ThreadLocalMapEntry是ThreadLocalMap的静态内部类，ThreadLocalMap是ThreadLocal的静态内部类 首先我们来看ThreadLocal，顾名思义，直接翻译过来就是 “线程本地” ？？ 我们来看看这个类的介绍注释 1234567891011121314151617/** * This class provides thread-local variables. These variables differ from * their normal counterparts in that each thread that accesses one (via its * &#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized * copy of the variable. &#123;@code ThreadLocal&#125; instances are typically private * static fields in classes that wish to associate state with a thread (e.g., * a user ID or Transaction ID). *//*** 谷歌翻译版本:* 此类提供线程局部变量* 这些变量不同于它们的普通副本，* 因为每个访问一个变量的线程（通过其&#123;@code get&#125;或&#123;@code set&#125;方法）* 都有自己的、独立的变量副本。* &#123;@code ThreadLocal&#125;实例通常是类中的私有静态字段，希望将状态与线程关联（例如，*用户ID或事务ID）。*/通过注释我们可以很轻松的理解到，原来这个东西就是为每一个线程创建一个单独的变量副本的呀。 我们来看看到底怎么使用 12345678910111213141516171819202122232425262728293031323334353637383940public class Main &#123; public static void main(String[] args) &#123; ThreadLocal&lt;Integer&gt; integerThreadLocal = new ThreadLocal&lt;&gt;()&#123; //这个方法专门用来提供开发者复写，提供副本默认值 @Override protected Integer initialValue() &#123; return 2333;//默认值我们这设置为 &#125; &#125;; for (int i = 0; i &lt; 5; i++) &#123; new Thread()&#123; @Override public void run() &#123; //为这个ThreadLocal&lt;Integer&gt;在当前线程存一个副本，值为3222 //如果不是基本数据类型，注意值传递和引用传递的区别，这里需要new一个新的放进去 //例如：ThreadLocal的泛型是Runnable, //那么就需要新建一个独立的Runnable实现类的对象 //runnableThreadLocal.set(new Runnable() &#123; // @Override // public void run() &#123; // // &#125; // &#125;;) integerThreadLocal.set(3222); //获取当前线程的副本，如果之前没有set()，那么默认值为2333 //如果之前set()了，就会取得set()的那个对象 integerThreadLocal.get(); /** * 通过以上代码，在这5个线程里都有了一个与integerThreadLocal对应 * 变量副本，这个副本是Integer类型的，每个线程通过integerThreadLocal.get() * 取到的都是线程独有的，与其他线程完全隔离的一个副本 */ &#125; &#125;.start(); &#125; &#125;&#125;通过上面的注释就足以理解这个东西的用法，这时候我们回到安卓来看看消息机制这里的设计，是不是就一下子恍然大悟了，我这再梳理一下 首先Lopper中是有一个sThreadLocal理解了上面小Demo,就能知道因为这个sThreadLocal的存在，我们就可以在每一个线程存一个Looper副本看，这是不是就很清晰了然后我们来看看ThreadLocalMap，前面我们看到ThreadLocal.get()的get()方法,这里再把代码贴一下 123456789101112131415161718public T get() &#123; Thread t = Thread.currentThread();//获得当前的线程对象 ThreadLocalMap map = getMap(t);//从当前线程拿到一个ThreadLocalMap if (map != null) &#123;//如果这个ThreadLocalMap不为空 //从里面取得Looper（这里做了一个包装，稍后会讲到） ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123;//如果Lopper不为空 @SuppressWarnings("unchecked") T result = (T)e.value; return result;//直接返回Looper &#125; &#125; return setInitialValue();//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;从上面的代码可以知道，一个线程对象里面是有一个threadLocals属性的，它是一个ThreadLocalMap类型的变量。就是它用来储存各种存在当前线程的副本。他是一个键值对存储的形式,下面是ThreadLocalMap的set（）方法的声明 1set(ThreadLocal&lt;?&gt; key, Object value)具体实现是比较复杂的，用到哈希表来储存，这里不展开讲了，有兴趣可以去了解一下，文章后面会有超链接。 然后我们来看看ThreadLocalMap.Entry e = map.getEntry(this);这个行代码，肯定很多人都会有疑惑，首先我们需要看一下ThreadLocalMap.Entry这个静态内部类 123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125;这里你可以看到这里是直接继承WeakReference弱引用这个类的，那为什么要这么设计呢？ 这里我大致的说一下，ThreadLocal是为了每个线程中的对象副本服务的，一旦我不需要使用ThreadLocal这个对象了，那么我肯定会将ThreadLocal对象的强引用去掉，以防止内存泄漏，但是这个如果不这么设计，如果有一个线程的生命周期比ThreadLocal长，那么必定会持有ThreadLocal的引用，这样就会导致内存泄漏，ThreadLocal没有被使用但是却无法被GC回收。相比之下，这样设计就不会出现这个问题。 Looper的构造方法1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);//生成一个MessageQueue，并作为成员保存在Looper中 mThread = Thread.currentThread();//绑定当前线程&#125;从上面的代码也印证了Looper和MessageQueue一般都是同时出现的，而且都只能有一个的言论（因为prepare方法在一个线程调用一次，前面代码提到过）。 Looper.loop1234567891011121314151617181920212223242526272829//因为方便，我只选择了关键代码public static void loop() &#123; final Looper me = myLooper();//取得当前线程的Looper，当然实际上也是通过sThreadLocal.get() if (me == null) &#123;//如果没有说明没有调用prepare(),抛出异常 throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue;//从当前的Looper对象里取得对应的MessageQueue //do something............ for (; ; ) &#123; Message msg = queue.next(); // 取出消息，这里可能会堵塞，直到重新取到消息 if (msg == null) &#123; //如果返回为空，则表示MessageQueue正在退出，所以这里也直接退出无限循环 //这里是只有MessageQueue调用quit(boolean safe)方法才会退出 //下面会有详细解释 return; &#125; //do something............. //这个target是发送这个消息的handler，取得消息之后让发送的这个handler去处理 //后面我们会讲到，handler是如何把这个消息发送到当前这个MessageQueue中，并且target的赋值 msg.target.dispatchMessage(msg); //do something............. msg.recycleUnchecked();//回收这个消息 &#125;&#125;通过代码应该很清晰就能展现出关键点，这里就不再赘述 因为这里涉及到Looper.loop退出的情况，下面我们用代码类分析一下，关键就在queue.next()，为了便于理解还是只凸显出主要代码，还有很多MessageQueue的消息处理的一些代码就不赘述了，下面代码重点看那个返回值为空的判断语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Message next() &#123; //do something.......... for (; ; ) &#123;//next中也是一个无限循环着也就很好的说明为什么next()是一个可堵塞的方法啦 //do something.......... if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; //这里是后面handler的sendMessage方法会给message添加一个时间的处理 if (now &lt; msg.when) &#123; //do something.......... &#125; else &#123; //do something.......... return msg;//如果所有条件都满足，就可以直接返回这个message了 &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. // 前面没有返回，这里如果为true只就直接返回null，前面Looper.loop就退出了 if (mQuitting) &#123; dispose(); return null; &#125; //do something.......... if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; //do something.......... &#125;&#125;我们来看看mQuitting这个变量是在哪被赋值为true的 1234567891011121314151617181920212223void quit(boolean safe) &#123; //mQuitAllowed这个其实在前文多次提到了，Looper和MessageQueue的构造方法都需要 //用来设定是否可以被退出 if (!mQuitAllowed) &#123; throw new IllegalStateException("Main thread not allowed to quit."); &#125; synchronized (this) &#123; if (mQuitting) &#123; return; &#125; mQuitting = true;//关键代码，这里赋值为true if (safe) &#123; removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked(); &#125; // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); &#125;&#125;从上面分析我们可以知道一旦调用了MessageQueue的quit的方法那么MessageQueue下一个利用next方法去取消息就会返回null，返回null就导致Looper的loop(也就是无限取消息的循环退出了),那么就有一个问题了，Looper也有一个quit方法，怎么实现的呢？ 123public void quit() &#123; mQueue.quit(false);&#125;恍然大悟！！！！！！！ handler.sendMessage()看发送消息之前我们需要先看看Handler的构造方法 12345678910111213141516171819202122//无参构造函数public Handler() &#123; this(null, false);&#125;//有参构造函数public Handler(@Nullable Callback callback, boolean async) &#123; //do something............ //获取当前线程的Looper mLooper = Looper.myLooper(); if (mLooper == null) &#123;//同样如果没有Looper会报错（没有Looper.prepare()） throw new RuntimeException( "Can't create handler inside thread " + Thread.currentThread() + " that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue;//绑定当前线程的MessageQueue //do something............&#125;可以看出Handler在那个线程创建，它就会直接绑定哪个线程的MessageQueue，之后它sendMessage()就可以直接放到这个MessageQueue里面 还是直接来看sendMessage()的代码 12345678910111213141516171819202122232425262728293031323334353637//点进来第一个方法是这个public final boolean sendMessage(@NonNull Message msg) &#123; return sendMessageDelayed(msg, 0);&#125;//发送延迟处理的消息public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue;//拿到创建Handler时绑定的那个MessageQueue if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this;//【发送的消息】绑定【发送消息的这个handler】 msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; //把消息交给MessageQueue去排序消息，这里是根据uptimeMillis转成具体时刻来排序的 //这里要注意，发送的延迟消息，只能保持设置的时间前这个消息不被处理 //但是无法保证这个消息具体在设置的时间之后的那个时候被处理 return queue.enqueueMessage(msg, uptimeMillis);&#125;handler.post()还是直接看代码，如果上面的理解了这个就非常简单了，只有一些区别 1234567891011public final boolean post(@NonNull Runnable r) &#123; //这里仍然还是调用的发送延时消息的方法，区别是下面那个方法 return sendMessageDelayed(getPostMessage(r), 0);&#125;//将Runnable包装成Message，那么这个Runnable在哪会被调用呢private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125;还记得前面讲到的Looper.loop吗，它会把消息交给与他绑定的Handler去处理来看看这个方法 12345678910111213141516public void dispatchMessage(@NonNull Message msg) &#123; if (msg.callback != null) &#123;//优先优先判断callback是不是空 handleCallback(msg);//不为空直接调用方法处理callback &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125;private static void handleCallback(Message message) &#123; message.callback.run();//这里直接执行了runnable的run方法&#125;结尾文章开头留下的悬念我想这下已经很清晰了，主线程中的main方法调用了Looper.loop,正是有这个无限循环的存在才会不会想一个简单的java程序一样，执行完了main里面的代码程序就结束了，而prepareMainLooper,正是为主线程（UI线程）准备了一个不可以退出的Looper。而这就可以说明Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞它。也就说我们的代码其实就是在这个循环里面去执行的，所以你在你的子线程要使用消息机制接受消息的话，最好将Looper.loop()放到你要直接执行的所有代码后面，不然没有执行qiut方法，后面的代码就不会执行。真逊，原来这么简单，是吧，看来还是要好好学习下去，知识++。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令以及如何在idea上可视化操作git]]></title>
    <url>%2F2019%2F12%2F30%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit%2F</url>
    <content type="text"><![CDATA[git链接在手，天下你有，自己去详细学习吧：史上最浅显易懂的Git教程！ 概念工作区（Working Directory）是我们直接编辑的地方，例如 idea 打开的项目，记事本打开的文本等，肉眼可见，直接操作。 暂存区（Stage 或 Index）数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。 版本库（commit History）存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程仓库了。 常用命令讲解Git 常用命令汇总1、远程仓库相关命令检出仓库：$ git clone [remoteName]查看远程仓库：$ git remote -v添加远程仓库：$ git remote add [name] [url]删除远程仓库：$ git rm [name]修改远程仓库：$ git remote set-url –push [name] [newUrl]拉取远程仓库：$ git pull [remoteName] [localBranchName]推送远程仓库：$ git push [remoteName] [localBranchName]如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下： $ git push origin test:master // 提交本地test分支作为远程的master分支$git push origin test:test // 提交本地test分支作为远程的test分支2、分支(branch)操作相关命令查看本地分支：$ git branch查看远程分支：$ git branch -r创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支切换分支：$ git checkout [name]创建新分支并立即切换到新分支：$ git checkout -b [name]删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并创建远程分支(本地分支push到远程)：$ git push origin [name]删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name]创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)$git symbolic-ref HEAD refs/heads/[name]$rm .git/index$git clean -fdx3、版本(tag)操作相关命令查看版本：$ git tag创建版本：$ git tag [name]删除版本：$ git tag -d [name]查看远程版本：$ git tag -r创建远程版本(本地版本push到远程)：$ git push origin [name]删除远程版本：$ git push origin :refs/tags/[name]合并远程仓库的tag到本地：$ git pull origin –tags上传本地tag到远程仓库：$ git push origin –tags创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’4、忽略一些文件、文件夹不提交.gitignore文件详解 附页： Git 常用命令速查git branch 查看本地所有分支git status 查看当前状态git commit 提交git branch -a 查看所有的分支git branch -r 查看远程所有分支git commit -am “init” 提交并且加注释git remote add origin git@192.168.1.119:ndshowgit push origin master 将文件给推到服务器上git remote show origin 显示远程库origin里的资源git push origin master:developgit push origin master:hb-dev 将本地库与服务器上的库进行关联git checkout –track origin/dev 切换到远程dev分支git branch -D master develop 删除本地库developgit checkout -b dev 建立一个新的本地分支devgit merge origin/dev 将分支dev与当前分支进行合并git checkout dev 切换到本地dev分支git remote show 查看远程库git add .git rm 文件名(包括路径) 从git中删除指定文件git clone git://github.com/schacon/grit.git从服务器上将代码给拉下来git config –list 看所有用户git ls-files 看已经被提交的git rm [file name] 删除一个文件git commit -a 提交当前repos的所有的改变git add [file name] 添加一个文件到git indexgit commit -v 当你用－v参数的时候可以看commit的差异git commit -m “This is the message describing the commit” 添加commit信息git commit -a -a是代表add，把所有的change加到git index里然后再commitgit commit -a -v 一般提交命令git log 看你commit的日志git diff 查看尚未暂存的更新git rm a.a 移除文件(从暂存区和工作区中删除)git rm –cached a.a 移除文件(只从暂存区中删除)git commit -m “remove” 移除文件(从Git中删除)git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)git diff –cached 或 $ git diff –staged 查看尚未提交的更新git stash push 将文件给push到一个临时空间中git stash pop 将文件从临时空间pop下来－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ git remote add origin it@github.com:username/Hello-World.gitgit push origin master 将本地项目给提交到服务器中－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ git pull 本地与服务器端同步－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。git push origin server fix:awesome branch－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ git fetch 相当于是从远程获取最新版本到本地，不会自动mergegit commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：git branch branch_0.1 master 从主分支master创建branch_0.1分支git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0git checkout branch_1.0/master 切换到branch_1.0/master分支du -hsgit branch 删除远程branchgit push origin:branch_remote_namegit branch -r -d branch_remote_name－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ 初始化版本库，并提交到远程服务器端 mkdir新建一个文件夹，一个空格后接你的文件夹的名字cd进入你的名字git init本地初始化touch READMEgit add README添加文件git commit -m ‘first commit’git remote add origin git@github.com:daixu/WebApp.git增加一个远程服务器端细讲我怕又是几小时 ，下面我给你们简单介绍几个常用命令，也就是我门作业会用到的。也是今后我们用到最多的。 github注册链接在手，天下你有，自己去注册吧：github注册链接 好了现在你们什么都有了，你就是一个成熟的程序员的了 接下来我们来偷懒你觉得上面的git命令复杂可以先不看，github里面新建工程啥的太麻烦可以先不看。 打开你神奇的idea，并打开你的项目 假如现在你要上传你的项目到你的github，你只需要 点 点 点 这一步如果你还没登陆的话会要求你登陆，我这已经登陆了所以直接弹出了这个框，点击share就会帮你在本地执行git init git add . git add remote 你的github里面创建仓库并把你的整个工程传上去，一把梭爽不爽 爽 好了正式开始你的程序员生活了，如何拉网络去你仓库的更新呢？只需 点 点 ** **点 其实拉取对现阶段的你们还没啥用，毕竟远程的就是你本地的本地提交的，但是你和别人合作开发的时候就需要拉取了，为啥呢，因为可能他改了之后提交到远程了呀，你需要更新本地到远程的最新版 那如何提交呢？ 只需要 点 点 点 中间那个大框框里写你这次提交描述，点击下面的，commit就会提交到本地的版本库，你要是想提交到版本库之后直接把代码更新到远程github的仓库里，右边那个小三角，然后commit and push，提交到本地时同时上传远程，会出现，如下页面： 点击push就可以了。 那么问题来了，要是你就想直接commit在本地，等今天工作完了，再push到远程呢？只需 点 点 点 好了 ，现在为止你已经会了基本的git操作，是不是超简单。 好了我来学习更多的git操作，对你自己说，”我 。 才 。 不 。 要 。 记 。 命 。 令。“ 假如你现在突发奇想有另外一个想法，想创建一个测试分支，来写那个功能，咋啦呢？ 只需 点 点 点 点击最下面的git 就能唤出这个窗口，这个英文应该大家都能看懂吧，这个英文看不懂就退群吧，思考一下怎么上大学几个月就把高中英语忘完了。 好了然后，你写了很多了，也提交了几次之后，你突然发现前面提交的那个有问题，不想提交了那咋办呢？ 只需点 点 点 那就退到你刚刚新提交的那个版本前面一个呗，例如我觉得test2有问题那我就右键点击test1，然后 这样你刚刚的修改的提交就没了，但是如果你选择的时mix的话，你的修改还是会在的，变成没有提交状态了，我来解释一下这四个选项。 soft重置版本库但是暂存区和工作区不会mixed会充值版本库和暂存区，但是工作区还在hard会重置版本库暂存区工作区（危险操作，但是找都是可以找回来的）keep重置所有的但是会保留文件如果你完全不要本地的所有更改了，可以直接hard到最近一个commit（危险操作，虽然我经常做） 好了现在假如你完成了你突发奇想的功能感觉还不错，想把test分支合并到主分支要咋办呢？ 还是点 点 点 先切换回主分支 然后 点击test分支 这样就合并啦 这也太简单了吧]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git常用命令备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编译运行过程详解]]></title>
    <url>%2F2019%2F12%2F30%2Fjava%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[title: java编译运行过程详解tags: 课件附页categories:java课件附页author: Jondate: 2019-10-23 00:40:00参考原文链接，以下做自己的整理备份 java整个编译以及运行的过程相当繁琐，我就举一个简单的例子说明： Java程序从源文件创建到程序运行要经过两大步骤： 源文件由编译器编译成字节码（ByteCode）；字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言（ “semi-interpreted” language） 123456789101112131415161718192021class Animal &#123; private String name; public Animal(String name) &#123; super(); this.name = name; &#125; public void printName() &#123; System.out.println("Animal = " + this.name); &#125;&#125; public class Main &#123; public static void main(String[] args) &#123; Animal animal = new Animal("super_yc"); animal.printName(); &#125;&#125;第一步（编译）： 创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，如果这个类所依赖的类还没有被编译， 编译器会自动的先编译这个所依赖的类，然后引用。如果java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报 “Cant found sysbol”的异常错误。 编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、 方法引用，成员变量引用等）；方法字节码中放的是各个方法的字节码。 第二步（运行）： java类运行的过程大概分为两个步骤：（1）类的加载 （2）类的执行。需要说明的一点的是：JVM主要在程序第一次运行时主动使用类的 时候，才会立即去加载。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到，不得不加载的时候，才加载进来，而且只加载一次！ 根据上面的程序，详解该程序运行的详细步骤： 在类路径下找到编译好的 java 程序中得到 Test.class 字节码文件后，在命令行上敲 java Test，系统就会启动一个 JVM 进程，JVM进程从classpath路径下找到一个名为Test.class的二进制文件，将Test.class文件中的类信息加载到运行时数据区的方法区中，这一过程叫做类的加载。（只有类信息在方法区中，才能创建对象，使用类中的成员变量）JVM 找到main方法的主函数入口， 持有一个指向当前类(Test)常量池的指针，而常量池中的第一项是发现是一个对Animal对象的符号引用，并且main方法中第一条指令是Animal animal = new Animal(“super_yc”)，就是让JVM创建一个Animal对象，但是方法区中还没有Animal类的类信息，于是JVM就要马上的加载Animal类，将Animal类信息放入到方法区中，于是JVM 以一个直接指向方法区 Animal类的指针替换了常量池中第一项的符号引用。加载完Animal类的信息以后，JVM虚拟机就会在堆内存中为一个Animal类实例分配内存，然后调用其构造函数初始化Animal实例，这个实例持有指向方法区的Animal类的类型信息（其中包含有方发表，java动态绑定的底层实现）的引用。（animal指向了Animal对象的引用会自动的放在栈中，字符串常量”super_yc”会自动的放在方法区的常量池中，对象会自动的放入堆区）当使用 animal.pringName()的时候，JVM根据栈中animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息方法表，获得pringName()函数的字节码地址，然后开始运行函数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[idea条件断点]]></title>
    <url>%2F2019%2F11%2F07%2Fidea%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9%2F</url>
    <content type="text"><![CDATA[idea的条件断点超简单的使用方法，右键点击你的短点，即可出现条件短点设置，其中condition就是超好用的条件短点的判断语句，语句需要返回结果是bool类型的，可以使用： ||&amp;&amp;|&amp;来链接多个语句，并且可以访问断点所在的作用域里所有可用的变量或者方法。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse的常用15个快捷键]]></title>
    <url>%2F2019%2F10%2F28%2Feclipse%E7%9A%84%E5%B8%B8%E7%94%A815%E4%B8%AA%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[15 个 Eclipse 常用开发快捷键使用技巧alt+? 或 alt+/：自动补全代码或者提示代码ctrl+o：快速outline视图ctrl+shift+r：打开资源列表ctrl+shift+f：格式化代码ctrl+e：快速转换编辑器ctrl+page down 或 ctrl+page up： 选项卡之间快速切换shift+enter 及 ctrl+shift+enter： 在当前行上或者下边创建空白。Alt+方向键上下：上下行交换内容或把当前行内容把上或下移动Control+Alt+方向上下键：复制高亮显示的一行或多行ctrl+m：当前编辑页面窗口最大化ctrl+/：自动注释当前行或者选择的多行ctrl+shift+/：自动注释掉选择的代码块ctrl+d：删除当前行ctrl+shift+x 和 ctrl+shift+y ：英文字母大小写的转换ctrl+shift+o：自动引入包和删除无用包]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面向对象-接口和其他的类]]></title>
    <url>%2F2019%2F10%2F12%2Fjava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[前言：听我讲课也就图一乐，要想真学到东西还是得自己看书。 大学学习最重要的莫过于是自学能力，我归纳的东西也许细节上有可能和书上有差异，因为我毕竟不是专业的，要想深究还是得对照书去看，我这只是对你们的一个引导。 万物皆可为对象那么对象与对象之间肯定不是独立的，上节课谢磊学长讲了类的继承，那是一种最广泛的关系。今天我们了解一点更加抽象一点的东西，但是只要大家认真听我想还是会有所明白。 先来吹吹概念小恐龙镇压，让学习不再困难： ！ 接口 接口最通俗的来讲就是一种统一的规范或者叫做协议，接口这个名称有点晦涩难懂，但是其实接口就是一个基于双方或者多方的协议 下面举几个例子： 你们用的插座的插孔可以被叫做接口（协议），因为这个规范存在，在中国无论你是什么充电器，只要是这个充电口，那么我就会给你输出电流，至于你充什么，干什么我都不管。你去面试，他说你必须有本科及以上的文凭且必须过了四级才能有面试资格，这也算事接口（协议），因为如果你没有这些东西，就不能去面试，至于你是怎么努力学习拿到本科文凭和怎么努力拿到四级证书的，一律不管。我今天布置了作业，我要收的是我布置的这些作业，至于你们每个人怎么去做出来我是不管的，那我布置的作业就是接口（协议），你们按照题目实现相应的功能就好，最后验收我也只会根据我布置的作业的应该输出的结果来看你是不是完成作业。（当然，当然我在作业文件中指出你不能用啥，我还是会看的具体细节的）现在，接口你们应该都应该大致明白是什么了吧。 接口有什么作用？或者接口存在的必要性？ 还是上一节的例子，如果国家没有规定这个插座的标准，那每个厂家的有自己的一套，你买公牛的插座就得买支持公牛插座的电器。出去在中国其他地方旅游你就只有背着各式各样的转接头。嗯，锻炼身体也是好事嘛。 所以国家就制定了标准。 编程中接口也差不多，所以重要性也就凸显出来了 编程中的接口？ 场景案例： 现在开始你就是bat当中的员工之一，你的上级太多了，都要吩咐你做事： 大boss想要员工会帮他给买部手机二boss想要员工会销售一套房子三boss想要员工会帮忙搭讪小姐姐四boss想要员工会跟他一起打游戏…………..一共有不知道多少个boss，总之你是底层员工嘛。 那么问题来了，这个员工类究竟得怎么设计呢，真是一个难题，而且老板们想要叫这个员工去做事的时候怎么知道这个员工会呢？ 答案： 其实很简单，把这些行为统统抽象成接口。 例如： 定义下面一些接口： 123public interface BuyCellPhone &#123; public void buycellphone();&#125;123public interface BuyHouse &#123; public void buyHouse();&#125;123public interface TrickGirl &#123; public void trickGirl();&#125;123public interface PlayingGamesTogether &#123; public void playingGameTogether();&#125;………………………………………………………(此处还有无数个接口) 那么这些接口有什么用呢？ 对应的老板只需要认识熟悉的接口就好（意思是只认你是否实现了这个接口），在需要的时候调用方法就好了，而不需要去了解认识每一个人。下面以大老板为例： 首先必须的有一个实现了这个 123456789101112131415161718/** * 实现了买手机这个功能接口的员工 */public class Staff implements BuyCellPhone &#123; private String name; private String sex; public Staff(String name, String sex) &#123; this.name = name; this.sex = sex; &#125; @Override public void buycellphone() &#123; System.out.println("屁颠屁颠帮老板去买手机"); &#125;&#125;此时身为老板的只需要只需要这样一个方法，就可以找个员工帮他买手机了，并且他可以完全不用了解这个员工谁，到底是干啥的，但是至少这人是实现了这个接口，就说明是有这个能力的 123public void lookingForSomeoneToBuyAMobilePhone(BuyCellPhone buyCellPhone) &#123; buyCellPhone.buycellphone();&#125; 抽象类我都叫抽象类了，你说我抽象不抽象，我觉得我比上面那玩意儿抽象，你说呢？ 黄坤坤告诉你到底有多抽象？抽象？我叫抽象类我就抽象啦？那hljj是jj吗？ 听听抽象类的自白（抽象类独白）：​ 天生就是用来被别人来继承的，简而言之，只有当爸爸的命，从不当儿子。可能有些事，必须得儿子去做，别直接叫我去做事。”只当爸爸“说明被继承是绝对需要，大部分抽象类都是没有完整实现类功能的类，等待子类继承去实现，所以它是不可以被实例化成对像的。“有些事必须得儿子去做”说明它可能存在方法是抽象的，必须得子类去具体实现。“别直接叫我做事”说明它是不可以直接示例化的。好了，说完上面牵强的解释，现在我们来看看例子： 好了，开始开飞机了接口基本概念 接口，英文称作interface，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。在Java中，定一个接口的形式如下： 123public interface InterfaceName &#123;&#125;需要注意的是: 接口中的变量会被隐式地指定为public static final变量用其他关键词修饰会报错，例如：public static final，private方法会被隐式地指定为public abstract方法且只能是public abstract方法用其他关键词会报错，例如：private、protected、static、 final接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。回调可能初识这个名词觉得高大上和陌生，下面我仔细的讲解一下回调到底是什么呢？ 我在知乎上看到一个高赞回答： 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。 这个回答在我学习接口时就看到了，但是当时还是一知半解，下面我们用代码来解释一下。 首先我们定义一个接口Notify，通知接口 123public interface Notify &#123; public void call();&#125;我们定义一个Shop类 123456789101112131415161718public class Shop &#123; private Notify notify; public void registrationNoticeMethod(Notify notify) &#123; this.notify = notify; &#125; public void tellCustomerOutOfStock() &#123; System.out.println("对不起，我们这没有货了"); &#125; public void arrivalNotice() &#123; if (notify != null) &#123; notify.call(); &#125; &#125;&#125;定义一个顾客类Customer，并且让顾客类实现Notify这个接口 123456789101112public class Customer implements Notify &#123; long phoneNum = 1234567; @Override public void call() &#123; System.out.println("打电话给" + phoneNum + "通知到货了"); &#125; public void goShopping() &#123; System.out.println("出门购物"); &#125;&#125;主程序： 12345678910111213141516171819202122232425262728 /** * 主函数 */public class Main &#123; public static void main(String[] args) &#123; //实例化对象 Customer customer = new Customer(); Shop shop = new Shop(); //顾客出门购物 customer.goShopping(); pause(); shop.tellCustomerOutOfStock(); pause(); shop.registrationNoticeMethod(customer); //第二天到货了 System.out.println("第二天"); shop.arrivalNotice(); &#125; /** * 这个函数不用在意，只是为了演示效果，增加暂停 */ private static void pause() &#123; new Scanner(System.in).nextLine(); &#125;&#125;输出： 代码中的@Override注解说明点击进入 特殊的接口函数式接口 简单来说，就是只有一个方法的接口。 接口继承接口以及java8之后的接口多继承问题详细解释链接可能失效，我这里简述一下。 java中不是没有多继承吗？java8之前 是的，的确java中没有多继承，但是在java中接口是个例外，接口可以多继承，因为接口没有方法体，所以不论实现哪个父接口的中的方法都是没有关系的。 java8之后 java8之后出现了接口的默认实现，就像以下的模式： 12345public interface A &#123; default void hhh() &#123; System.out.println("我是B"); &#125;&#125;12345public interface B &#123; default void hhh() &#123; System.out.println("我是C"); &#125;&#125;如果有个接口继承前两个接口，就必须把冲突的方法重写 1234567public interface C extends A, B &#123; @Override default void hhh() &#123; &#125;&#125;如果有个类同时实现这两个接口也需要实现冲突默认方法 123456public class Test implements B, A &#123; @Override public void hhh() &#123; &#125;&#125;抽象类定义在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。怎么使用抽象类声明12345678910111213/** * 普通的类 */public class Test&#123; &#125;/** * 抽象类 */public abstract class Test &#123;&#125;声明一个java抽象类只需要在正常的类的class之前加上abstract 抽象方法声明123abstract class A &#123; public abstract void a();&#125;使用时需要注意的：抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。最重要的主程序来了，仔细看注释介绍抽象方法必须由子类来进行重写。抽象类人类只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。抽象类中可以包含具体的方法，当然也可以不包含抽象方法。子类中的抽象方法不能与父类的抽象方法同名。abstract不能与final并列修饰同一个类。这个显而易见，既然是抽象的，就必须需要时需要被子类实现的，所以不可能时finalabstract 不能与private、static、final或并列修饰同一个方法。private:抽象方法，必须是需要被继承的实现的，所以不可以用私有修饰符修饰static：同样，抽象方法是需要被实现的，但是静态方法是不可以被重写final：同上抽象类和接口的区别语法层面上的区别抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法（在java8的之后接口）；抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；一个类只能继承一个抽象类，而一个类却可以实现多个接口。设计层面上的区别抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是“的关系，而 接口 实现则是 “有没有“的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？ ？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。实际的例子下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念： 123456789/** * 门的抽象类 */public abstract class DoorAbstract &#123; public abstract void open(); public abstract void close();&#125; 或者： 123456789/** * 门的接口 */public interface DoorInterface &#123; public void open(); public void close();&#125;但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路： 将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。很明显这个属性放到以上任何一个的当中都是不合适的，但是报警又是一个比较广泛的属性，java不支持多继承，所以最好将这个方法抽象到一个接口里面，这就是所谓的对行为抽象： 123456/** * 报警的接口，所有实现了这个接口的类都是有报警这个功能 */public interface Alarm &#123; public void alarm();&#125;然后在对这个可以报警的门进行封装： 1234567891011121314151617181920/** * 可以报警的门 */public class AlarmDoor extends DoorAbstract implements Alarm &#123; @Override public void alarm() &#123; &#125; @Override public void open() &#123; &#125; @Override public void close() &#123; &#125;&#125;这里其中有个注解@Override我简单说明一下（至于注解是啥，不详细的讲解了下节课会讲到）： @Override是伪代码,表示重写可以不写，不过写上有如下好处: 可以当注释用,方便阅读，可以很明显的看到哪些方法是重写的方法；编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了，这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)。对于这里而言第二个作用是没有作用的，因为如果继承了抽象类，如果抽象类中含有抽象方法，必须实现这个方法不然编译器也会报错，接口也是同样的，前面说到接口中的方法默认是public abstract。 内部类 顾名思义：可以将一个类的定义放在另一个类的定义内部，这就是内部类。 怎么用？12345678910/** * 类中定义类 */public class A &#123; class B &#123; &#125;&#125;好了，你现在已经会了内部类了，你看多简单呐 好了开玩笑的啦。 内部类小飞机为什么要使用内部类？​ 在《Think in java》也就是《java编程思想》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 ​ 在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。 完了上面这么简单的描述还听不懂 ，听不懂没关系，这样说我也不懂，来慢慢分析。 123public interface Father &#123;&#125;123public interface Mother &#123;&#125;接下来骚操作来了： 你可以这样子 123public class Son implements Father, Mother &#123;&#125;也可以这样子 123456public class Daughter implements Father&#123; class Mother implements Mother&#123; &#125;&#125;但是，不是一个类可以实现多个接口嘛，第二种实现还有什么意义呢。 那么问题来了，如果爸爸妈妈他们不是接口而是一个抽象类或者类呢？现在应该理解更为深刻了。 内部类基础.this和.new语法 当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。 内部类如何访问外围类的东西呢？ 当然直接用变量名就可以访问啦 原因？（凡事要解释得通才行嘛） 其实在内部类对象中保存了一个对外部类对象的引用，当在内部类的成员方法中访问某一变量时，如果在该方法和内部类中都没有定义过这个变量，（如果有这个变量的话，或者外部类的某个成员变量与内部类的成员变量相同eg:在内部类中定义 private String name; 那么访问的则是内部类的这个变量）调用就会被传递给内部类中的那个对外部类对象的引用，通过这个引用去调用这个变量。在内部类调用外部类的方法也是同样的一个道理（还是这个内部类对象保存了一个对外部类的引用）。 内部类如何获取外围类的对象呢？（.this） 这样子： 123456789101112/** * 内部类示例 */public class A &#123; String s = ""; class B &#123; public void lala() &#123; A a = A.this; //关键的地方 &#125; &#125;&#125; 如何创建内部类的对象呢？ 在外围类内 1234567891011121314/** * 内部类示例 */public class A &#123; String s = ""; public void lala() &#123; B b = new B(); //关键的地方 &#125; class B &#123; &#125;&#125;在外围类外（也就是在其他地方）：（.new） 12A a = new A();A.B b = a.new B(); 到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为A的外围类和一个名为B的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。 关于java编译运行有兴趣了解自己了解（之前不是很多同学用命令行javac 和 java命令嘛） 内部类的分类成员内部类成员内部类中不能存在任何static的变量和方法；成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。例子： 12345678910/** * 类中定义类 */public class A &#123; class B &#123; &#125;&#125;对就是这种最简单的内部类 局部内部类嵌套在方法或者作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题嵌套在方法中很简单，直接在方法里面写类嘛，到那时嵌套在作用域里面怎么回事，这说明直接随便在一个类中随便找个位置，写个大括号，大括号中中也是可以写局部内部类的例如：（这个简单例子可能有点绕）通常是想创建一个类来辅助我们的解决方案，但那时又不希望这个类是公共可用的，所以就产生了局部内部类局部内部类和成员内部类一样被编译，只是它的作用域发生了改变它只能在该方法和属性中被使用，出了该方法和属性就会失效首先为了方便，我门先定义一个接口：下面开始正式的例子：可以返回局部内部类实例化对象的函数（下面有个类B，里面有个方法返回A的引用，并且函数体里面有个实现了接口A的局部内部类C）你可以直接这样子定义然后在方法中使用（作用域在方法内）匿名内部类咋写？首先定义一个接口，一个抽象类，和一个简单的类 123456/** * 我是一个冷漠无情的简单接口A */public interface A &#123; public void a();&#125;123456/** * 我是一个冷漠无情的简单抽象类B */public abstract class B &#123; public abstract void b();&#125;12345678/** * 我是一个冷漠无情的超简单普通类 */public class C &#123; public void c() &#123; &#125;&#125;好了，有了上面的基础，我们就来演示一下匿名内部类： 12345678910111213141516171819202122public class D &#123; public static void main(String[] args) &#123; new A() &#123;//继承接口A的匿名内部类 @Override public void a() &#123; &#125; &#125;; new B() &#123;//继承抽象类B的内部类 @Override public void b() &#123; &#125; &#125;; new C() &#123;//继承普通类C的匿名内部类 &#125;; &#125;&#125;内部类的注意事项匿名内部类是没有访问修饰符的。new 匿名内部类，这个类首先是要存在的。如果我们将接口注释掉，就会出现编译出错。例子同上第二个，如果不用B这个现有的接口的话例如这样子写，是会报错的：java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final你是啥意思呀，完全不懂你说的啥啊，这又是啥狗屁啊，小丁学长你在开啥飞机。emmmmmmm，好的，那我们来举例子 首先我们定义一个接口，做准备。然后我门再写一个普通类B，后面修改B来挨个测试首先我们测试在方法里面的内部类，这个也是我们最常用的。我们在内部类实现的方法里面直接输出b看并且不把变量b设置为final 是不是讲错了，咋不需要变量b咋不需要final就能通过，翻车了。百度谷歌一番，我找到这样一句话。emmm，那究竟是不是这样子呢？再来康康？我们这次在上面那个内部类直接修改变量b的值。看可不可以呢。编译之后，果然报错了，错误如下：安心了，我们继续开飞机：下面这两个用法，我估计你今后写10万行代码都遇不上一次这样写的，但是为了验证以上话是正确的，我们得试试。第二项测试，在匿名内部类中类的静态代码块使用外部作用域里面的变量（因为是java有自动final修饰我们下面几次测试都使用直接更改外部作用域变量来测试【即：直接更改变量b的值】）好的我来编译一下好的继续报错，而且还是这个错，nice说明，那句话更加正确了，java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final那么接下来我们来测试最后一项测试，我们在匿名内部类中访问外围类中的属性，看能不能修改编译一下，没错？运行一下，没有报错？woc，emmmmmm，找找原因，于是我们在再在B类中添加一个普通内部类，如下：前面我们说了，找找原因，为啥没有报错，前面我们说内部类基础得时候，我们说是内部类是持有外围类得引用的，所以会智能的可以直接使用外围类的成员属性。我们编译B类，然后出现了如下文件：咦，难道匿名内部类也会储存外围类的引用🐎，是不是我们具体来康康。我们先来看看B类编译之后反编译的代码没有太大的区别，唯一的区别就是变量b，原本的0的值变成了布尔类型，这是为啥呢？还问为啥？是要我开火箭嘛，这篇课件不是因为“为啥”会有13000+的字嘛？？你仔细想想，写个程序要那么多为什么吗？？您好要的。最简单的来说这是编译器的一个优化，你这个值没有使用，为啥要给你要存一个整形，整形相对于布尔类型还是蛮大的，自己康康，整整四倍呢。。。。。。类型存储需求bit 数取值范围备注int4字节4*8-2147483648~2147483647即 (-2)的31次方 ~ (2的31次方) - 1short2字节2*8-32768~32767即 (-2)的15次方 ~ (2的15次方) - 1long8字节8*8即 (-2)的63次方 ~ (2的63次方) - 1byte1字节1*8-128~127即 (-2)的7次方 ~ (2的7次方) - 1float4字节4*8float 类型的数值有一个后缀 F（例如：3.14F）double8字节8*8没有后缀 F 的浮点数值（例如：3.14）默认为 doubleboolean1字节1*8true、falsechar2字节2*8Java中，只要是字符，不管是数字还是英文还是汉字，都占两个字节。再来看看B$C.class，验证是否持有外围类的引用嗯，作为内部类，持有外围类的应用，正解。这里只能看到外围类的引用传进来了，那系统是怎么使用的呢？ 保存和使用是jvm级别的事，这里就详细讲了，我还没怎么看呢。好的关键部分了，我们再来看看B$1.class反编译的结果 看到没有，匿名内部类也是会保存外围类的引用的好了这下说明我上面那句话是对的，nice，那么问题又来了。为什么一定要是final？？？你们吐血没？？反正我吐了好的，我们来讲那么又来了一个名词，“闭包”闭包是什么呢？来听听大牛的说的他认为最通俗易懂的答案：一个依赖于外部环境自由变量的函数这个函数能够访问外部环境里的自由变量哦豁， 还是不明白，好的，那么你继续听我慢慢分析首先我们定义一个接口，做准备准备工作。不准备了，不准备了，自己百度看教程吧，再准备这课件起码到20000字了。这里附两个java中的final讲解 闭包讲解其实分为java8之前之后匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。咦，上面不是反编译之后有构造方法吗？不对不对，我这说的是使用内部类的时候，不能有构造方法，你都直接，反编译时出现的构造方法是系统在你生成匿名内部类对象时默认调用的构造方法，因为再怎么它也是个类嘛，还是有类的尊严的。【内部类自白】：怎么人家成为你对象也是条件的嘛，没有构造方法怎么行静态内部类非静态内部类在编译完成之后会隐含地保存着一个引用它的创建是不需要依赖于外围类的它不能使用任何外围类的非static成员变量和方法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>课件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh用法及命令]]></title>
    <url>%2F2019%2F10%2F07%2Fssh%E7%94%A8%E6%B3%95%E5%8F%8A%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[原文链接 什么是SSH？简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。这里只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。 中间人攻击SSH之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。 ssh的安装SSH分客户端openssh-client和openssh-server 如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudoapt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server。 Ubuntu缺省已经安装了ssh client。 #配置ssh#1234567891011121314151617181920212223echo -e "\033[31;1m ******************************* \033[0m"echo -e "\033[31;1m ************安装和配置ssh************ \033[0m"sudo apt-get install -y openssh-server 1&gt; /dev/nullsudo sed -i 's/UsePAM no/UsePAM yes/g' /etc/ssh/sshd_configsudo sed -i '8a /etc/init.d/ssh start' /etc/profilesudo /etc/init.d/ssh startps -e | grep sshecho -e "\033[31;1m ssh授权 \033[0m"cd ~/.ssh/ssh-keygen -t rsacat ./id_rsa.pub &gt;&gt; ./authorized_keys $ ps -e|grep ssh 2151 ? 00:00:00 ssh-agent 5313 ? 00:00:00 sshdssh-agent表示ssh-client启动，sshd表示ssh-server启动了。如果缺少sshd，说明ssh服务没有启动或者没有安装。SSH基本用法SSH远程登录口令登录假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。 1$ ssh user@host 如：ssh pika@192.168.0.111如果本地用户名与远程用户名一致，登录时可以省略用户名。 1$ ssh hostSSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。 1$ ssh -p 2222 user@host上面这条命令表示，ssh直接连接远程主机的2222端口。如果你是第一次登录对方主机，系统会出现下面的提示： 12345$ ssh user@hostThe authenticity of host 'host (12.18.429.21)' can't be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)?这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。假定经过风险衡量以后，用户决定接受这个远程主机的公钥。 Are you sure you want to continue connecting (yes/no)? yes系统会出现一句提示，表示host主机已经得到认可。 Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.然后，会要求输入密码。 Password: (enter password)如果密码正确，就可以登录了。当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。 如果本地用户名与远程用户名一致，登录时可以省略用户名。 1$ ssh hostSSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。 1$ ssh -p 2222 user@host上面这条命令表示，ssh直接连接远程主机的2222端口。如果你是第一次登录对方主机，系统会出现下面的提示： 123The authenticity of host 'host (12.18.429.21)' can't be established. RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d. Are you sure you want to continue connecting (yes/no)?这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。假定经过风险衡量以后，用户决定接受这个远程主机的公钥。​ Are you sure you want to continue connecting (yes/no)? yes系统会出现一句提示，表示host主机已经得到认可。​ Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.然后，会要求输入密码。​ Password: (enter password)如果密码正确，就可以登录了。当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。 公钥登录使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个： 1$ ssh-keygen运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。这时再输入下面的命令，将公钥传送到远程主机host上面： 1$ ssh-copy-id user@host好了，从此你再登录，就不需要输入密码了。如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。 123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys然后，重启远程主机的ssh服务。 12# ubuntu系统service ssh restart12# debian系统/etc/init.d/ssh restartauthorized_keys文件远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程： 1$ ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub这条命令由多个语句组成，依次分解开来看： “$ ssh user@host”，表示登录远程主机；单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：“$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；‘cat &gt;&gt; .ssh/authorized_keys’ &lt; /.ssh/id_rsa.pub的作用是，将本地的公钥文件/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。写入authorized_keys文件后，公钥登录的设置就完成了。然后，重启远程主机的ssh服务。 1234# ubuntu系统service ssh restart# debian系统/etc/init.d/ssh restartauthorized_keys文件远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程： 1$ ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub这条命令由多个语句组成，依次分解开来看：（1）”$ ssh user@host”，表示登录远程主机；（2）单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：（3）”$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；（4）’cat &gt;&gt; .ssh/authorized_keys’ &lt; /.ssh/id_rsa.pub的作用是，将本地的公钥文件/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。写入authorized_keys文件后，公钥登录的设置就完成了。 [SSH原理与运用（一）：远程登录] 使用ssh在远程后台不中断地跑程序Linux关闭ssh（关闭终端等）后运行的程序或者服务自动停止，如python3 a.py &amp;。 解决：使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行。 1nohup python3 a.py &amp;[linux进程管理与SELinux] ssh连接中断如果使用的是iTerm2，要让ssh不断线： profiles -&gt; sessions -&gt; When idel, send ASCII code 其它命令行客户端，通过配置 ServerAliveInterval 来实现，在 ~/.ssh/config 中加入： ServerAliveInterval=30。表示ssh客户端每隔30秒给远程主机发送一个no-op包，no-op是无任何操作的意思，这样远程主机就不会关闭这个SSH会话。 vim ~/.ssh/config，然后新增 Host * ServerAliveInterval 6060秒就好了，而且基本去连的机器都保持，所以配置了*，如果有需要针对某个机器，可以自行配置为需要的serverHostName。 [ssh保持连接不断开] SSH远程操作SSH数据传输SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。 $ ssh user@host ‘mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。下面看几个例子。【例1】将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。 $ cd &amp;&amp; tar czv src | ssh user@host ‘tar xz’【例2】将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。 $ ssh user@host ‘tar cz src’ | tar xzv【例3】查看远程主机是否运行进程httpd。 $ ssh user@host ‘ps ax | grep [h]ttpd’ lz建议使用scp进行远程copy： scp 跨机远程拷贝scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限。 scp命令参数-1 强制scp命令使用协议ssh1-2 强制scp命令使用协议ssh2-4 强制scp命令只使用IPv4寻址-6 强制scp命令只使用IPv6寻址-B 使用批处理模式（传输过程中不询问传输口令或短语）-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）-p 留原文件的修改时间，访问时间和访问权限。-q 不显示传输进度条。-r 递归复制整个目录。-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。-l limit 限定用户所能使用的带宽，以Kbit/s为单位。-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，-P port 注意是大写的P, port是指定数据传输用到的端口号-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。scp一般有六种使用方法本地复制远程文件：（把远程的文件复制到本地）scp root@www.test.com:/val/test/test.tar.gz /val/test/test.tar.gz远程复制本地文件：（把本地的文件复制到远程主机上）scp /val/test.tar.gz root@www.test.com:/val/test.tar.gz本地复制远程目录：（把远程的目录复制到本地）scp -r root@www.test.com:/val/test/ /val/test/远程复制本地目录：（把本地的目录复制到远程主机上）scp -r ./ubuntu_env/ root@192.168.0.111:/home/pipipika:/media/pika/files/machine_learning/datasets$scp -r SocialNetworks/piting@192.168.0.172:/media/data/pipi/datasets本地复制远程文件到指定目录：（把远程的文件复制到本地）scp root@www.test.com:/val/test/test.tar.gz /val/test/远程复制本地文件到指定目录：（把本地的文件复制到远程主机上）scp /val/test.tar.gz root@www.test.com:/val/ps: scp复制文件时只指定服务器地址不加路径默认复制到哪里??? [12个scp传输文件的命令栗子] [scp 跨机远程拷贝] SSH端口操作绑定本地端口既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写： $ ssh -D 8080 user@hostSSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。 本地端口转发有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）。假定host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。我们在host1执行下面的命令： $ ssh -L 2121:host2:21 host3命令中的L参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。 $ ftp localhost:2121“本地端口转发”使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH隧道”。下面是一个比较有趣的例子。 1$ ssh -L 5900:localhost:5900 host3它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。另一个例子是通过host3的端口转发，ssh登录host2。 1$ ssh -L 9001:host2:22 host3这时，只要ssh登录本机的9001端口，就相当于登录host2了。 1$ ssh -p 9001 localhost上面的-p参数表示指定登录端口。 出错处理：ssh: Could not resolve hostname 192.168..:***: Name or service not known 解决：指定端口不能直接使用ip:端口号，使用-p参数来解决就可以了。 远程端口转发既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，”本地端口转发”就不能用了，怎么办？解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。我们在host3执行下面的命令： 1$ ssh -R 2121:host2:21 host1R参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。绑定之后，我们在host1就可以连接host2了： 1$ ftp localhost:2121这里必须指出，”远程端口转发”的前提条件是，host1和host3两台主机都有sshD和ssh客户端。 SSH的其他参数SSH还有一些别的参数，也值得介绍。N参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。 1$ ssh -NT -D 8080 hostf参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。 1$ ssh -f -D 8080 host要关闭这个后台连接，就只有用kill命令去杀掉进程。]]></content>
  </entry>
  <entry>
    <title><![CDATA[git push 解决 弹出用户名和密码输入框]]></title>
    <url>%2F2019%2F10%2F04%2Fgit-push-%E8%A7%A3%E5%86%B3-%E5%BC%B9%E5%87%BA%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%2F</url>
    <content type="text"><![CDATA[首先查看你的远程仓库版本12345git remote -v result：origin https://github.com/username/username.github.io.git (fetch)origin https://github.com/username/username.github.io.git (push)若你没有添加别人的仓库，通常只有这两个 重新设置对应远程仓库成ssh的方式:123git remote rm origingit remote add origin git@github.com:username&#x2F;repository.gitgit push -u origin master]]></content>
      <categories>
        <category>Git学习备忘</category>
      </categories>
      <tags>
        <tag>知识就是力量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.gitignore忽略文件总结]]></title>
    <url>%2F2019%2F10%2F04%2Fgitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[语法归纳1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 表示此为注释,将被Git忽略*.a 表示忽略所有 .a 结尾的文件!lib.a 表示但lib.a除外/TODO 表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ 表示忽略 build/目录下的所有文件，过滤整个build文件夹；doc/*.txt 表示会忽略doc/notes.txt但不包括 doc/server/arch.txt bin/: 表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件/bin: 表示忽略根目录下的bin文件/*.c: 表示忽略cat.c，不忽略 build/cat.cdebug/*.obj: 表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj**/foo: 表示忽略/foo,a/foo,a/b/foo等a/**/b: 表示忽略a/b, a/x/b,a/x/y/b等!/bin/run.sh 表示不忽略bin目录下的run.sh文件*.log: 表示忽略所有 .log 文件config.php: 表示忽略当前路径的 config.php 文件 /mtk/ 表示过滤整个文件夹*.zip 表示过滤所有.zip文件/mtk/do.c 表示过滤某个具体文件 被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。 需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：!*.zip!/mtk/one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：/mtk/*!/mtk/one.txt 假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！ ----------------------------------------------------------------------------------还有一些规则如下：fd1/*说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； /fd1/*说明：忽略根目录下的 /fd1/ 目录的全部内容； /*!.gitignore!/fw/ /fw/*!/fw/bin/!/fw/sf/说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。从版本库去除并忽略提交先执行以下任意删除命令123git rm file # 从版本库删除，并删除本地文件git rm --cached file # 从版本库删除文件并保留本地文件git rm -r --cached loggers # -r 是允许递归删除，当要删除的是文件夹的时候有用在.gitignore文件中添加提醒.gitignore忽略规则的匹配语法每一行的忽略规则的语法如下： 空格不匹配任意文件，可作为分隔符，可用反斜杠转义以“＃”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。可以使用标准的glob模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。以斜杠”/“开头表示目录；”/“结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；”/“开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。以星号”**”通配多个字符，即匹配多个任意字符；使用两个星号”*“ 表示匹配任意中间目录，比如`a//z`可以匹配 a/z, a/b/z 或 a/b/c/z等。以问号”?“通配单个字符，即匹配一个任意字符；以方括号”[]“包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。以叹号”!“表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用”!”规则是不起作用的。也就是说”!”开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用”!”也不会再次被包含。可以使用反斜杠进行转义。需要谨记：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； .gitignore忽略规则的优先级在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）： 从命令行中读取可用的忽略规则当前目录定义的规则父级目录定义的规则，依次递推$GIT_DIR/info/exclude 文件中定义的规则core.excludesfile中定义的全局规则]]></content>
      <categories>
        <category>Git学习备忘</category>
      </categories>
      <tags>
        <tag>知识就是力量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行后台运行程序命令]]></title>
    <url>%2F2019%2F10%2F03%2Flinux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[后台执行命令：&amp;和nohup归纳：ps -ef或者grep查看进程kill XX杀死进程，XX替换为进程PID命令后加&amp;后台运行，但生命周期受窗口限制nohup 命令 &amp;完全后台运行原文链接，本文归纳梳理，便于自己记忆。 后台运行命令&amp;断开链接或者关闭窗口仍然会终止程序 在命令后面加上&amp; 实现后台运行。例如： 1sh test.sh &amp; 适合在后台运行的命令有find、费时的排序及一些shell脚本。需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。后台运行一样会将结果输出到屏幕上，干扰你的工作。如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中命令 &gt; out.file 2&gt;&amp;1 &amp; 1 这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。 当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它(ps -ef | grep 进程号 或者 kill -9 进程号） nohup 可退出命令窗口使用 使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用一但把当前控制台关掉(退出帐户时)，作业就会停止运行。nohup命令可以在你退出帐户之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。该命令的一般形式为： 1nohup 命令 &amp;1如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件： 1nohup command &gt; myout.file 2&gt;&amp;1 &amp;1注意使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。 ctrl + z可以将一个正在前台执行的命令放到后台，并且处于暂停状态。ctrl+c终止前台命令。jobs查看当前有多少在后台运行的命令。jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。2&gt;&amp;1解析1command &gt;out.file 2&gt;&amp;1 &amp;1command&gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。2&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行。试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>知识就是力量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows脚本转移Linux上git命令出现错误]]></title>
    <url>%2F2019%2F10%2F03%2Fwindows%E8%84%9A%E6%9C%AC%E8%BD%AC%E7%A7%BBLinux%E4%B8%8Agit%E5%91%BD%E4%BB%A4%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[场景在我将整个hexo博客源码从windows10转移到linux（centos7）中时，脚本中的git命令没有例外的出现了这个错误 1234567git: 'pull' is not a git command. See 'git --help'. Did you mean one of these? pullgit: 'push' is not a git command. See 'git --help'. Did you mean one of these? push这是什么人间疾苦，于是我Google，找到最接近的答案就是这个 https://stackoverflow.com/questions/1465398/git-pull-broken 这是十年前的一个issue，很明显不是这个问题。git早已经修正了这个issue。 那么问题来了，这到底是什么原因导致git认为你认为完全正确的命令是有问题的呢： 首先我保证绝对不是git版本的问题，我反复在服务器上更替了不同版本的git，无论是直接安装编译好的版本还是自己编译都多次尝试过，但是无一例外出错了。还是相同的错误。其次脚本绝对是可运行的，在windows上可以正确无误的执行。服务器镜像问题？没钱换服务器，况且服务器上运行了不少东西，不好更换，但我觉得的应该不是，其他脚本命令是可以运行的。那到底是哪的问题呢？ 解决最后我几乎快完全丧失解决它的希望时，我进行了最后一次尝试。 用在linux vim重写脚本，发现在写的途中有些命令写出现和原来的颜色是不一样的 最后脚本运行成功。 所以千万别用windows10的记事本写代码，应该是编码的问题，还是建议用专业的编辑器写脚本]]></content>
      <categories>
        <category>错误记录</category>
      </categories>
      <tags>
        <tag>巨坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+admin+windows服务器的综合博客平台]]></title>
    <url>%2F2019%2F10%2F03%2Fhexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[windows下的hexo+github博客搭建博客搭建不多说这里放上大神的知乎，点击自己按照流程来做就好了，下面我做一个归纳整理，也留作备份。 安装Node.js windows下载链接下载之后一路next就好，环境变量默认会把帮你配好最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。也有没有自动配的情况，可以手动配一下。 添加国内镜像源 如果没有K X S W(这是啥大家都明白吧)的话，可以使用阿里的国内镜像进行加速。 1npm config set registry https://registry.npm.taobao.org 安装Git Git的下载链接安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。安装完成后在命令提示符中输入git --version验证是否安装成功。同样如果没有找到版本号需要手动配置 注册Github账号 注册地址注册完成之后进入主页点击新建项目项目名称是你的github用户名加.github.io例如: XXXXX.github.io同时也可以勾选一下Redme.md![new p](C:\data\Treeeeeeee.github.io\blog\source_posts\hexo-admin-windows-服务器的综合博客平台\new p.png)然后按照下面的流程你就可以获得一个最简单的博客进去之后随便选一个 安装Hexo在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在D:\study\program\blog目录下。 在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。 定位到该目录下，输入npm i hexo-cli -g安装Hexo。会有几个报错，无视它就行。 安装完后输入hexo -v验证是否安装成功。 然后就要初始化我们的网站，输入hexo init初始化文件夹，接着输入npm install安装必备的组件。 这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以看到我们的博客啦，效果如下： 按ctrl+c关闭本地服务器。 连接Github与本地首先右键打开git bash，然后输入下面命令： 12git config --global user.name "godweiyang"git config --global user.email "792321264@qq.com"用户名和邮箱根据你注册github的信息自行修改。 然后生成密钥SSH key： 1ssh-keygen -t rsa -C "792321264@qq.com"打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。 git bash中输入 1cat ~/.ssh/id_rsa.pub将输出的内容复制到框中，点击确定保存。 输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了。 打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。 修改最后一行的配置： 1234deploy: type: git repo: branch: masterrepository或者repo修改为你自己的github项目地址 我这里默认的是使用ssh，如果想使用https点击更换就好了 我推荐使用ssh，毕竟你已经在你的github中添加了你本机的ssh，免得再输密码如果不懂ssh可以先使用https，后面我们做服务器的自动git用ssh会更好，如果不需要，而且是在windows下使用的话那就https的吧，没啥关系，windows有记住密码的功能 写文章、发布文章首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。 然后输入hexo new post &quot;article title&quot;，新建一篇文章。 article title 替换成你要写的文章的名字，需要注意一下： 最好使用英文，使用中文的话博客的url会非常长如果想插入图片的话，打开你的博客目录里面的_config.yml找到post_asset_folder:属性，并复制未true，这样生成一篇新文章时，会在目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等。这样在文章中插入图片使用相对路径就可以即在本地书写的时候看到图片，又在生成的博客中看到，例如：在文章中直接这样插入，就可以完美插入图片。详细可以借鉴我另外一篇博客这里推荐一个超好用加方便的markdown编辑软件Typora，而且恰好支持这种图片资源文件，设置一下可以把任意来源图片直接弄到对应文件夹这样设置以后你不管是从网络上来的图片还是任意地方拖动的进来的图片都会自动给你放到这个文件夹 然后打开D:\study\program\blog\source\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。 编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。 绑定域名现在默认的域名还是xxx.github.io，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。 以我的百度云为例，如下图所示，添加两条解析记录： 然后打开你的github博客项目，点击settings，拉到下面Custom domain处，填上你自己的域名，保存： 这时候你的项目根目录应该会出现一个名为CNAME的文件了。如果没有的话，打开你本地博客/source目录，我的是D:\study\program\blog\source，新建CNAME文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行hexo g、hexo d上传到github。 备份博客源文件有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。 我的备份方法随便找个文件夹，右键打开git bash，依次执行以下命令然后删除你拉下来的所有东西文件夹，如果你开了隐藏文件夹也可见的话别把.git文件夹删除了，如果没开就放心删除所有文件吧（看见.git别动就对了）然后把你你的整个博客文件夹移动到这里，并删除你博客文件下里面所有叫.gitignore的文件，通常来说，博客源码根目录有一个，主题文件夹里面都有.gitignore文件是用来说明那些东西不被git push的，具体请自行百度然后继续依次执行以下命令等待完成就可以在任何地方直接拉下来使用了，在其他地方使用有以下几个要注意的：环境必须安装这个没得说如果你是使用shh来部署的项目需要把这台设备的生成的ssh添加到你的github账号里指的是你前面属性repo :是用的https的还是ssh的其他备份方法(该内容是粘贴复制)首先在github博客仓库下新建一个分支hexo，然后git clone到本地，把.git文件夹拿出来，放在博客根目录下。然后git branch -b hexo切换到hexo分支，然后git add .，然后git commit -m &quot;xxx&quot;，最后git push origin hexo提交就行了。博客源代码下载个性化设置（matery主题）常见问题及解答（FAQ）个性化设置|更换主题|效果图 我的博客地址有什么问题可以在文章下评论留言 inside主题直接下载源码放到你的博客源码目录的themes目录里面，并修改_config.yml文件中theme:属性，然后执行：浏览器访问：localhost:4000 就能直接看到效果了具体配置我就不详细说明了可以去看主题制作者的博客：链接]]></content>
      <categories>
        <category>兴趣</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
        <tag>浪费了大好青春</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完美的hexo中插入图片的解决方案]]></title>
    <url>%2F2019%2F10%2F01%2Fhexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[完美的hexo中插入图片的解决方案以下内容来自ETRD的《hexo中完美插入本地图片》，摘录整理关键部分，留作备份。 Markdown编辑器Typora不需要关注太多markdown语法就能写出比较好看的markdown，支持实时转换Hexo配置文件的设置 确保你的Hexo的配置文件_config.yml里面有个这个选项配置，并将其置为true 1post_asset_folder: true 这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用 1hexo new生成一篇新文章时，会在 1\source\_posts目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等 实际上我通常喜欢自己右键手动去建立一个md文件来写博客，而不使用hexo new命令，此时要达到同样的效果，我同样也需要手动去建立一个同名的文件夹去存放资源，我试过这样做是可行的，并且这样做虽然有点麻烦，但我似乎发现了它的一个优点，那就是当我的文章中没有图片时，我并不需要这个空的资源文件夹。 有了上面的配置，Hexo在public文件下生成html文件时，会在相应的目录中把那文章对应的资源文件夹中的图片等附件复制过去，例如，这是我生成的一个例子： 安装hexo-asset-image插件你需要安装一个图片路径转换的插件，这个插件名字是hexo-asset-image，我目前安装的是最新的0.03版本，使用如下命令安装插件 1npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save插件安装完以后，实际上是存放在下面的目录文件夹下 1\blog\node_modules\hexo-asset-image想要卸载这个插件怎么处理，我听说直接删掉这个文件夹，反正我这么试过了。 md文件的时间标签hexo-asset-image的原理应该是根据Hexo生成html后以时间的为目录的规则，将我们图片的相对地址转换成了生成后与时间对应目录的绝对地址，因此我认为md文件中应该要有时间标签，一来是为了让Hexo根据md的时间标签来确定文章的新旧排序，如果没有时间标签，Hexo会把md文件的修改时间作为发布时间，这显然是不合理的，再者这个时间标签，我想hexo-asset-image也会引用到，在一篇实际的博文中，我的md文件完整的开头是这样的： 1234567title: hexo中完美插入本地图片date: 2017-01-23 11:00:55categories: hexo使用tags: - hexo- 本地图片- hexo-asset-image插入图片由于每个md文件都有对应的一个资源文件夹，因此，你首先要把需要插入的图片放到这个资源文件夹下，然后进行路径引用，这是上面插入图片时的实际引用代码 1![QQ截图20170123114005](&#x2F;hexo中完美插入本地图片&#x2F;QQ截图20170123114005.png)使用Typora又有一个十分方便的地方在于，只需要将图片往这里一拖就插入了，但其实际拖入图片后的插入代码是绝对路径的引用，是这样的 1![QQ截图20170123114005](K:\FangCloudSync\Github博客源码\blog\source\_posts\hexo中完美插入本地图片\QQ截图20170123114005.png)对比上面的两个代码，我只需要将前面的那段绝对路径删掉K:\FangCloudSync\Github博客源码\blog\source_posts ，然后再将剩余的两个\分别换成/ 就可以了 当然你要是觉得还是麻烦，可以直接打开typora的偏好设置 进行如上设置，就不用手动编辑成相对路径了 这样子，Typora编辑时同时能够看到插入的图片。]]></content>
      <categories>
        <category>兴趣</category>
      </categories>
      <tags>
        <tag>hexo配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于酷q平台的管理机器人]]></title>
    <url>%2F2019%2F10%2F01%2F%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[酷Q机器人 自从samrtQQ下线之后，很多QQ机器人都失效了。 但是最近又比较想用这样一个机器人来管理减轻自己的一些工作，于是千方百计的我发现了酷Q。 这里附上官网链接 开发以及注意事项SDK的选择酷q提供了多种SDK但是都是我不常用的，官方的支持的SDK是E语言，这语言emmmm好，都好，写，都可以写。虽然提供了java的sdk但是java版本始终不是正统，咬牙学了一天E语言，最后还是吐了。没办法，不习惯，没说E语言不好。害，最后还是选择的java版本。不过但是还没开始使用的时候我看到了更加好用的一个找到一个更加好用方便的SDK-PicqBotX，这是通过http的插件来与酷q的程序交互。虽然不能像官方网站上提供的那个那样可以直接打包成jar运行但是个人认为开发更加简单。环境以及配置细节这里讲得很清楚，以下说明几个坑：如果使用kotlin代替java进行开发，请最好使用Gradle对项目进行管理，它对kotlin有更加完美的支持。在介绍readme中的这个位置一定要看准，下载对应版本的工具，否则可能出问题，比较麻烦，而且没有提示难以排查。两个端口号一定要对应于你程序中的机器人的端口号否则会链接失败（建议直接用默认的31091 31092，也可自己选择）本人开发流程使用idea新建项目选择gradle管理项目java版本任意，需要kotlin开发勾选kotlin导包 导入最新的sdk。 根据需要复制示例代码更改个人实现效果和功能通知功能请假功能有学生请假则会以json格式文本保存在服务器（或者本地）导出请假表格文档，会直接给下载链接补登请假还有安卓端的管理app和网页版实时查看数据。部署机器人在winows server上部署 太简单了，省略具体步骤，总结解释就是以下步骤： 电脑上安装上所有酷q，http插件，java所需要的环境，跟你的本地一样（本地会配置，我想server上配置也难不倒聪明的你）打包你的机器人，可以是jar可以是其他的，只要是能够将你的代码打包运行就好运行酷q，打开http插件，运行你的机器人。在linux上部署 因为酷q是window程序，要想在linux上部署那就必须得使用docker（不知道docker是什么的请百度），由于不是专业运维方向对docker不是很了解，也踩了很多坑。 这里附上http插件的官方教程，里面有详细的描述如何安装最新的酷q的docker镜像，如果docker还没安装自行百度安装你的服务器的docker。 然后基本上和以上步骤都是差不多，但是有个地方需要注意 这里的上报地址，理所当然就是酷q接收到消息之后传递给你的程序去处理，但是在docker中利用127.0.0.1是访问的docker内部，而你的机器人程序并不是在docker内所以，酷q是无法将消息上报给你的机器人的，有以下解决方案： 对于mac和windows可以使用host.docker.internal替换127.0.0.1对于Linux可以创建一个桥接网络(我在网络上查找的，自己在centos上没有尝试成功)下面的localNet是网络名字,可自行修改;关于192.168.0.0这个子网,也可以自行定义.默认按照下面的命令,执行后将可以通过192.168.0.1访问宿主机docker network create -d bridge --subnet 192.168.0.0/24 --gateway 192.168.0.1 localNet若你是在你的服务器上部署的你的机器人，可以直接使用服务器的公网ip只有这样酷q才能将消息上报到你的机器人处理,否则你的机器人只能发送消息，不能接收消息并作出反应。 用到的库 阿帕奇的表格框架gson通知管理机器人源代码地址：冷漠无情的机器人 因为源代码中有不少私人数据，所以取消。]]></content>
      <categories>
        <category>兴趣</category>
      </categories>
      <tags>
        <tag>世界这么大，当然要多去看看</tag>
      </tags>
  </entry>
</search>
