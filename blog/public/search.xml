<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android消息机制深入了解</title>
      <link href="/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
      <url>/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么消息机制这么重要呢">为什么消息机制这么重要呢<a href="2020/03/08/Android消息机制深入了解#为什么消息机制这么重要呢"></a></h1><p>其实一个安卓的app也是有自己的<strong>main</strong>方法的<img src="/2020/03/08/Android消息机制深入了解/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg" alt="img" style="zoom:50%;">，跟一个普通的java程序并没有太大的区别，只不过用户接触不到这个方法，这个方法在<strong>ActivityThread</strong>这个类里面，这个也就是android中所说的<strong>UI线程</strong>。你可能在想一个问题，那么既然是一个有main方法的java程序，那么一整个安卓的app究竟是怎么来运行的呢，如何做到和用户交互并执行这些代码的呢？？（这里涉及到很多东西，本文只讲与<strong>消息机制相关</strong>的，文章<strong>末尾</strong>我会一一解释）<img src="/2020/03/08/Android消息机制深入了解/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg" alt="img" style="zoom:50%;"></p><h1 id="消息机制重要的三大成员">消息机制重要的三大成员<a href="2020/03/08/Android消息机制深入了解#消息机制重要的三大成员"></a></h1><ul><li><p><strong>MessageQueue</strong></p></li><li><p><strong>Looper</strong></p></li><li><p><strong>Handler</strong></p><blockquote><p>一个线程只能有一个Looper和MessageQueue，但是可以有多个handler，为什么呢？后面我们慢慢会讲到。</p></blockquote></li></ul><p>那么这三者是如何配合的呢，简单来说，<strong>MessageQueue</strong>就是一根<strong>运输消息管道</strong>，handler负责不断往里面<strong>放</strong>，<strong>Looper</strong>负责不断从里面<strong>取</strong>出来，又交给发送的这个handler去处理，那么就出现两个问题？</p><ul><li>那么为什么要这样子设计？这样子设计怎么实现的<strong>跨线程通信</strong></li><li>为什么handler放进去最后looper又要交还给发送消息的这个handler去处理</li></ul><p>通过后面的源码解析，就能自己领会这两个问题</p><h1 id="消息机制主要流程详解">消息机制主要流程详解<a href="2020/03/08/Android消息机制深入了解#消息机制主要流程详解"></a></h1><p>如果你要在一个线程中使用消息机制</p><p>首先需要<code>Looper.prepare();</code>和<code>Looper.loop();</code>，然后你就可以使用你的<strong>handler发送消息</strong>了。</p><blockquote><p>主线程是不需要自己<code>Looper.prepare();</code>和<code>Looper.loop();</code>在ActivityThread的main方法里面就已经执行了类似代码<code>Looper.prepareMainLooper();</code>和<code>Looper.loop();</code></p></blockquote><p>下面我会逐一从<strong>源码层面</strong>来分析整个消息机制的主要流程<img src="/2020/03/08/Android消息机制深入了解/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg" alt="img" style="zoom:50%;">，会不会很难呢，要不要继续学下去，头发 - -。</p><h2 id="Looper-prepare-；">Looper.prepare()；<a href="2020/03/08/Android消息机制深入了解#Looper-prepare-；"></a></h2><p>首先我们点进去看看代码是如何实现的</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数在ActivityThread的main方法里面执行,用户创建主线程的Looper对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通常我们在其他线程如果需要用到消息机制，会执行这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数重载，这个参数用于构造一个可以关闭或者无法关闭的Looper</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>最重要的方法就是第三个<code>prepare(boolean quitAllowed)</code>，我们可以看到代码很短，也很好理解。</p><p>首先调用这个这个<strong>Looper类</strong>里面一个<strong>静态变量<code>sThreadLocal</code></strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></div></figure><p>这是一个<strong><code>ThreadLocal&lt;Looper&gt;</code>类型</strong>的一个变量，而且是直接<strong><code>new</code>出来的</strong>,点击进去看</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>查看<strong>ThreadLocal源代码里面的构造方法</strong>也没有做任何操作，说明本身这个变量是里是没有我们想要的东西的</p><p>那么<strong>关键肯定是在<code>sThreadLocal.get()</code>里面</strong>，通过后面的抛出异常</p><p><code>throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</code></p><p>我们可以断定这个<strong>判断</strong>肯定<strong>是</strong>用来<strong>判断当前线程是否已经存在了一个Lopper对象</strong></p><p>接下来我们来看<code>get()</code>方法内部</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码不是很多，我们一步步分析</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();<span class="comment">//获得当前的线程对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//从当前线程拿到一个ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;<span class="comment">//如果这个ThreadLocalMap不为空</span></span><br><span class="line">      <span class="comment">//从里面取得Looper（这里做了一个包装，稍后会讲到）</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">//如果Lopper不为空</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;<span class="comment">//直接返回Looper</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();<span class="comment">//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可能虽然有注释还是有些疑惑，下面我们一一来讲解一下 Why<img src="/2020/03/08/Android消息机制深入了解/v2-639605533bdb1ecf1c6562677a430554_hd.jpg" alt="img" style="zoom:50%;"></p><p>首先我们来看看<strong><code>ThreadLocalMap map = getMap(t);</code>中<code>get(t)</code>的代码</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以看到，是直接返回了<strong>当前线程对象</strong>的一个<strong>成员变量<code>threadLocals</code></strong>，那么这个<code>threadLocals</code>究竟是个什么东西呢？</p><h3 id="ThreadLocal和ThreadLocalMap">ThreadLocal和ThreadLocalMap<a href="2020/03/08/Android消息机制深入了解#ThreadLocal和ThreadLocalMap"></a></h3><p>首先我们来看<code>ThreadLocal</code>，顾名思义，直接翻译过来就是 “线程本地” ？？<img src="/2020/03/08/Android消息机制深入了解/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg" alt="img" style="zoom:50%;"></p><p>我们来看看这个类的介绍注释</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class provides thread-local variables.  These variables differ from</span></span><br><span class="line"><span class="comment"> * their normal counterparts in that each thread that accesses one (via its</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> get&#125; or &#123;<span class="doctag">@code</span> set&#125; method) has its own, independently initialized</span></span><br><span class="line"><span class="comment"> * copy of the variable.  &#123;<span class="doctag">@code</span> ThreadLocal&#125; instances are typically private</span></span><br><span class="line"><span class="comment"> * static fields in classes that wish to associate state with a thread (e.g.,</span></span><br><span class="line"><span class="comment"> * a user ID or Transaction ID).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 谷歌翻译版本:</span></span><br><span class="line"><span class="comment">* 此类提供线程局部变量</span></span><br><span class="line"><span class="comment">* 这些变量不同于它们的普通副本，</span></span><br><span class="line"><span class="comment">* 因为每个访问一个变量的线程（通过其&#123;<span class="doctag">@code</span> get&#125;或&#123;<span class="doctag">@code</span> set&#125;方法）</span></span><br><span class="line"><span class="comment">* 都有自己的、独立的变量副本。</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> ThreadLocal&#125;实例通常是类中的私有静态字段，希望将状态与线程关联（例如，*用户ID或事务ID）。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure><p>通过注释我们可以很轻松的理解到，原来这个东西就是为每一个线程创建一个单独的变量副本的呀<img src="/2020/03/08/Android消息机制深入了解/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg" alt="img" style="zoom:50%;">。</p><p>我们来看看到底怎么使用</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal&lt;Integer&gt; integerThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;()&#123;</span><br><span class="line">            <span class="comment">//这个方法专门用来提供开发者复写，提供副本默认值</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2333</span>;<span class="comment">//默认值我们这设置为</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//为这个ThreadLocal&lt;Integer&gt;在当前线程存一个副本，值为3222</span></span><br><span class="line">                    <span class="comment">//如果不是基本数据类型，注意值传递和引用传递的区别，这里需要new一个新的放进去</span></span><br><span class="line">                    <span class="comment">//例如：ThreadLocal的泛型是Runnable,</span></span><br><span class="line">                    <span class="comment">//那么就需要新建一个独立的Runnable实现类的对象</span></span><br><span class="line">                    <span class="comment">//runnableThreadLocal.set(new Runnable() &#123;</span></span><br><span class="line">                    <span class="comment">//            @Override</span></span><br><span class="line">                    <span class="comment">//            public void run() &#123;</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">//            &#125;</span></span><br><span class="line">                    <span class="comment">//        &#125;;)</span></span><br><span class="line">                    integerThreadLocal.set(<span class="number">3222</span>);</span><br><span class="line">                    <span class="comment">//获取当前线程的副本，如果之前没有set()，那么默认值为2333</span></span><br><span class="line">                  <span class="comment">//如果之前set()了，就会取得set()的那个对象</span></span><br><span class="line">                    integerThreadLocal.get();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 通过以上代码，在这5个线程里都有了一个与integerThreadLocal对应</span></span><br><span class="line"><span class="comment">                     * 变量副本，这个副本是Integer类型的，每个线程通过integerThreadLocal.get()</span></span><br><span class="line"><span class="comment">                     * 取到的都是线程独有的，与其他线程完全隔离的一个副本</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>通过上面的注释就足以理解这个东西的用法，这时候我们回到安卓来看看消息机制这里的设计，是不是就一下子恍然大悟了<img src="/2020/03/08/Android消息机制深入了解/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg" alt="img" style="zoom:50%;">，我这再梳理一下</p><ul><li><p>首先Lopper中是有一个<code>sThreadLocal</code></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></div></figure><p>理解了上面小Demo,就能知道这个<code>sThreadLocal</code>的存在是为了方便在每一个线程存一个Looper副本</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>看，这是不是就很清晰了<img src="/2020/03/08/Android消息机制深入了解/v2-8312b637ba6407992515ffa42b56391d_hd.jpg" alt="img" style="zoom:50%;"></p></li></ul><p>然后我们来看看<code>ThreadLocalMap</code>，前面我们看到<code>ThreadLocal.get()</code>的<code>get()</code>方法,这里再把代码贴一下</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();<span class="comment">//获得当前的线程对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//从当前线程拿到一个ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;<span class="comment">//如果这个ThreadLocalMap不为空</span></span><br><span class="line">      <span class="comment">//从里面取得Looper（这里做了一个包装，稍后会讲到）</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">//如果Lopper不为空</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;<span class="comment">//直接返回Looper</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();<span class="comment">//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>从上面的代码可以知道，一个线程对象里面是有一个<code>threadLocals</code>属性的，它是一个<code>ThreadLocalMap</code>类型的变量。就是它用来储存各种存在当前线程的副本。他是一个键值对存储的形式,下面是<code>ThreadLocalMap</code>的set（）方法的声明</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(ThreadLocal&lt;?&gt; key, Object value)</span><br></pre></td></tr></table></div></figure><p>具体实现是比较复杂的，用到哈希表来储存，这里不展开讲了，有兴趣可以去了解一下，文章后面会有超链接。</p><p>然后我们来看看<code>ThreadLocalMap.Entry e = map.getEntry(this);</code>这个行代码，肯定很多人都会有疑惑，首先我们需要看一下ThreadLocalMap.Entry这个静态内部类</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里你可以看到这里是直接继承WeakReference弱引用这个类的，那为什么要这么设计呢？<img src="/2020/03/08/Android消息机制深入了解/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg" alt="img" style="zoom:50%;"></p><p>这里我大致的说一下，ThreadLocal是为了每个线程中的对象副本服务的，一旦我不需要使用ThreadLocal这个对象了，那么我肯定会将ThreadLocal对象的强引用去掉，以防止内存泄漏，但是这个如果不这么设计，如果有一个线程的生命周期比ThreadLocal长，那么必定会持有ThreadLocal的引用，这样就会导致内存泄漏，ThreadLocal没有被使用但是却无法被GC回收。相比之下，这样设计就不会出现这个问题。</p><h3 id="Looper的构造方法">Looper的构造方法<a href="2020/03/08/Android消息机制深入了解#Looper的构造方法"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);<span class="comment">//生成一个MessageQueue，并作为成员保存在Looper中</span></span><br><span class="line">    mThread = Thread.currentThread();<span class="comment">//绑定当前线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>从上面的代码也印证了Looper和MessageQueue一般都是同时出现的，而且都只能有一个的言论（因为prepare方法在一个线程调用一次，前面代码提到过）。</p><h2 id="Looper-loop">Looper.loop<a href="2020/03/08/Android消息机制深入了解#Looper-loop"></a></h2><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为方便，我只选择了关键代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//取得当前线程的Looper，当然实际上也是通过sThreadLocal.get()</span></span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;<span class="comment">//如果没有说明没有调用prepare(),抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//从当前的Looper对象里取得对应的MessageQueue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//do something............</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// 取出消息，这里可能会堵塞，直到重新取到消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//如果返回为空，则表示MessageQueue正在退出，所以这里也直接退出无限循环</span></span><br><span class="line">              <span class="comment">//这里是只有MessageQueue调用quit(boolean safe)方法才会退出</span></span><br><span class="line">              <span class="comment">//下面会有详细解释</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//do something.............</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//这个target是发送这个消息的handler，取得消息之后让发送的这个handler去处理</span></span><br><span class="line">          <span class="comment">//后面我们会讲到，handler是如何把这个消息发送到当前这个MessageQueue中，并且target的赋值</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//do something.............</span></span><br><span class="line">            msg.recycleUnchecked();<span class="comment">//回收这个消息</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>通过代码应该很清晰就能展现出关键点，这里就不再赘述</p><p>因为这里涉及到Looper.loop退出的情况，下面我们用代码类分析一下，关键就在<code>queue.next()</code>，为了便于理解还是只凸显出主要代码，还有很多MessageQueue的消息处理的一些代码就不赘述了，下面代码重点看那个返回值为空的判断语句</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//do something..........</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;<span class="comment">//next中也是一个无限循环着也就很好的说明为什么next()是一个可堵塞的方法啦</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//do something..........</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                prevMsg = msg;</span><br><span class="line">                msg = msg.next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//这里是后面handler的sendMessage方法会给message添加一个时间的处理</span></span><br><span class="line">            <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                <span class="comment">//do something..........</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//do something..........</span></span><br><span class="line">                <span class="keyword">return</span> msg;<span class="comment">//如果所有条件都满足，就可以直接返回这个message了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No more messages.</span></span><br><span class="line">            nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">      <span class="comment">// 前面没有返回，这里如果为true只就直接返回null，前面Looper.loop就退出了</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            dispose();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//do something..........</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">            mBlocked = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//do something..........</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>我们来看看<code>mQuitting</code>这个变量是在哪被赋值为true的</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//mQuitAllowed这个其实在前文多次提到了，Looper和MessageQueue的构造方法都需要</span></span><br><span class="line">  <span class="comment">//用来设定是否可以被退出</span></span><br><span class="line">    <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mQuitting = <span class="keyword">true</span>;<span class="comment">//关键代码，这里赋值为true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">            removeAllFutureMessagesLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>从上面分析我们可以知道一旦调用了MessageQueue的quit的方法那么MessageQueue下一个利用next方法去取消息就会返回null，返回null就导致Looper的loop(也就是无限取消息的循环退出了),那么就有一个问题了，Looper也有一个quit方法，怎么实现的呢？</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>恍然大悟！！！！！！！<img src="/2020/03/08/Android消息机制深入了解/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg" alt="img" style="zoom:50%;"></p><h2 id="handler-sendMessage">handler.sendMessage()<a href="2020/03/08/Android消息机制深入了解#handler-sendMessage"></a></h2><p>看发送消息之前我们需要先看看Handler的构造方法</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@Nullable Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//do something............</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取当前线程的Looper</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;<span class="comment">//同样如果没有Looper会报错（没有Looper.prepare()）</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    mQueue = mLooper.mQueue;<span class="comment">//绑定当前线程的MessageQueue</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//do something............</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以看出Handler在那个线程创建，它就会直接绑定哪个线程的MessageQueue，之后它<code>sendMessage()</code>就可以直接放到这个MessageQueue里面</p><p>还是直接来看<code>sendMessage()</code>的代码</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点进来第一个方法是这个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送延迟处理的消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;<span class="comment">//拿到创建Handler时绑定的那个MessageQueue</span></span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(@NonNull MessageQueue queue, @NonNull Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;<span class="comment">//【发送的消息】绑定【发送消息的这个handler】</span></span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//把消息交给MessageQueue去排序消息，这里是根据uptimeMillis转成具体时刻来排序的</span></span><br><span class="line">  <span class="comment">//这里要注意，发送的延迟消息，只能保持设置的时间前这个消息不被处理</span></span><br><span class="line">  <span class="comment">//但是无法保证这个消息具体在设置的时间之后的那个时候被处理</span></span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="handler-post">handler.post()<a href="2020/03/08/Android消息机制深入了解#handler-post"></a></h3><p>还是直接看代码，如果上面的理解了这个就非常简单了<img src="/2020/03/08/Android消息机制深入了解/v2-8312b637ba6407992515ffa42b56391d_hd-3736965.jpg" alt="img" style="zoom:50%;">，只有一些区别</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(@NonNull Runnable r)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这里仍然还是调用的发送延时消息的方法，区别是下面那个方法</span></span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将Runnable包装成Message，那么这个Runnable在哪会被调用呢</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>还记得前面讲到的Looper.loop吗，它会把消息交给与他绑定的Handler去处理来看看这个方法</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;<span class="comment">//优先优先判断callback是不是空</span></span><br><span class="line">        handleCallback(msg);<span class="comment">//不为空直接调用方法处理callback</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();<span class="comment">//这里直接执行了runnable的run方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="结尾">结尾<a href="2020/03/08/Android消息机制深入了解#结尾"></a></h1><p>文章开头留下的悬念我想这下已经很清晰了，主线程中的main方法调用了Looper.loop,正是有这个无限循环的存在才会不会想一个简单的java程序一样，执行完了main里面的代码程序就结束了，而<code>prepareMainLooper</code>,正是为主线程（UI线程）准备了一个不可以退出的Looper。而这就可以说明Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞它。<strong>也就说我们的代码其实就是在这个循环里面去执行的</strong>，所以你在你的子线程要使用消息机制接受消息的话，最好将Looper.loop()放到你要直接执行的所有代码后面，不然没有执行qiut方法，后面的代码就不会执行。<img src="/2020/03/08/Android消息机制深入了解/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg" alt="img" style="zoom: 67%;">真逊，原来这么简单，是吧，看来还是要好好学习下去，知识++。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 温故知新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令以及如何在idea上可视化操作git</title>
      <link href="/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/"/>
      <url>/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/</url>
      
        <content type="html"><![CDATA[<h1 id="git">git<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#git"></a></h1><p>链接在手，天下你有，自己去详细学习吧：<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener"> 史上最浅显易懂的Git教程！ </a></p><h2 id="概念">概念<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#概念"></a></h2><h3 id="工作区（Working-Directory）">工作区（Working Directory）<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#工作区（Working-Directory）"></a></h3><p>是我们直接编辑的地方，例如 idea 打开的项目，记事本打开的文本等，肉眼可见，直接操作。</p><h3 id="暂存区（Stage-或-Index）">暂存区（Stage 或 Index）<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#暂存区（Stage-或-Index）"></a></h3><p>数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。</p><h3 id="版本库（commit-History）">版本库（commit History）<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#版本库（commit-History）"></a></h3><p>存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程仓库了。</p><p><img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/2429e4d2661e60027537aea0077f6e40.png" alt="git 数据流程图示意图" class="article-img"></p><h2 id="常用命令讲解">常用命令讲解<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#常用命令讲解"></a></h2><h3 id="Git-常用命令汇总">Git 常用命令汇总<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#Git-常用命令汇总"></a></h3><h4 id="1、远程仓库相关命令">1、远程仓库相关命令<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#1、远程仓库相关命令"></a></h4><ul><li>检出仓库：$ git clone [remoteName]</li><li>查看远程仓库：$ git remote -v</li><li>添加远程仓库：$ git remote add [name] [url]</li><li>删除远程仓库：$ git rm [name]</li><li>修改远程仓库：$ git remote set-url –push [name] [newUrl]</li><li>拉取远程仓库：$ git pull [remoteName] [localBranchName]</li><li>推送远程仓库：$ git push [remoteName] [localBranchName]</li></ul><p><em>如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：</em></p><ul><li>$ git push origin test:master         // 提交本地test分支作为远程的master分支</li><li>$git push origin test:test              // 提交本地test分支作为远程的test分支</li></ul><h4 id="2、分支-branch-操作相关命令">2、分支(branch)操作相关命令<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#2、分支-branch-操作相关命令"></a></h4><ul><li><p>查看本地分支：$ git branch</p></li><li><p>查看远程分支：$ git branch -r</p></li><li><p>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch test</span><br></pre></td></tr></table></div></figure></li><li><p>切换分支：$ git checkout [name]</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout test</span><br></pre></td></tr></table></div></figure></li><li><p>创建新分支并立即切换到新分支：$ git checkout -b [name]</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b test</span><br></pre></td></tr></table></div></figure></li><li><p>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch -d test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">or</span></span><br><span class="line"></span><br><span class="line">git branch -D test</span><br></pre></td></tr></table></div></figure></li><li><p>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并</p></li><li><p>创建远程分支(本地分支push到远程)：$ git push origin [name]</p></li><li><p>删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name]</p></li><li><p><em>创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)</em></p></li><li><p>$git symbolic-ref HEAD refs/heads/[name]</p></li><li><p>$rm .git/index</p></li><li><p>$git clean -fdx</p></li></ul><h4 id="3、版本-tag-操作相关命令">3、版本(tag)操作相关命令<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#3、版本-tag-操作相关命令"></a></h4><ul><li>查看版本：$ git tag</li><li>创建版本：$ git tag [name]</li><li>删除版本：$ git tag -d [name]</li><li>查看远程版本：$ git tag -r</li><li>创建远程版本(本地版本push到远程)：$ git push origin [name]</li><li>删除远程版本：$ git push origin :refs/tags/[name]</li><li>合并远程仓库的tag到本地：$ git pull origin –tags</li><li>上传本地tag到远程仓库：$ git push origin –tags</li><li>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’</li></ul><h4 id="4、忽略一些文件、文件夹不提交">4、忽略一些文件、文件夹不提交<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#4、忽略一些文件、文件夹不提交"></a></h4><p><a href="https://jontree.github.io/2019/10/04/gitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">.gitignore文件详解</a></p><h3 id="附页：-Git-常用命令速查">附页： Git 常用命令速查<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#附页：-Git-常用命令速查"></a></h3><ul><li>git branch 查看本地所有分支</li><li>git status 查看当前状态</li><li>git commit 提交</li><li>git branch -a 查看所有的分支</li><li>git branch -r 查看远程所有分支</li><li>git commit -am “init” 提交并且加注释</li><li>git remote add origin <a href="mailto:git@192.168.1.119" target="_blank" rel="noopener">git@192.168.1.119</a>:ndshow</li><li>git push origin master 将文件给推到服务器上</li><li>git remote show origin 显示远程库origin里的资源</li><li>git push origin master:develop</li><li>git push origin master:hb-dev 将本地库与服务器上的库进行关联</li><li>git checkout –track origin/dev 切换到远程dev分支</li><li>git branch -D master develop 删除本地库develop</li><li>git checkout -b dev 建立一个新的本地分支dev</li><li>git merge origin/dev 将分支dev与当前分支进行合并</li><li>git checkout dev 切换到本地dev分支</li><li>git remote show 查看远程库</li><li>git add .</li><li>git rm 文件名(包括路径) 从git中删除指定文件</li><li>git clone git://github.com/schacon/grit.git从服务器上将代码给拉下来</li><li>git config –list 看所有用户</li><li>git ls-files 看已经被提交的</li><li>git rm [file name] 删除一个文件</li><li>git commit -a 提交当前repos的所有的改变</li><li>git add [file name] 添加一个文件到git index</li><li>git commit -v 当你用－v参数的时候可以看commit的差异</li><li>git commit -m “This is the message describing the commit” 添加commit信息</li><li>git commit -a -a是代表add，把所有的change加到git index里然后再commit</li><li>git commit -a -v 一般提交命令</li><li>git log 看你commit的日志</li><li>git diff 查看尚未暂存的更新</li><li>git rm a.a 移除文件(从暂存区和工作区中删除)</li><li>git rm –cached a.a 移除文件(只从暂存区中删除)</li><li>git commit -m “remove” 移除文件(从Git中删除)</li><li>git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)</li><li>git diff –cached 或 $ git diff –staged 查看尚未提交的更新</li><li>git stash push 将文件给push到一个临时空间中</li><li>git stash pop 将文件从临时空间pop下来</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p><ul><li>git remote add origin <a href="mailto:it@github.com" target="_blank" rel="noopener">it@github.com</a>:username/Hello-World.git</li><li>git push origin master 将本地项目给提交到服务器中</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p><ul><li>git pull 本地与服务器端同步</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p><ul><li>git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。</li><li>git push origin server fix:awesome branch</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p><ul><li>git fetch 相当于是从远程获取最新版本到本地，不会自动merge</li><li>git commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：</li><li>git branch branch_0.1 master 从主分支master创建branch_0.1分支</li><li>git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0</li><li>git checkout branch_1.0/master 切换到branch_1.0/master分支</li><li>du -hs</li><li>git branch 删除远程branch</li><li>git push origin:branch_remote_name</li><li>git branch -r -d branch_remote_name</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p><p>初始化版本库，并提交到远程服务器端</p><ul><li><p>mkdir </p><p>新建一个文件夹，一个空格后接你的文件夹的名字</p></li><li><p>cd </p><p>进入你的名字</p></li><li><p>git init本地初始化</p></li><li><p>touch README</p></li><li><p>git add README添加文件</p></li><li><p>git commit -m ‘first commit’</p></li><li><p>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:daixu/WebApp.git增加一个远程服务器端</p></li></ul><p>细讲我怕又是几小时 <img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/v2-daba4efa3f71587ad62c168eeb711a01_hd-1571838207875.jpg" alt="img" style="zoom:50%;">，下面我给你们简单介绍几个常用命令，也就是我门作业会用到的。也是今后我们用到最多的。</p><h1 id="github注册">github注册<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#github注册"></a></h1><p>链接在手，天下你有，自己去注册吧：<a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">github注册链接</a></p><p>好了现在你们什么都有了，你就是一个成熟的程序员的了</p><p><img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/006szvLFgy1fwll8fpyzdj30b407dq5d.jpg" alt="IT 从业者的压力究竟有多大？北京某互联网公司28岁程序员王某：其实我觉得吧，压力也没那么大 - 程序员表情包系列_程序员_码农表情" class="article-img"></p><h1 id="接下来我们来偷懒">接下来我们来偷懒<a href="2019/12/30/git常用命令以及如何在idea上可视化操作git#接下来我们来偷懒"></a></h1><p>你觉得上面的git命令复杂可以先不看，github里面新建工程啥的太麻烦可以先不看。</p><p>打开你神奇的idea，并打开你的项目</p><p>假如现在你要上传你的项目到你的github，你只需要 点  点  点</p><p><img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/TIM%E6%88%AA%E5%9B%BE20191023163526.png" alt="TIM截图20191023163526" class="article-img"></p><p>这一步如果你还没登陆的话会要求你登陆，我这已经登陆了所以直接弹出了这个框，点击share就会帮你在本地执行<code>git init</code> <code>git add .</code> <code>git add remote</code> 你的github里面创建仓库并把你的整个工程传上去，一把梭爽不爽 <img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd.jpg" alt="img" style="zoom: 50%;">爽</p><p><img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/TIM%E6%88%AA%E5%9B%BE20191023163817.png" alt="TIM截图20191023163817" class="article-img"></p><p>好了正式开始你的程序员生活了<img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/1571820564925.jpeg" alt="1571820564925" style="zoom: 18%;">，如何拉网络去你仓库的更新呢？只需  <strong>点</strong>   <strong>点 **   **点</strong></p><p><img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/TIM%E6%88%AA%E5%9B%BE20191023165925.png" alt="TIM截图20191023165925" class="article-img"></p><p>其实拉取对现阶段的你们还没啥用，毕竟远程的就是你本地的本地提交的，但是你和别人合作开发的时候就需要拉取了，为啥呢，因为可能他改了之后提交到远程了呀，你需要更新本地到远程的最新版</p><p>那如何提交呢？<img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/1571820567750.jpeg" alt="1571820567750" style="zoom:25%;"> 只需要  <strong>点  点  点</strong> </p><p><img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/TIM%E6%88%AA%E5%9B%BE20191023170652.png" alt="TIM截图20191023170652" class="article-img"></p><p>中间那个大框框里写你这次提交描述，点击下面的，commit就会提交到本地的版本库，你要是想提交到版本库之后直接把代码更新到远程github的仓库里，右边那个小三角，然后commit and push，提交到本地时同时上传远程，会出现，如下页面：</p><p><img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/TIM%E6%88%AA%E5%9B%BE20191023170946.png" alt="TIM截图20191023170946" class="article-img"></p><p>点击push就可以了。</p><p>那么问题来了，要是你就想直接commit在本地，等今天工作完了，再push到远程呢？只需   <strong>点</strong>   <strong>点</strong>    <strong>点</strong></p><p><img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/TIM%E6%88%AA%E5%9B%BE20191023171200.png" alt="TIM截图20191023171200" class="article-img"></p><p>好了 ，现在为止你已经会了基本的git操作，是不是超简单。</p><p>好了我来学习更多的git操作，对你自己说，<strong>”我  。 才  。  不  。  要  。   记  。   命  。  令。<img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/v2-fdddf30851f4370410c068f923e0c405_hd.jpg" alt="img" style="zoom:50%;">“</strong></p><p>假如你现在突发奇想有另外一个想法，想创建一个测试分支，来写那个功能，咋啦呢？ 只需  <strong>点    点    点</strong></p><p> <img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/TIM%E6%88%AA%E5%9B%BE20191023171820.png" alt="TIM截图20191023171820" class="article-img"></p><p>点击最下面的git 就能唤出这个窗口，这个英文应该大家都能看懂吧，这个英文看不懂就退群吧，思考一下怎么上大学几个月就把高中英语忘完了。</p><p>好了然后，你写了很多了，也提交了几次之后，你突然发现前面提交的那个有问题，不想提交了那咋办呢？ 只需<strong>点    点    点</strong></p><p><img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/TIM%E6%88%AA%E5%9B%BE20191023172756.png" alt="TIM截图20191023172756" class="article-img"></p><p>那就退到你刚刚新提交的那个版本前面一个呗，例如我觉得<code>test2</code>有问题那我就右键点击<code>test1</code>，然后</p><p><img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/TIM%E6%88%AA%E5%9B%BE20191023173110.png" alt="TIM截图20191023173110" class="article-img"></p><p>这样你刚刚的修改的提交就没了，但是如果你选择的时mix的话，你的修改还是会在的，变成没有提交状态了，我来解释一下这四个选项。</p><ul><li><code>soft</code>重置版本库但是暂存区和工作区不会</li><li><code>mixed</code>会充值版本库和暂存区，但是工作区还在</li><li><code>hard</code>会重置版本库暂存区工作区（危险操作，但是找都是可以找回来的）</li><li><code>keep</code>重置所有的但是会保留文件</li></ul><p>如果你完全不要本地的所有更改了，可以直接hard到最近一个commit（危险操作，虽然我经常做<img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/v2-a11eadf17f85c2caef8ac2e391d0cf69_hd.jpg" alt="img" style="zoom:50%;">）</p><p>好了现在假如你完成了你突发奇想的功能感觉还不错，想把test分支合并到主分支要咋办呢？ 还是<strong>点    点    点</strong></p><p>先切换回主分支</p><p><img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/TIM%E6%88%AA%E5%9B%BE20191023175603.png" alt="TIM截图20191023175603" class="article-img"></p><p>然后</p><p>点击test分支</p><p><img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/TIM%E6%88%AA%E5%9B%BE20191023175637.png" alt="TIM截图20191023175637" class="article-img"></p><p>这样就合并啦</p><p>这也太简单了吧<img src="/2019/12/30/git常用命令以及如何在idea上可视化操作git/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd.jpg" alt="img" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git常用命令备份 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea条件断点</title>
      <link href="/2019/11/07/idea%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9/"/>
      <url>/2019/11/07/idea%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="idea的条件断点">idea的条件断点<a href="2019/11/07/idea条件断点#idea的条件断点"></a></h1><p>超简单的使用方法，右键点击你的短点，即可出现条件短点设置，其中<code>condition</code>就是超好用的条件短点的判断语句，语句需要返回结果是bool类型的，可以使用：</p><ul><li>||</li><li>&amp;&amp;</li><li>|</li><li>&amp;</li></ul><p>来链接多个语句，并且可以访问断点<strong>所在的作用域里所有可用的变量或者方法。</strong></p><p><img src="/2019/11/07/idea条件断点/image-20191107003330787.png" alt="image-20191107003330787" class="article-img"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eclipse的常用15个快捷键</title>
      <link href="/2019/10/28/eclipse%E7%9A%84%E5%B8%B8%E7%94%A815%E4%B8%AA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/10/28/eclipse%E7%9A%84%E5%B8%B8%E7%94%A815%E4%B8%AA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="15-个-Eclipse-常用开发快捷键使用技巧"><strong>15 个 Eclipse 常用开发快捷键使用技巧</strong><a href="2019/10/28/eclipse的常用15个快捷键#15-个-Eclipse-常用开发快捷键使用技巧"></a></h1><ol><li><strong>alt+?</strong> 或 <strong>alt+/</strong>：自动补全代码或者提示代码</li><li><strong>ctrl+o</strong>：快速outline视图</li><li><strong>ctrl+shift+r</strong>：打开资源列表</li><li><strong>ctrl+shift+f</strong>：格式化代码</li><li><strong>ctrl+e</strong>：快速转换编辑器</li><li><strong>ctrl+page down</strong> 或 <strong>ctrl+page up</strong>： 选项卡之间快速切换</li><li><strong>shift+enter</strong> 及 <strong>ctrl+shift+enter</strong>： 在当前行上或者下边创建空白。</li><li><strong>Alt+方向键上下</strong>：上下行交换内容或把当前行内容把上或下移动</li><li><strong>Control+Alt+方向上下键</strong>：复制高亮显示的一行或多行</li><li><strong>ctrl+m</strong>：当前编辑页面窗口最大化</li><li><strong>ctrl+/</strong>：自动注释当前行或者选择的多行</li><li><strong>ctrl+shift+/</strong>：自动注释掉选择的代码块</li><li><strong>ctrl+d</strong>：删除当前行</li><li><strong>ctrl+shift+x</strong> 和 <strong>ctrl+shift+y</strong> ：英文字母大小写的转换</li><li><strong>ctrl+shift+o</strong>：自动引入包和删除无用包</li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java编译运行过程详解</title>
      <link href="/2019/10/23/java%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/10/23/java%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>java整个编译以及运行的过程相当繁琐，我就举一个简单的例子说明：</strong></p><p>Java程序从源文件创建到程序运行要经过两大步骤：</p><ol><li><p>源文件由编译器编译成字节码（ByteCode）； </p></li><li><p>字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言</p></li></ol><p>（ “semi-interpreted” language）</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Animal = "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal(<span class="string">"super_yc"</span>);</span><br><span class="line">        animal.printName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>第一步（编译）：</strong></p><p>创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，如果这个类所依赖的类还没有被编译，</p><p>编译器会自动的先编译这个所依赖的类，然后引用。如果java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报</p><p>“Cant found sysbol”的异常错误。</p><p>编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、</p><p>方法引用，成员变量引用等）；方法字节码中放的是各个方法的字节码。</p><p><strong>第二步（运行）：</strong></p><p>java类运行的过程大概分为两个步骤：（1）类的加载 （2）类的执行。需要说明的一点的是：JVM主要在程序第一次运行时主动使用类的</p><p>时候，才会立即去加载。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到，不得不加载的时候，才加载进来，而且只加载一次！</p><p><strong>根据上面的程序，详解该程序运行的详细步骤：</strong></p><ol><li>在类路径下找到编译好的 java 程序中得到 Test.class 字节码文件后，在命令行上敲 java Test，系统就会启动一个 JVM 进程，JVM进程从classpath路径下找到一个名为Test.class的二进制文件，将Test.class文件中的类信息加载到运行时数据区的方法区中，这一过程叫做类的加载。（只有类信息在方法区中，才能创建对象，使用类中的成员变量）</li></ol><ol start="2"><li>JVM 找到main方法的主函数入口， 持有一个指向当前类(Test)常量池的指针，而常量池中的第一项是发现是一个对Animal对象的符号引用，并且main方法中第一条指令是Animal animal = new Animal(“super_yc”)，就是让JVM创建一个Animal对象，但是方法区中还没有Animal类的类信息，于是JVM就要马上的加载Animal类，将Animal类信息放入到方法区中，于是JVM 以一个直接指向方法区 Animal类的指针替换了常量池中第一项的符号引用。</li></ol><ol start="3"><li>加载完Animal类的信息以后，JVM虚拟机就会在堆内存中为一个Animal类实例分配内存，然后调用其构造函数初始化Animal实例，这个实例持有指向方法区的Animal类的类型信息（其中包含有方发表，java动态绑定的底层实现）的引用。（animal指向了Animal对象的引用会自动的放在栈中，字符串常量”super_yc”会自动的放在方法区的常量池中，对象会自动的放入堆区）</li></ol><ol start="4"><li>当使用 animal.pringName()的时候，JVM根据栈中animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型</li></ol><p>信息方法表，获得pringName()函数的字节码地址，然后开始运行函数。</p><p>参考<a href="https://blog.csdn.net/super_YC/article/details/71439786" target="_blank" rel="noopener">原文链接</a>，以下做自己的整理备份</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 课件附页 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课件附页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面向对象-接口和其他的类</title>
      <link href="/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/"/>
      <url>/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言：">前言：<a href="2019/10/12/java面向对象-接口和其他的类#前言："></a></h1><p><strong>听我讲课也就图一乐，要想真学到东西还是得自己看书。</strong></p><p><strong>大学学习最重要的莫过于是自学能力，我归纳的东西也许细节上有可能和书上有差异，因为我毕竟不是专业的，要想深究还是得对照书去看，我这只是对你们的一个引导</strong>。</p><p><strong>万物皆可为对象那么对象与对象之间肯定不是独立的，上节课谢磊学长讲了类的继承，那是一种最广泛的关系。今天我们了解一点更加抽象一点的东西，但是只要大家认真听我想还是会有所明白。</strong></p><h1 id="先来吹吹概念">先来吹吹概念<a href="2019/10/12/java面向对象-接口和其他的类#先来吹吹概念"></a></h1><p><strong>小恐龙镇压，让学习不再困难：</strong></p><p><img src="/2019/10/12/java面向对象-接口和其他的类/v2-db4581e2b067caef5a9586f7eebdf201_hd-1571838820692.jpg" alt="img" style="zoom: 50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-8a2e689837fdbbbf4b1ab294f9b8dd1e_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-61c75070123da9b76126716abb4c0dc0_hd-1571843419436.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-c73dbda0a22ac613aa85548743e89311_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-52943cfec07e50eccbe2b6f6e4c7afcb_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-621e04e365e7d4a385575811df365d92_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-71abcc971fa6b70a60fed90756317c19_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-aafe63145f01d7c98b9ca567484a2dea_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-a67b056f65147bc9971073f6b23d2aa3_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-d238eb952899a0a26dd5b66a36f76c56_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-fdddf30851f4370410c068f923e0c405_hd-1571843588629.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-ea2fa82794080c01e783ce025c450116_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-c4f54c756177054f05115c55be8058d7_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-cf3a3ed1086e56442c381a3ee8a1fee9_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-1a566b02828b4759584f5a5e6fee2903_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-bffbbe33c937ceb498d0882bf21a651c_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-75af770ceb10d0dcfbf702142f5c625b_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-325a1104a87fafd601284c628fa6aea9_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-23b4f1f3873f02b9e9abd2d1ab30a73f_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-ec6f0e0dfb5dc6805387101614784dcf_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-99e68ddacf27251a57bfffc82a43a2a0_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-7e64adbe12f97ac1fb00fc17d7d72f28_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-7a637419db11fb84c062b0361a4045db_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-bdb493d4a6d79ffa93fe78c71a2fd1a8_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-8312b637ba6407992515ffa42b56391d_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-bc2e4a10498c1b64a01628d0df373856_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-81940f37a0165b0459cb03241922e3ee_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-639605533bdb1ecf1c6562677a430554_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-45a9abdf48e6be17cb8d9e31b53578f9_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-02ffe126c98c17d03a83adad5f65938b_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-24c27adb48dfeffc6de36260df10bad5_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-e608e1d4f94a6d0c06f9e9b78d5458b5_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-05aa749d19004c9fea98e84fcea3307f_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-4d0519e265a57a53b7f92599fce86a9c_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg" alt="img" style="zoom:50%;">  <img src="/2019/10/12/java面向对象-接口和其他的类/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-0bc6bbbfcf6d855c832b055aae892f1a_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-a959fa53966fc0b6400f88c50b8b95e3_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-afd6a92d4313b460829bf99b7ef3759e_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-8d05da004dc65b91ffa63dcc213b7714_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-45b057e23dd633692fb0154f4a09ca49_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-53ac2d7b9f62a8ff17b795cc73570734_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-8c6c3bde98e8cf206839bf57085af02e_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-87072b9873cd5e8703a473b191e17042_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-f50699afeec4929bdc58d56db811bc47_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-e015f2d920aa5e00fa4b25d3b6a79bac_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-13d572e979351e77f984cd5b38a019b3_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-cb5372ddead7e3c2bfcbc8e50e5e941f_hd.jpg" alt="img" style="zoom:50%;"> <img src="/2019/10/12/java面向对象-接口和其他的类/v2-e36c4694236b67a6e655c77d0e5336cf_hd.jpg" alt="img" style="zoom:50%;"> ！</p><h2 id="接口">接口<a href="2019/10/12/java面向对象-接口和其他的类#接口"></a></h2><blockquote><p>接口最通俗的来讲就是一种统一的规范或者叫做协议，接口这个名称有点晦涩难懂，但是其实接口就是一个基于双方或者多方的协议</p><p>下面举几个例子：</p><ul><li>你们用的插座的插孔可以被叫做接口（协议），因为这个规范存在，在中国无论你是什么充电器，只要是这个充电口，那么我就会给你输出电流，至于你充什么，干什么我都不管。</li><li>你去面试，他说你必须有本科及以上的文凭且必须过了四级才能有面试资格，这也算事接口（协议），因为如果你没有这些东西，就不能去面试，至于你是怎么努力学习拿到本科文凭和怎么努力拿到四级证书的，一律不管。</li><li>我今天布置了作业，我要收的是我布置的这些作业，至于你们每个人怎么去做出来我是不管的，那我布置的作业就是接口（协议），你们按照题目实现相应的功能就好，最后验收我也只会根据我布置的作业的应该输出的结果来看你是不是完成作业。（当然，当然我在作业文件中指出你不能用啥，我还是会看的具体细节的）</li></ul><p>现在，接口你们应该都应该大致明白是什么了吧。</p></blockquote><h3 id="接口有什么作用？或者接口存在的必要性？">接口有什么作用？或者接口存在的必要性？<a href="2019/10/12/java面向对象-接口和其他的类#接口有什么作用？或者接口存在的必要性？"></a></h3><blockquote><p>还是上一节的例子，如果国家没有规定这个插座的标准，那每个厂家的有自己的一套，你买公牛的插座就得买支持公牛插座的电器。出去在中国其他地方旅游你就只有背着各式各样的转接头。嗯，锻炼身体也是好事嘛。</p><p>所以国家就制定了标准。</p><p>编程中接口也差不多，所以重要性也就凸显出来了</p></blockquote><h3 id="编程中的接口？">编程中的接口？<a href="2019/10/12/java面向对象-接口和其他的类#编程中的接口？"></a></h3><blockquote><p><strong>场景案例</strong>：</p><p>现在开始你就是bat当中的员工之一，你的上级太多了，都要吩咐你做事：</p><ul><li>大boss想要员工会帮他给买部手机</li><li>二boss想要员工会销售一套房子</li><li>三boss想要员工会帮忙搭讪小姐姐</li><li>四boss想要员工会跟他一起打游戏</li><li>…………..</li></ul><p>一共有不知道多少个boss，总之你是底层员工嘛。</p><p>那么问题来了，这个员工类究竟得怎么设计呢，真是一个难题，而且老板们想要叫这个员工去做事的时候怎么知道这个员工会呢？</p><p>答案：</p><p>其实很简单，把这些行为统统抽象成接口。</p><p>例如：</p><p>定义下面一些接口：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BuyCellPhone</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buycellphone</span><span class="params">()</span></span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BuyHouse</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHouse</span><span class="params">()</span></span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TrickGirl</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trickGirl</span><span class="params">()</span></span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlayingGamesTogether</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playingGameTogether</span><span class="params">()</span></span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>………………………………………………………(此处还有无数个接口)</p><p>那么这些接口有什么用呢？</p><p>对应的老板只需要认识熟悉的接口就好（意思是只认你是否实现了这个接口），在需要的时候调用方法就好了，而不需要去了解认识每一个人。下面以大老板为例：</p><p>首先必须的有一个实现了这个</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 实现了买手机这个功能接口的员工</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> <span class="keyword">implements</span> <span class="title">BuyCellPhone</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="keyword">private</span> String name;</span><br><span class="line">&gt;     <span class="keyword">private</span> String sex;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">Staff</span><span class="params">(String name, String sex)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.name = name;</span><br><span class="line">&gt;         <span class="keyword">this</span>.sex = sex;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buycellphone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"屁颠屁颠帮老板去买手机"</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>此时身为老板的只需要只需要这样一个方法，就可以找个员工帮他买手机了，并且他可以完全不用了解这个员工谁，到底是干啥的，但是至少这人是实现了这个接口，就说明是有这个能力的</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lookingForSomeoneToBuyAMobilePhone</span><span class="params">(BuyCellPhone buyCellPhone)</span> </span>&#123;</span><br><span class="line">&gt;     buyCellPhone.buycellphone();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><h2 id="抽象类">抽象类<a href="2019/10/12/java面向对象-接口和其他的类#抽象类"></a></h2><p><strong><img src="/2019/10/12/java面向对象-接口和其他的类/164336559DA3C001F7D365CBC0A67998.jpg" alt="164336559DA3C001F7D365CBC0A67998" style="zoom:18%;">我都叫抽象类了，你说我抽象不抽象，我觉得我比上面那玩意儿抽象，你说呢？</strong></p><h3 id="黄坤坤告诉你到底有多抽象？">黄坤坤告诉你到底有多抽象？<a href="2019/10/12/java面向对象-接口和其他的类#黄坤坤告诉你到底有多抽象？"></a></h3><p><strong>抽象？我叫抽象类我就抽象啦？那hljj是jj吗？</strong></p><ul><li><p><strong>听听抽象类的自白</strong></p><p><strong>（抽象类独白）</strong>：</p><p>​        天生就是用来被别人来继承的，简而言之，只有当爸爸的命，从不当儿子。可能有些事，必须得儿子去做，别直接叫我去做事。</p></li><li><p>”<strong>只当爸爸</strong>“</p><p>说明被继承是绝对需要，大部分抽象类都是没有完整实现类功能的类，等待子类继承去实现，所以它是不可以被实例化成对像的。</p></li><li><p>“<strong>有些事必须得儿子去做</strong>”</p><p>说明它可能存在方法是抽象的，必须得子类去具体实现。</p></li><li><p>“<strong>别直接叫我做事</strong>”  </p><p>说明它是不可以直接示例化的。</p></li></ul><h3 id="好了，说完上面牵强的解释，现在我们来看看例子：">好了，说完上面牵强的解释，现在我们来看看例子：<a href="2019/10/12/java面向对象-接口和其他的类#好了，说完上面牵强的解释，现在我们来看看例子："></a></h3><p><img src="/2019/10/12/java面向对象-接口和其他的类/ceeb653ejw1fai8r9ct23j205c05q3yn.jpg" alt="爸爸在呢 有事快说 - 和爸爸斗图 斗图+表情_爸爸_斗图表情" class="article-img"></p><h1 id="好了，开始开飞机了">好了，开始开飞机了<a href="2019/10/12/java面向对象-接口和其他的类#好了，开始开飞机了"></a></h1><h1 id="接口-1">接口<a href="2019/10/12/java面向对象-接口和其他的类#接口-1"></a></h1><h2 id="基本概念">基本概念<a href="2019/10/12/java面向对象-接口和其他的类#基本概念"></a></h2><p> 接口，英文称作<strong>interface</strong>，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对<strong>行为</strong>的抽象。在Java中，定一个接口的形式如下： </p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>需要注意的是:</p><ul><li><p>接口中的变量会被隐式地指定为public static final变量 </p><blockquote><p>用其他关键词修饰会报错，例如：</p><ul><li><code>public static final</code>，<code>private</code></li></ul></blockquote></li><li><p>方法会被隐式地指定为public abstract方法且只能是public abstract方法 </p><blockquote><p>用其他关键词会报错，例如：</p><ul><li><code>private</code>、<code>protected</code>、<code>static</code>、 <code>final</code></li></ul></blockquote><p>接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。 </p><p>可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。 </p></li></ul><h2 id="回调">回调<a href="2019/10/12/java面向对象-接口和其他的类#回调"></a></h2><p>可能初识这个名词觉得高大上和陌生，下面我仔细的讲解一下回调到底是什么呢？</p><p><strong>我在知乎上看到一个高赞回答：</strong></p><blockquote><p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。</p></blockquote><p>这个回答在我学习接口时就看到了，但是当时还是一知半解，下面我们用代码来解释一下。</p><p>首先我们定义一个接口<code>Notify</code>，通知接口</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Notify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>我们定义一个<code>Shop</code>类</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Notify notify;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registrationNoticeMethod</span><span class="params">(Notify notify)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.notify = notify;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tellCustomerOutOfStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对不起，我们这没有货了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrivalNotice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (notify != <span class="keyword">null</span>) &#123;</span><br><span class="line">            notify.call();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>定义一个顾客类<code>Customer</code>，并且让顾客类实现<code>Notify</code>这个接口</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Notify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> phoneNum = <span class="number">1234567</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话给"</span> + phoneNum + <span class="string">"通知到货了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goShopping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出门购物"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>主程序：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 主函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实例化对象</span></span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">        Shop shop = <span class="keyword">new</span> Shop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//顾客出门购物</span></span><br><span class="line">        customer.goShopping();</span><br><span class="line">        pause();</span><br><span class="line">        shop.tellCustomerOutOfStock();</span><br><span class="line">        pause();</span><br><span class="line">        shop.registrationNoticeMethod(customer);</span><br><span class="line">        <span class="comment">//第二天到货了</span></span><br><span class="line">        System.out.println(<span class="string">"第二天"</span>);</span><br><span class="line"></span><br><span class="line">        shop.arrivalNotice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个函数不用在意，只是为了演示效果，增加暂停</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).nextLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>输出：</p><p><img src="/2019/10/12/java面向对象-接口和其他的类/TIM%E6%88%AA%E5%9B%BE20191022120614.png" alt="TIM截图20191022120614" class="article-img"></p><p><a href="2019/10/12/java面向对象-接口和其他的类#这里其中有个注解">代码中的@Override注解说明</a>点击进入</p><h2 id="特殊的接口">特殊的接口<a href="2019/10/12/java面向对象-接口和其他的类#特殊的接口"></a></h2><p>函数式接口</p><p>简单来说，就是只有一个方法的接口。</p><h2 id="接口继承接口以及java8之后的接口多继承问题">接口继承接口以及java8之后的接口多继承问题<a href="2019/10/12/java面向对象-接口和其他的类#接口继承接口以及java8之后的接口多继承问题"></a></h2><p><a href="https://colobu.com/2014/11/04/Java-8-default-method-and-multiple-inheritance/" target="_blank" rel="noopener">详细解释链接</a>可能失效，我这里简述一下。</p><h4 id="java中不是没有多继承吗？">java中不是没有多继承吗？<a href="2019/10/12/java面向对象-接口和其他的类#java中不是没有多继承吗？"></a></h4><p><strong>java8之前</strong></p><p>是的，的确java中没有多继承，但是在java中接口是个例外，接口可以多继承，因为接口没有方法体，所以不论实现哪个父接口的中的方法都是没有关系的。</p><p><strong>java8之后</strong></p><p>java8之后出现了接口的默认实现，就像以下的模式：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>如果有个接口继承前两个接口，就必须把冲突的方法重写</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>如果有个类同时实现这两个接口也需要实现冲突默认方法</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">B</span>, <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="抽象类-1">抽象类<a href="2019/10/12/java面向对象-接口和其他的类#抽象类-1"></a></h1><h2 id="定义">定义<a href="2019/10/12/java面向对象-接口和其他的类#定义"></a></h2><ul><li>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</li><li>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</li><li>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</li><li>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</li><li>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><h2 id="怎么使用">怎么使用<a href="2019/10/12/java面向对象-接口和其他的类#怎么使用"></a></h2><h4 id="抽象类声明">抽象类声明<a href="2019/10/12/java面向对象-接口和其他的类#抽象类声明"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>声明一个java抽象类只需要在正常的类的class之前加上<code>abstract</code></p><h4 id="抽象方法声明">抽象方法声明<a href="2019/10/12/java面向对象-接口和其他的类#抽象方法声明"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="使用时需要注意的：">使用时需要注意的：<a href="2019/10/12/java面向对象-接口和其他的类#使用时需要注意的："></a></h2><ul><li><p>抽象类<strong>不能被实例化</strong>，实例化的工作应该交<strong>由它的子类来完成</strong>，它<strong>只需要有一个引用即可</strong>。</p><blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 生物抽象类（因为没有一个具体的实体可以是生物，所以应该被抽象为更高的抽象类）</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Biological</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">death</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 人类，继承生物，可以没有自己的方法，全部是从抽象类继承的非抽象方法（注意：抽象类中有抽象方法子类必须实现）</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Biological</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>最重要的主程序来了，仔细看注释介绍</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 主程序，以下只是演示，注释最重要</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;         Biological biological = <span class="keyword">new</span> Person();<span class="comment">//初始化时将人类的对象赋值给生物的引用时可以的</span></span><br><span class="line">&gt;         Person person = <span class="keyword">new</span> Person();<span class="comment">//生成一个人类的对象</span></span><br><span class="line">&gt;         biological = person;<span class="comment">//将人类的对象复制给生物的引用也是没问题</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote></li><li><p><strong>抽象方法</strong>必须<strong>由子类来进行重写</strong>。</p><blockquote><p><strong>抽象类</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 生物类</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Biological</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getEnergy</span><span class="params">()</span></span>;<span class="comment">//增加了获取能量这个抽象方法</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">death</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>人类</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 人类，继承生物，继承了两个非抽象方法，并实现了抽象方法</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Biological</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEnergy</span><span class="params">()</span> </span>&#123;<span class="comment">//实现的抽象抽象方法</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote></li><li><p>只要<strong>包含一个抽象方法的抽象类</strong>，该方法<strong>必须要定义成抽象类</strong>，不管是否还包含有其他方法。</p></li><li><p>抽象类中<strong>可以包含具体的方法</strong>，当然<strong>也可以不包含抽象方法</strong>。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有抽象方法的抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有抽象方法的抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p>子类中的抽象方法<strong>不能</strong>与父类的抽象方法<strong>同名</strong>。</p></li><li><p><code>abstract</code>不能与<code>final</code>并列修饰同一个类。</p><blockquote><p>这个显而易见，既然是抽象的，就必须需要时需要被子类实现的，所以不可能时final</p></blockquote></li><li><p><code>abstract</code> 不能与<code>private</code>、<code>static</code>、<code>final</code>或并列修饰同一个方法。</p><blockquote><p><code>private</code>:抽象方法，必须是需要被继承的实现的，所以不可以用私有修饰符修饰</p><p><code>static</code>：同样，抽象方法是需要被实现的，但是静态方法是不可以被重写</p><p>final：同上</p></blockquote></li></ul><h1 id="抽象类和接口的区别">抽象类和接口的区别<a href="2019/10/12/java面向对象-接口和其他的类#抽象类和接口的区别"></a></h1><h2 id="语法层面上的区别">语法层面上的区别<a href="2019/10/12/java面向对象-接口和其他的类#语法层面上的区别"></a></h2><ul><li><strong>抽象类</strong>可以提供<strong>成员方法的实现细节</strong>，而<strong>接口</strong>中只能存在<strong>public abstract 方法（在java8的之后接口）</strong>；</li><li><strong>抽象类</strong>中的成员变量可以是<strong>各种类型</strong>的，而<strong>接口</strong>中的成员变量只能是<strong>public static final类型</strong>的；</li><li><strong>接口</strong>中<strong>不能含有静态代码块</strong>以及<strong>静态方法</strong>，而<strong>抽象类</strong>可以有<strong>静态代码块</strong>和<strong>静态方法</strong>；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><h2 id="设计层面上的区别">设计层面上的区别<a href="2019/10/12/java面向对象-接口和其他的类#设计层面上的区别"></a></h2><ul><li><p>抽象类是对一种<strong>事物的抽象</strong>，即<strong>对类抽象</strong>，而接口是<strong>对行为的抽象</strong>。</p></li><li><p>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</p></li><li><p>举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，<strong>继承</strong>是一个 “<strong>是不是</strong>“的关系，而 <strong>接口</strong> 实现则是 “<strong>有没有</strong>“的关系。</p></li><li><p>如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而<strong>接口实现则是有没有</strong>、<strong>具备不具备的关系</strong>，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p></li><li><p>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？ ？</p><blockquote><p> 最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p></blockquote></li></ul><h2 id="实际的例子">实际的例子<a href="2019/10/12/java面向对象-接口和其他的类#实际的例子"></a></h2><p>下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 门的抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DoorAbstract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>　　或者：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 门的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DoorInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>但是现在如果我们需要门具有<strong>报警alarm( )</strong>的功能，那么该如何实现？下面提供两种思路：</p><ul><li>将这三个功能都放在抽象类里面，但是这样一来<strong>所有继承于这个抽象类的子类都具备了报警功能</strong>，但是有的门并不一定具备报警功能；</li><li>将这三个功能都放在接口里面，需要用到<strong>报警功能的类就需要实现这个接口中的open( )和close( )</strong>，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</li></ul><p>很明显这个属性放到以上任何一个的当中都是不合适的，但是报警又是一个比较广泛的属性，java不支持多继承，所以最好将这个方法抽象到一个接口里面，这就是所谓的对行为抽象：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 报警的接口，所有实现了这个接口的类都是有报警这个功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>然后在对这个可以报警的门进行封装：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以报警的门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">DoorAbstract</span> <span class="keyword">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="这里其中有个注解">这里其中有个注解<a href="2019/10/12/java面向对象-接口和其他的类#这里其中有个注解"></a></h4><p>@Override我简单说明一下（至于注解是啥，不详细的讲解了下节课会讲到）：</p><p><code>@Override</code>是伪代码,表示重写可以不写，不过写上有如下好处: </p><ul><li>可以当注释用,方便阅读，可以很明显的看到哪些方法是重写的方法；</li><li>编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了，这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)。</li></ul><p>对于这里而言第二个作用是没有作用的，因为如果继承了抽象类，如果抽象类中含有抽象方法，必须实现这个方法不然编译器也会报错，接口也是同样的，前面说到接口中的方法默认是<code>public abstract</code>。</p><h1 id="内部类">内部类<a href="2019/10/12/java面向对象-接口和其他的类#内部类"></a></h1><p> 顾名思义：可以将一个类的定义放在另一个类的定义内部，这就是内部类。 <img src="/2019/10/12/java面向对象-接口和其他的类/v2-2b4d1f67bd8f8aaecb32920c58cd687c_hd.jpg" alt="img" style="zoom:50%;"></p><h2 id="怎么用？">怎么用？<a href="2019/10/12/java面向对象-接口和其他的类#怎么用？"></a></h2><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类中定义类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>好了，你现在已经会了内部类了，你看多简单呐     <img src="/2019/10/12/java面向对象-接口和其他的类/v2-8da4b48b8262d2786486cb942571be4c_hd.jpg" alt="img" style="zoom:50%;"></p><p>好了开玩笑的啦。<img src="/2019/10/12/java面向对象-接口和其他的类/v2-db4581e2b067caef5a9586f7eebdf201_hd.jpg" alt="img" style="zoom:50%;"></p><h2 id="内部类小飞机">内部类小飞机<a href="2019/10/12/java面向对象-接口和其他的类#内部类小飞机"></a></h2><h2 id="为什么要使用内部类？">为什么要使用内部类？<a href="2019/10/12/java面向对象-接口和其他的类#为什么要使用内部类？"></a></h2><p>​        在《Think in java》也就是《java编程思想》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 </p><p>​        在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p><p><img src="/2019/10/12/java面向对象-接口和其他的类/v2-acb2c980db4a235ed0538f34d9c2918d_hd-1571748707404.jpg" alt="img" style="zoom: 33%;">  完了上面这么简单的描述还听不懂 ，听不懂没关系，这样说我也不懂，来慢慢分析。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>接下来骚操作来了：</p><p>你可以这样子</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">implements</span> <span class="title">Father</span>, <span class="title">Mother</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>也可以这样子</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daughter</span> <span class="keyword">implements</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> <span class="keyword">implements</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>但是，不是一个类可以实现多个接口嘛，第二种实现还有什么意义呢。</p><p>那么问题来了，如果爸爸妈妈他们不是接口而是一个抽象类或者类呢？现在应该理解更为深刻了。</p><h2 id="内部类基础">内部类基础<a href="2019/10/12/java面向对象-接口和其他的类#内部类基础"></a></h2><p><code>.this</code>和<code>.new</code>语法</p><p> 当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。 </p><p><strong>内部类如何访问外围类的东西呢？</strong></p><blockquote><p>当然直接用变量名就可以访问啦</p><p>原因？（凡事要解释得通才行嘛）</p><blockquote><p>其实在内部类对象中保存了一个对外部类对象的引用，当在内部类的成员方法中访问某一变量时，如果在该方法和内部类中都没有定义过这个变量，（如果有这个变量的话，或者外部类的某个成员变量与内部类的成员变量相同eg:在内部类中定义 <strong>private String name;</strong> 那么访问的则是内部类的这个变量）调用就会被传递给内部类中的那个对外部类对象的引用，通过这个引用去调用这个变量。在内部类调用外部类的方法也是同样的一个道理（还是这个内部类对象保存了一个对外部类的引用）。 </p></blockquote></blockquote><p><strong>内部类如何获取外围类的对象呢？（.this）</strong></p><blockquote><p>这样子：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 内部类示例</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&gt;     String s = <span class="string">""</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&gt;         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lala</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;             A a = A.<span class="keyword">this</span>;  <span class="comment">//关键的地方</span></span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><p><strong>如何创建内部类的对象呢？</strong></p><blockquote><p><strong>在外围类内</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 内部类示例</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&gt;     String s = <span class="string">""</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lala</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         B b = <span class="keyword">new</span> B();  <span class="comment">//关键的地方</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p><strong>在外围类外（也就是在其他地方）：</strong>（.new）</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; A a = <span class="keyword">new</span> A();</span><br><span class="line">&gt; A.B b = a.new B();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><p> 到这里了我们需要明确一点，<strong>内部类是个编译时的概念</strong>，一旦编译成功后，它就与外围类<strong>属于两个完全不同的类</strong>（当然他们之间还是有联系的）。对于一个名为A的外围类和一个名为B的内部类，在编译成功后，会出现这样两个class文件：<strong>OuterClass.class和OuterClass$InnerClass.class。</strong> </p><p>关于java编译运行有兴趣了解<a href="http://jontree.github.io/2019/10/23/java%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3" target="_blank" rel="noopener">自己了解</a>（之前不是很多同学用命令行javac  和 java命令嘛）</p><h2 id="内部类的分类">内部类的分类<a href="2019/10/12/java面向对象-接口和其他的类#内部类的分类"></a></h2><h3 id="成员内部类">成员内部类<a href="2019/10/12/java面向对象-接口和其他的类#成员内部类"></a></h3><ul><li>成员内部类中不能存在任何static的变量和方法；</li><li>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。 </li></ul><p>例子：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类中定义类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>对就是这种最简单的内部类</p><h3 id="局部内部类">局部内部类<a href="2019/10/12/java面向对象-接口和其他的类#局部内部类"></a></h3><ul><li><p>嵌套在方法或者作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题</p><blockquote><p>嵌套在方法中很简单，直接在方法里面写类嘛，到那时嵌套在作用域里面怎么回事，这说明直接随便在一个类中随便找个位置，写个大括号，大括号中中也是可以写局部内部类的</p><p>例如：（这个简单例子可能有点绕）</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; * 含有局部内部类的类B</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">&gt;    &#123;<span class="comment">//这是一个静态代码块</span></span><br><span class="line">&gt;        <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;<span class="comment">//这是一个局部内部类，作用域就在静态代码块中</span></span><br><span class="line">&gt;            </span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote></blockquote></li><li><p>通常是想创建一个类来辅助我们的解决方案，但那时又不希望这个类是公共可用的，所以就产生了局部内部类</p></li><li><p>局部内部类和成员内部类一样被编译，只是它的作用域发生了改变</p></li><li><p>它只能在该方法和属性中被使用，出了该方法和属性就会失效 </p><p>首先为了方便，我门先定义一个接口：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 口接口A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>下面开始正式的例子：</p><p>可以返回局部内部类实例化对象的函数（下面有个类B，里面有个方法返回A的引用，并且函数体里面有个实现了接口A的局部内部类C）</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 含有局部内部类的类B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">lala</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>你可以直接这样子定义然后在方法中使用（作用域在方法内）</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 含有局部内部类的类B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lala</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul><h3 id="匿名内部类">匿名内部类<a href="2019/10/12/java面向对象-接口和其他的类#匿名内部类"></a></h3><h4 id="咋写？">咋写？<a href="2019/10/12/java面向对象-接口和其他的类#咋写？"></a></h4><p>首先定义一个接口，一个抽象类，和一个简单的类</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我是一个冷漠无情的简单接口A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我是一个冷漠无情的简单抽象类B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我是一个冷漠无情的超简单普通类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>好了，有了上面的基础，我们就来演示一下匿名内部类：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A() &#123;<span class="comment">//继承接口A的匿名内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> B() &#123;<span class="comment">//继承抽象类B的内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> C() &#123;<span class="comment">//继承普通类C的匿名内部类</span></span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="内部类的注意事项">内部类的注意事项<a href="2019/10/12/java面向对象-接口和其他的类#内部类的注意事项"></a></h4><ul><li><p>匿名内部类是没有访问修饰符的。</p></li><li><p>new 匿名内部类，这个类首先是要存在的。如果我们将接口注释掉，就会出现编译出错。</p><blockquote><p>例子同上第二个，如果不用B这个现有的接口的话例如这样子写，是会报错的：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">new</span> () &#123;</span><br><span class="line">&gt;             <span class="meta">@Override</span></span><br><span class="line">&gt;             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;<span class="comment">//超级错误的写法，谁这样写谁要被打手板</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote></blockquote></li><li><p>java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final</p><blockquote><p><img src="/2019/10/12/java面向对象-接口和其他的类/v2-32db3eeb7c9cb282553504e2c1108130_hd.jpg" alt="img" style="zoom:50%;">你是啥意思呀，完全不懂你说的啥啊，这又是啥狗屁啊，小丁学长你在开啥飞机。</p><p>emmmmmmm，好的，那我们来举例子    <img src="/2019/10/12/java面向对象-接口和其他的类/ceeb653ejw1faoq48816nj208z0buaan.jpg" alt="举个栗子 - 后退，我要开始装逼了_表情头牌_蘑菇头_搞笑对话表情" style="zoom:10%;"></p><p>首先我们定义一个接口，做准备。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 我是一个冷漠无情的简单接口A</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>然后我门再写一个普通类B，后面修改B来挨个测试</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 我是一个冷漠无情的简单类B</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt; <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">&gt;   <span class="keyword">new</span> A() &#123;</span><br><span class="line">&gt;       <span class="meta">@Override</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt;   </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p><strong>首先我们测试在方法里面的内部类，这个也是我们最常用的。我们在内部类实现的方法里面直接输出b看并且不把变量b设置为final</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 冷漠无情的简单类B我又来了</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt; <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">&gt;   <span class="keyword">new</span> A() &#123;</span><br><span class="line">&gt;       <span class="meta">@Override</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;           System.out.println(b);<span class="comment">//编译是能通过的，不会报错的</span></span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p><img src="/2019/10/12/java面向对象-接口和其他的类/v2-72c27a074e1feb699849c4d9d8c2614c_hd.jpg" alt="img" style="zoom:50%;"> 是不是讲错了，咋不需要变量b咋不需要final就能通过，翻车了。</p><p>百度谷歌一番，我找到这样一句话。</p><p><img src="/2019/10/12/java面向对象-接口和其他的类/TIM%E6%88%AA%E5%9B%BE20191024013553.png" alt="TIM截图20191024013553" class="article-img"></p><p>emmm，那究竟是不是这样子呢？再来康康？我们这次在上面那个内部类直接修改变量b的值。看可不可以呢。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 我是一个冷漠无情的简单类B</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt; <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">&gt;   <span class="keyword">new</span> A() &#123;</span><br><span class="line">&gt;       <span class="meta">@Override</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;           b = <span class="number">99</span>;<span class="comment">//关键部位（也是报错部位）</span></span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>编译之后，果然报错了，错误如下：</p><p><img src="/2019/10/12/java面向对象-接口和其他的类/TIM%E6%88%AA%E5%9B%BE20191024014025.png" alt="TIM截图20191024014025" class="article-img"></p><p>安心了，我们继续开飞机：</p><p>下面这两个用法，我估计你今后写10万行代码都遇不上一次这样写的，但是为了验证以上话是正确的，我们得试试。</p><p><strong>第二项测试，在匿名内部类中类的静态代码块使用外部作用域里面的变量（因为是java有自动final修饰我们下面几次测试都使用直接更改外部作用域变量来测试【即：直接更改变量b的值】）</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 我是一个冷漠无情的简单类B,我又出现了</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt; <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">&gt;   <span class="keyword">new</span> A() &#123;</span><br><span class="line">&gt;       &#123;</span><br><span class="line">&gt;           b = <span class="number">99</span>;<span class="comment">//关键部分</span></span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;       <span class="meta">@Override</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;           </span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>好的我来编译一下</p><p><img src="/2019/10/12/java面向对象-接口和其他的类/TIM%E6%88%AA%E5%9B%BE20191024014025.png" alt="TIM截图20191024014025" class="article-img"></p><p>好的继续报错，而且还是这个错，nice说明，那句话更加正确了，<code>java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final</code></p><p><strong>那么接下来我们来测试最后一项测试，我们在匿名内部类中访问外围类中的属性，看能不能修改</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 我是一个冷漠无情的简单类B,我又出现了</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt; <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">&gt;   <span class="keyword">new</span> A() &#123;</span><br><span class="line">&gt;       <span class="meta">@Override</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;           a = <span class="number">99</span>;<span class="comment">//关键部分（没报错）</span></span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>编译一下，没错？运行一下，没有报错？woc，emmmmmm，<img src="/2019/10/12/java面向对象-接口和其他的类/v2-72c27a074e1feb699849c4d9d8c2614c_hd.jpg" alt="img" style="zoom:50%;"></p><p>找找原因，于是我们在再在B类中添加一个普通内部类，如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 我是一个的简单类B,这次我可不简单了</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt; <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">&gt;   <span class="keyword">new</span> A() &#123;<span class="comment">//匿名内部类</span></span><br><span class="line">&gt;       <span class="meta">@Override</span></span><br><span class="line">&gt;       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;           a = <span class="number">99</span>;</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;<span class="comment">//简单内部类C</span></span><br><span class="line">&gt;   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>前面我们说了，<br>找找原因，为啥没有报错，前面我们说内部类基础得时候，我们说是内部类是持有外围类得引用的，所以会智能的可以直接使用外围类的成员属性。</p><p>我们编译B类，然后出现了如下文件：</p><p><img src="/2019/10/12/java面向对象-接口和其他的类/TIM%E6%88%AA%E5%9B%BE20191024021220.png" alt="TIM截图20191024021220" class="article-img"></p><p>咦，难道匿名内部类也会储存外围类的引用🐎，是不是我们具体来康康。</p><p>我们先来看看B类编译之后反编译的代码</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">int</span> b = <span class="keyword">false</span>;</span><br><span class="line">&gt;   A var10001 = <span class="keyword">new</span> A() &#123;</span><br><span class="line">&gt;       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;           B.<span class="keyword">this</span>.a = <span class="number">99</span>;</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">&gt;   C() &#123;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>没有太大的区别，唯一的区别就是变量b，原本的0的值变成了布尔类型，这是为啥呢？</p><p>还问为啥？是要我开火箭嘛，这篇课件不是因为“为啥”会有13000+的字嘛？？你仔细想想，写个程序要那么多为什么吗？？您好要的。最简单的来说这是编译器的一个优化，你这个值没有使用，为啥要给你要存一个整形，整形相对于布尔类型还是蛮大的，自己康康，整整四倍呢。。。。。。</p><table><thead><tr><th>类型</th><th>存储需求</th><th>bit 数</th><th>取值范围</th><th>备注</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td>4*8</td><td>-2147483648~2147483647</td><td>即 (-2)的31次方 ~ (2的31次方) - 1</td></tr><tr><td>short</td><td>2字节</td><td>2*8</td><td>-32768~32767</td><td>即 (-2)的15次方 ~ (2的15次方) - 1</td></tr><tr><td>long</td><td>8字节</td><td>8*8</td><td></td><td>即 (-2)的63次方 ~ (2的63次方) - 1</td></tr><tr><td>byte</td><td>1字节</td><td>1*8</td><td>-128~127</td><td>即 (-2)的7次方 ~ (2的7次方) - 1</td></tr><tr><td>float</td><td>4字节</td><td>4*8</td><td></td><td>float 类型的数值有一个后缀 F（例如：3.14F）</td></tr><tr><td>double</td><td>8字节</td><td>8*8</td><td></td><td>没有后缀 F 的浮点数值（例如：3.14）默认为 double</td></tr><tr><td>boolean</td><td>1字节</td><td>1*8</td><td>true、false</td><td></td></tr><tr><td>char</td><td>2字节</td><td>2*8</td><td></td><td>Java中，只要是字符，不管是数字还是英文还是汉字，都占两个字节。</td></tr></tbody></table><p><strong>再来看看B$C.class，验证是否持有外围类的引用</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">B</span>$<span class="title">C</span> </span>&#123;</span><br><span class="line">&gt; B$C(B <span class="keyword">this</span>$<span class="number">0</span>) &#123;</span><br><span class="line">&gt;   <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>嗯，作为内部类，持有外围类的应用，<strong>正解</strong>。这里只能看到外围类的引用传进来了，那系统是怎么使用的呢？<img src="/2019/10/12/java面向对象-接口和其他的类/006APoFYjw1fbw78x1kr4g308c08caa2-1571887367591.gif" alt="兔子摔地上 - 吐血表情包_动图_吐血表情" style="zoom:15%;">  保存和使用是jvm级别的事，这里就详细讲了，我还没怎么看呢。</p><p><strong>好的关键部分了，我们再来看看B$1.class反编译的结果</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">B</span>$1 <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&gt;  B$<span class="number">1</span>(B <span class="keyword">this</span>$<span class="number">0</span>) &#123;</span><br><span class="line">&gt;      <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;      <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>.a = <span class="number">99</span>;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p><img src="/2019/10/12/java面向对象-接口和其他的类/9150e4e5gy1g6o895cawsj20sg0sg76j.jpg" alt="原来是这么回事！这下谜解开了（哆啦A梦表情包）_这么回事_这下_解开_原来表情" style="zoom:18%;">  看到没有，匿名内部类也是会保存外围类的引用的</p><p>好了这下说明我上面那句话是对的，nice，那么问题又来了。</p><p><strong>为什么一定要是final<img src="/2019/10/12/java面向对象-接口和其他的类/v2-114ee3caaad0d612d39818c9f3f81201_hd.jpg" alt="img" style="zoom:50%;">？？？</strong><img src="/2019/10/12/java面向对象-接口和其他的类/006APoFYjw1fbw78x1kr4g308c08caa2-1571887367591.gif" alt="兔子摔地上 - 吐血表情包_动图_吐血表情" style="zoom:15%;"><strong>你们吐血没？？反正我吐了</strong></p><p>好的，我们来讲</p><p>那么又来了一个名词，“<strong>闭包</strong>”</p><p>闭包是什么呢？来听听大牛的说的他认为最通俗易懂的答案：</p><ol><li>一个依赖于外部环境自由变量的函数</li><li>这个函数能够访问外部环境里的自由变量</li></ol><p>哦豁，<img src="/2019/10/12/java面向对象-接口和其他的类/v2-746b68b4c2149a0faef9f4ec9a4e8e92_hd.jpg" alt="img" style="zoom:50%;"> 还是不明白，好的，那么你继续听我慢慢分析</p><p>首先我们定义一个接口，做准备准备工作。</p><p><code>不准备了，不准备了，自己百度看教程吧，再准备这课件起码到20000字了。</code></p><p>这里附两个<a href="https://blog.csdn.net/jiao_zg/article/details/78911469" target="_blank" rel="noopener">java中的final讲解</a>   <a href="https://www.zhihu.com/question/24084277/answer/110176733" target="_blank" rel="noopener">闭包讲解</a>其实分为java8之前之后</p></blockquote></li><li><p>匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。</p><blockquote><p>咦，上面不是反编译之后有构造方法吗？</p><p>不对不对，我这说的是使用内部类的时候，不能有构造方法，你都直接，反编译时出现的构造方法是系统在你生成匿名内部类对象时默认调用的构造方法，因为再怎么它也是个类嘛，还是有类的尊严的。</p><p>【内部类自白】：怎么人家成为你对象也是条件的嘛<img src="/2019/10/12/java面向对象-接口和其他的类/6af89bc8gw1f8tzg6lig0g209m073x6p.gif" alt="二次元妹子害羞了（亲亲）_二次元_亲亲_害羞表情" style="zoom: 25%;">，没有构造方法怎么行</p></blockquote></li></ul><h3 id="静态内部类">静态内部类<a href="2019/10/12/java面向对象-接口和其他的类#静态内部类"></a></h3><ul><li><p>非静态内部类在编译完成之后会隐含地保存着一个引用 </p></li><li><p>它的创建是不需要依赖于外围类的</p></li><li><p>它不能使用任何外围类的非static成员变量和方法。 </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 课件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh用法及命令</title>
      <link href="/2019/10/07/ssh%E7%94%A8%E6%B3%95%E5%8F%8A%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/10/07/ssh%E7%94%A8%E6%B3%95%E5%8F%8A%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/pipisorry/article/details/52269785" target="_blank" rel="noopener">原文链接</a></p><h1 id="什么是SSH？">什么是SSH？<a href="2019/10/07/ssh用法及命令#什么是SSH？"></a></h1><p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。<br>SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。这里只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。</p><h2 id="中间人攻击">中间人攻击<a href="2019/10/07/ssh用法及命令#中间人攻击"></a></h2><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。<br>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。<br>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。<br>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。</p><h1 id="ssh的安装">ssh的安装<a href="2019/10/07/ssh用法及命令#ssh的安装"></a></h1><p>SSH分客户端openssh-client和openssh-server</p><p>如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudoapt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server。</p><p>Ubuntu缺省已经安装了ssh client。</p><h2 id="配置ssh">#配置ssh#<a href="2019/10/07/ssh用法及命令#配置ssh"></a></h2><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">echo -e "\033[31;1m ******************************* \033[0m"</span><br><span class="line">echo -e "\033[31;1m ************安装和配置ssh************ \033[0m"</span><br><span class="line">sudo apt-get install -y openssh-server 1&gt; /dev/null</span><br><span class="line">sudo sed -i 's/UsePAM no/UsePAM yes/g' /etc/ssh/sshd_config</span><br><span class="line">sudo sed -i '8a /etc/init.d/ssh start' /etc/profile</span><br><span class="line">sudo /etc/init.d/ssh start</span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line">echo -e "\033[31;1m ssh授权 \033[0m"</span><br><span class="line">cd ~/.ssh/</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">cat ./id_rsa.pub &gt;&gt; ./authorized_keys</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -e|grep ssh</span></span><br><span class="line"> 2151 ?        00:00:00 ssh-agent</span><br><span class="line"></span><br><span class="line"> 5313 ?        00:00:00 sshd</span><br><span class="line"></span><br><span class="line">ssh-agent表示ssh-client启动，sshd表示ssh-server启动了。</span><br><span class="line"></span><br><span class="line">如果缺少sshd，说明ssh服务没有启动或者没有安装。</span><br></pre></td></tr></table></div></figure><h1 id="SSH基本用法">SSH基本用法<a href="2019/10/07/ssh用法及命令#SSH基本用法"></a></h1><h2 id="SSH远程登录">SSH远程登录<a href="2019/10/07/ssh用法及命令#SSH远程登录"></a></h2><h3 id="口令登录">口令登录<a href="2019/10/07/ssh用法及命令#口令登录"></a></h3><p>假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host  如：ssh pika@192.168.0.111</span></span><br></pre></td></tr></table></div></figure><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh host</span></span><br></pre></td></tr></table></div></figure><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -p 2222 user@host</span></span><br></pre></td></tr></table></div></figure><p>上面这条命令表示，ssh直接连接远程主机的2222端口。<br>如果你是第一次登录对方主机，系统会出现下面的提示：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host</span></span><br><span class="line"></span><br><span class="line">The authenticity of host 'host (12.18.429.21)' can't be established.</span><br><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></div></figure><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？<br>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。<br>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。<br>    　　<code>Are you sure you want to continue connecting (yes/no)? yes</code><br>系统会出现一句提示，表示host主机已经得到认可。<br>    　　<code>Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.</code><br>然后，会要求输入密码。<br>    　　<code>Password: (enter password)</code><br>如果密码正确，就可以登录了。<br>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh host</span></span><br></pre></td></tr></table></div></figure><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -p 2222 user@host</span></span><br></pre></td></tr></table></div></figure><p>上面这条命令表示，ssh直接连接远程主机的2222端口。<br>如果你是第一次登录对方主机，系统会出现下面的提示：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host 'host (12.18.429.21)' can't be established.</span><br><span class="line">    　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">    　　Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></div></figure><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？<br>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。<br>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。<br>​    　　<code>Are you sure you want to continue connecting (yes/no)? yes</code><br>系统会出现一句提示，表示host主机已经得到认可。<br>​    　　<code>Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.</code><br>然后，会要求输入密码。<br>​    　　<code>Password: (enter password)</code><br>如果密码正确，就可以登录了。<br>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p><h3 id="公钥登录">公钥登录<a href="2019/10/07/ssh用法及命令#公钥登录"></a></h3><p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。<br>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen</span></span><br></pre></td></tr></table></div></figure><p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。<br>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。<br>这时再输入下面的命令，将公钥传送到远程主机host上面：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-copy-id user@host</span></span><br></pre></td></tr></table></div></figure><p>好了，从此你再登录，就不需要输入密码了。<br>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></div></figure><p>然后，重启远程主机的ssh服务。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu系统</span></span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debian系统</span></span><br><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></div></figure><p>authorized_keys文件<br>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。<br>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host <span class="string">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></div></figure><p>这条命令由多个语句组成，依次分解开来看：</p><ol><li>“$ ssh user@host”，表示登录远程主机；</li><li>单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：</li><li>“$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；</li><li>‘cat &gt;&gt; .ssh/authorized_keys’ &lt; <del>/.ssh/id_rsa.pub的作用是，将本地的公钥文件</del>/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。</li></ol><p>然后，重启远程主机的ssh服务。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ubuntu系统</span></span><br><span class="line">service ssh restart</span><br><span class="line"><span class="meta">#</span><span class="bash"> debian系统</span></span><br><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></div></figure><p>authorized_keys文件<br>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。<br>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host <span class="string">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></div></figure><p>这条命令由多个语句组成，依次分解开来看：（1）”$ ssh user@host”，表示登录远程主机；（2）单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：（3）”$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；（4）’cat &gt;&gt; .ssh/authorized_keys’ &lt; <del>/.ssh/id_rsa.pub的作用是，将本地的公钥文件</del>/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。</p><p>[SSH原理与运用（一）：远程登录]</p><p>使用ssh在远程后台不中断地跑程序<br>Linux关闭ssh（关闭终端等）后运行的程序或者服务自动停止，如python3 a.py &amp;。</p><p>解决：使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup python3 a.py &amp;</span><br></pre></td></tr></table></div></figure><p>[linux进程管理与SELinux]</p><h2 id="ssh连接中断">ssh连接中断<a href="2019/10/07/ssh用法及命令#ssh连接中断"></a></h2><p>如果使用的是iTerm2，要让ssh不断线： profiles -&gt; sessions -&gt; When idel, send ASCII code</p><p>其它命令行客户端，通过配置 ServerAliveInterval 来实现，在 ~/.ssh/config 中加入： ServerAliveInterval=30。表示ssh客户端每隔30秒给远程主机发送一个no-op包，no-op是无任何操作的意思，这样远程主机就不会关闭这个SSH会话。</p><p>vim ~/.ssh/config，然后新增</p><p>Host *<br>    ServerAliveInterval 60<br>60秒就好了，而且基本去连的机器都保持，所以配置了*，如果有需要针对某个机器，可以自行配置为需要的serverHostName。</p><p>[ssh保持连接不断开]</p><h2 id="SSH远程操作">SSH远程操作<a href="2019/10/07/ssh用法及命令#SSH远程操作"></a></h2><h3 id="SSH数据传输">SSH数据传输<a href="2019/10/07/ssh用法及命令#SSH数据传输"></a></h3><p>SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。<br>    　　$ ssh user@host ‘mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub<br>单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。<br>这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。<br>下面看几个例子。<br>【例1】<br>将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。<br>    　　$ cd &amp;&amp; tar czv src | ssh user@host ‘tar xz’<br>【例2】<br>将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。<br>    　　$ ssh user@host ‘tar cz src’ | tar xzv<br>【例3】<br>查看远程主机是否运行进程httpd。<br>    　　$ ssh user@host ‘ps ax | grep [h]ttpd’</p><p>lz建议使用scp进行远程copy：</p><p>scp 跨机远程拷贝<br>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限。</p><h3 id="scp命令参数">scp命令参数<a href="2019/10/07/ssh用法及命令#scp命令参数"></a></h3><ul><li>-1 强制scp命令使用协议ssh1</li><li>-2 强制scp命令使用协议ssh2</li><li>-4 强制scp命令只使用IPv4寻址</li><li>-6 强制scp命令只使用IPv6寻址</li><li>-B 使用批处理模式（传输过程中不询问传输口令或短语）</li><li>-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li><li>-p 留原文件的修改时间，访问时间和访问权限。</li><li>-q 不显示传输进度条。</li><li>-r 递归复制整个目录。</li><li>-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li><li>-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li><li>-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li><li>-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li><li>-l limit 限定用户所能使用的带宽，以Kbit/s为单位。</li><li>-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，</li><li>-P port 注意是大写的P, port是指定数据传输用到的端口号</li><li>-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li><li>scp一般有六种使用方法<ul><li>本地复制远程文件：（把远程的文件复制到本地）</li><li>scp <a href="mailto:root@www.test.com" target="_blank" rel="noopener">root@www.test.com</a>:/val/test/test.tar.gz /val/test/test.tar.gz<br>远程复制本地文件：（把本地的文件复制到远程主机上）</li><li>scp /val/test.tar.gz <a href="mailto:root@www.test.com" target="_blank" rel="noopener">root@www.test.com</a>:/val/test.tar.gz<br>本地复制远程目录：（把远程的目录复制到本地）</li><li>scp -r <a href="mailto:root@www.test.com" target="_blank" rel="noopener">root@www.test.com</a>:/val/test/ /val/test/<br>远程复制本地目录：（把本地的目录复制到远程主机上）</li><li>scp -r ./ubuntu_env/ <a href="mailto:root@192.168.0.111" target="_blank" rel="noopener">root@192.168.0.111</a>:/home/pipi</li><li>pika:/media/pika/files/machine_learning/datasets$scp -r SocialNetworks/ </li><li><a href="mailto:piting@192.168.0.172" target="_blank" rel="noopener">piting@192.168.0.172</a>:/media/data/pipi/datasets</li></ul></li><li>本地复制远程文件到指定目录：（把远程的文件复制到本地）</li><li>scp <a href="mailto:root@www.test.com" target="_blank" rel="noopener">root@www.test.com</a>:/val/test/test.tar.gz /val/test/<br>远程复制本地文件到指定目录：（把本地的文件复制到远程主机上）</li><li>scp /val/test.tar.gz <a href="mailto:root@www.test.com" target="_blank" rel="noopener">root@www.test.com</a>:/val/</li></ul><p>ps: scp复制文件时只指定服务器地址不加路径默认复制到哪里???</p><p>[12个scp传输文件的命令栗子]</p><p>[scp 跨机远程拷贝]</p><h2 id="SSH端口操作">SSH端口操作<a href="2019/10/07/ssh用法及命令#SSH端口操作"></a></h2><h3 id="绑定本地端口">绑定本地端口<a href="2019/10/07/ssh用法及命令#绑定本地端口"></a></h3><p>既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。<br>假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：<br>    　　$ ssh -D 8080 user@host<br>SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。</p><h3 id="本地端口转发">本地端口转发<a href="2019/10/07/ssh用法及命令#本地端口转发"></a></h3><p>有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）。<br>假定host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。<br>我们在host1执行下面的命令：<br>    　　$ ssh -L 2121:host2:21 host3<br>命令中的L参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。<br>这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。<br>    　　$ ftp localhost:2121<br>“本地端口转发”使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH隧道”。<br>下面是一个比较有趣的例子。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -L 5900:localhost:5900 host3</span></span><br></pre></td></tr></table></div></figure><p>它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。<br>另一个例子是通过host3的端口转发，ssh登录host2。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -L 9001:host2:22 host3</span></span><br></pre></td></tr></table></div></figure><p>这时，只要ssh登录本机的9001端口，就相当于登录host2了。 　　</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -p 9001 localhost</span></span><br></pre></td></tr></table></div></figure><p>上面的-p参数表示指定登录端口。</p><p>出错处理：ssh: Could not resolve hostname 192.168.<em>.</em>:***: Name or service not known</p><p>解决：指定端口不能直接使用ip:端口号，使用-p参数来解决就可以了。</p><h3 id="远程端口转发">远程端口转发<a href="2019/10/07/ssh用法及命令#远程端口转发"></a></h3><p>既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。<br>还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，”本地端口转发”就不能用了，怎么办？<br>解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。<br>我们在host3执行下面的命令：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -R 2121:host2:21 host1</span></span><br></pre></td></tr></table></div></figure><p>R参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。<br>绑定之后，我们在host1就可以连接host2了：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ftp localhost:2121</span></span><br></pre></td></tr></table></div></figure><p>这里必须指出，”远程端口转发”的前提条件是，host1和host3两台主机都有sshD和ssh客户端。</p><h1 id="SSH的其他参数">SSH的其他参数<a href="2019/10/07/ssh用法及命令#SSH的其他参数"></a></h1><p>SSH还有一些别的参数，也值得介绍。<br>N参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -NT -D 8080 host</span></span><br></pre></td></tr></table></div></figure><p>f参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -f -D 8080 host</span></span><br></pre></td></tr></table></div></figure><p>要关闭这个后台连接，就只有用kill命令去杀掉进程。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git push 解决 弹出用户名和密码输入框</title>
      <link href="/2019/10/04/git-push-%E8%A7%A3%E5%86%B3-%E5%BC%B9%E5%87%BA%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86/"/>
      <url>/2019/10/04/git-push-%E8%A7%A3%E5%86%B3-%E5%BC%B9%E5%87%BA%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86/</url>
      
        <content type="html"><![CDATA[<h2 id="首先查看你的远程仓库版本">首先查看你的远程仓库版本<a href="2019/10/04/git-push-解决-弹出用户名和密码输入框#首先查看你的远程仓库版本"></a></h2><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v </span><br><span class="line"></span><br><span class="line">result：</span><br><span class="line">origin  https://github.com/username/username.github.io.git (fetch)</span><br><span class="line">origin  https://github.com/username/username.github.io.git (push)</span><br></pre></td></tr></table></div></figure><p>若你没有添加别人的仓库，通常只有这两个</p><h2 id="重新设置对应远程仓库成ssh的方式">重新设置对应远程仓库成ssh的方式:<a href="2019/10/04/git-push-解决-弹出用户名和密码输入框#重新设置对应远程仓库成ssh的方式"></a></h2><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@github.com:username/repository.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> Git学习备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识就是力量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.gitignore忽略文件总结</title>
      <link href="/2019/10/04/gitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/04/gitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="语法归纳">语法归纳<a href="2019/10/04/gitignore忽略文件总结#语法归纳"></a></h2><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#               表示此为注释,将被Git忽略</span></span><br><span class="line">*.a             表示忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a          表示但lib.a除外</span><br><span class="line">/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；</span><br><span class="line">doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt</span><br><span class="line"> </span><br><span class="line">bin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件</span><br><span class="line">/bin:           表示忽略根目录下的bin文件</span><br><span class="line">/*.c:           表示忽略cat.c，不忽略 build/cat.c</span><br><span class="line">debug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj</span><br><span class="line">**/foo:         表示忽略/foo,a/foo,a/b/foo等</span><br><span class="line">a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等</span><br><span class="line">!/bin/run.sh    表示不忽略bin目录下的run.sh文件</span><br><span class="line">*.<span class="built_in">log</span>:          表示忽略所有 .<span class="built_in">log</span> 文件</span><br><span class="line">config.php:     表示忽略当前路径的 config.php 文件</span><br><span class="line"> </span><br><span class="line">/mtk/           表示过滤整个文件夹</span><br><span class="line">*.zip           表示过滤所有.zip文件</span><br><span class="line">/mtk/do.c       表示过滤某个具体文件</span><br><span class="line"> </span><br><span class="line">被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。</span><br><span class="line"> </span><br><span class="line">需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：</span><br><span class="line">!*.zip</span><br><span class="line">!/mtk/one.txt</span><br><span class="line"> </span><br><span class="line">唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？</span><br><span class="line">想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：</span><br><span class="line">/mtk/*</span><br><span class="line">!/mtk/one.txt</span><br><span class="line"> </span><br><span class="line">假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</span><br><span class="line">注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！</span><br><span class="line"> </span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">还有一些规则如下：</span><br><span class="line">fd1/*</span><br><span class="line">说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；</span><br><span class="line"> </span><br><span class="line">/fd1/*</span><br><span class="line">说明：忽略根目录下的 /fd1/ 目录的全部内容；</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">!.gitignore</span><br><span class="line">!/fw/ </span><br><span class="line">/fw/*</span><br><span class="line">!/fw/bin/</span><br><span class="line">!/fw/sf/</span><br><span class="line">说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。</span><br></pre></td></tr></table></div></figure><h2 id="从版本库去除并忽略提交">从版本库去除并忽略提交<a href="2019/10/04/gitignore忽略文件总结#从版本库去除并忽略提交"></a></h2><h3 id="先执行以下任意删除命令">先执行以下任意删除命令<a href="2019/10/04/gitignore忽略文件总结#先执行以下任意删除命令"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm file<span class="comment"># 从版本库删除，并删除本地文件</span></span><br><span class="line">git rm --cached file<span class="comment"># 从版本库删除文件并保留本地文件</span></span><br><span class="line">git rm -r --cached loggers  <span class="comment"># -r 是允许递归删除，当要删除的是文件夹的时候有用</span></span><br></pre></td></tr></table></div></figure><h3 id="在-gitignore文件中添加">在.gitignore文件中添加<a href="2019/10/04/gitignore忽略文件总结#在-gitignore文件中添加"></a></h3><h2 id="提醒">提醒<a href="2019/10/04/gitignore忽略文件总结#提醒"></a></h2><h3 id="gitignore忽略规则的匹配语法">.gitignore忽略规则的匹配语法<a href="2019/10/04/gitignore忽略文件总结#gitignore忽略规则的匹配语法"></a></h3><p>每一行的忽略规则的语法如下：</p><ul><li><strong>空格</strong>不匹配任意文件，可作为分隔符，可用反斜杠转义</li><li>以“<strong>＃</strong>”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。</li><li>可以使用标准的<strong>glob</strong>模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。</li><li>以斜杠”<strong>/</strong>“开头表示目录；”/“结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；”/“开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。</li><li>以星号”<strong><em>**”通配多个字符，即匹配多个任意字符；使用两个星号”</em></strong>*<strong>“ 表示匹配任意中间目录，比如`a/</strong>/z`可以匹配 a/z, a/b/z 或 a/b/c/z等。</li><li>以问号”<strong>?</strong>“通配单个字符，即匹配一个任意字符；</li><li>以方括号”<strong>[]</strong>“包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。</li><li>以叹号”<strong>!</strong>“表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：<strong>如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用”!”规则是不起作用的</strong>。也就是说”!”开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用”!”也不会再次被包含。可以使用反斜杠进行转义。</li></ul><p><strong>需要谨记</strong>：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p><h3 id="gitignore忽略规则的优先级">.gitignore忽略规则的优先级<a href="2019/10/04/gitignore忽略文件总结#gitignore忽略规则的优先级"></a></h3><p>在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：</p><ul><li>从命令行中读取可用的忽略规则</li><li>当前目录定义的规则</li><li>父级目录定义的规则，依次递推</li><li>$GIT_DIR/info/exclude 文件中定义的规则</li><li>core.excludesfile中定义的全局规则</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git学习备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识就是力量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行后台运行程序命令</title>
      <link href="/2019/10/03/linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/10/03/linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="后台执行命令：-amp-和nohup">后台执行命令：&amp;和nohup<a href="2019/10/03/linux后台运行程序#后台执行命令：-amp-和nohup"></a></h1><h2 id="归纳：">归纳：<a href="2019/10/03/linux后台运行程序#归纳："></a></h2><h4 id="ps-ef或者grep查看进程"><code>ps -ef</code>或者<code>grep</code>查看进程<a href="2019/10/03/linux后台运行程序#ps-ef或者grep查看进程"></a></h4><h4 id="kill-XX杀死进程，XX替换为进程PID"><code>kill XX</code>杀死进程，<code>XX</code>替换为进程PID<a href="2019/10/03/linux后台运行程序#kill-XX杀死进程，XX替换为进程PID"></a></h4><h4 id="命令后加-amp-后台运行，但生命周期受窗口限制">命令后加<code>&amp;</code>后台运行，但生命周期受窗口限制<a href="2019/10/03/linux后台运行程序#命令后加-amp-后台运行，但生命周期受窗口限制"></a></h4><h4 id="nohup-命令-amp-完全后台运行"><code>nohup 命令 &amp;</code>完全后台运行<a href="2019/10/03/linux后台运行程序#nohup-命令-amp-完全后台运行"></a></h4><p><a href="https://blog.csdn.net/liuyanfeier/article/details/62422742" target="_blank" rel="noopener"><strong>原文链接</strong></a>，本文归纳梳理，便于自己记忆。</p><h2 id="后台运行命令">后台运行命令<a href="2019/10/03/linux后台运行程序#后台运行命令"></a></h2><h3 id="amp">&amp;<a href="2019/10/03/linux后台运行程序#amp"></a></h3><p><code>断开链接或者关闭窗口仍然会终止程序</code></p><blockquote><p>在命令后面加上&amp; 实现后台运行。例如：</p></blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh test.sh &amp;</span><br></pre></td></tr></table></div></figure><blockquote><ul><li><p>适合在后台运行的命令有find、费时的排序及一些shell脚本。</p></li><li><p>需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。</p></li><li><p>后台运行一样会将结果输出到屏幕上，干扰你的工作。</p></li><li><p>如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中</p></li></ul><p><code>命令  &gt;  out.file  2&gt;&amp;1  &amp; 1</code></p><p>这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。</p><ul><li><p>当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它</p><p><strong>(ps -ef | grep 进程号 或者 kill -9 进程号）</strong></p></li></ul></blockquote><h3 id="nohup">nohup<a href="2019/10/03/linux后台运行程序#nohup"></a></h3><p> <code>可退出命令窗口使用</code></p><blockquote><ul><li><p>使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用</p></li><li><p>一但把当前控制台关掉(退出帐户时)，作业就会停止运行。</p></li><li><p><strong>nohup命令</strong>可以在你退出帐户之后继续运行相应的进程。</p><blockquote><p>nohup就是不挂起的意思( no hang up)。该命令的一般形式为：</p></blockquote></li></ul></blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup 命令 &amp;1</span><br></pre></td></tr></table></div></figure><p>如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup command &gt; myout.file 2&gt;&amp;1 &amp;1</span><br></pre></td></tr></table></div></figure><h2 id="注意">注意<a href="2019/10/03/linux后台运行程序#注意"></a></h2><p>使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。</p><ul><li>ctrl + z<br>可以将一个正在前台执行的命令放到后台，并且处于暂停状态。</li><li>ctrl+c<br>终止前台命令。</li><li>jobs<br>查看当前有多少在后台运行的命令。<br>jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。</li><li>2&gt;&amp;1解析</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt;out.file 2&gt;&amp;1 &amp;1</span><br></pre></td></tr></table></div></figure><ol><li>command&gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。</li><li>2&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行。</li><li>试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识就是力量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows脚本转移Linux上git命令出现错误</title>
      <link href="/2019/10/03/windows%E8%84%9A%E6%9C%AC%E8%BD%AC%E7%A7%BBLinux%E4%B8%8Agit%E5%91%BD%E4%BB%A4%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF/"/>
      <url>/2019/10/03/windows%E8%84%9A%E6%9C%AC%E8%BD%AC%E7%A7%BBLinux%E4%B8%8Agit%E5%91%BD%E4%BB%A4%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="场景">场景<a href="2019/10/03/windows脚本转移Linux上git命令出现错误#场景"></a></h2><p>在我将整个hexo博客源码从windows10转移到linux（centos7）中时，脚本中的git命令没有例外的出现了这个错误</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git: <span class="string">'pull'</span> is not a git <span class="built_in">command</span>. See <span class="string">'git --help'</span>.  </span><br><span class="line">Did you mean one of these? </span><br><span class="line">pull</span><br><span class="line"></span><br><span class="line">git: <span class="string">'push'</span> is not a git <span class="built_in">command</span>. See <span class="string">'git --help'</span>.  </span><br><span class="line">Did you mean one of these? </span><br><span class="line">push</span><br></pre></td></tr></table></div></figure><p>这是什么人间疾苦，于是我Google，找到最接近的答案就是这个</p><p><a href="https://stackoverflow.com/questions/1465398/git-pull-broken" target="_blank" rel="noopener">https://stackoverflow.com/questions/1465398/git-pull-broken</a></p><p>这是十年前的一个issue，很明显不是这个问题。git早已经修正了这个issue。</p><p><strong>那么问题来了，这到底是什么原因导致git认为你认为完全正确的命令是有问题的呢：</strong></p><ul><li>首先我保证绝对不是git版本的问题，我反复在服务器上更替了不同版本的git，无论是直接安装编译好的版本还是自己编译都多次尝试过，但是无一例外出错了。还是相同的错误。</li><li>其次脚本绝对是可运行的，在windows上可以正确无误的执行。</li><li>服务器镜像问题？没钱换服务器，况且服务器上运行了不少东西，不好更换，但我觉得的应该不是，其他脚本命令是可以运行的。</li></ul><p>那到底是哪的问题呢？</p><h2 id="解决">解决<a href="2019/10/03/windows脚本转移Linux上git命令出现错误#解决"></a></h2><p>最后我几乎快完全丧失解决它的希望时，我进行了最后一次尝试。</p><p><strong>用在linux  vim重写脚本，发现在写的途中有些命令写出现和原来的颜色是不一样的</strong></p><p>最后脚本运行成功。</p><p><strong>所以千万别用windows10的记事本写代码，应该是编码的问题，还是建议用专业的编辑器写脚本</strong></p>]]></content>
      
      
      <categories>
          
          <category> 错误记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 巨坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+admin+windows服务器的综合博客平台</title>
      <link href="/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/"/>
      <url>/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="windows下的hexo-github博客搭建">windows下的hexo+github博客搭建<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#windows下的hexo-github博客搭建"></a></h1><h2 id="博客搭建">博客搭建<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#博客搭建"></a></h2><p>不多说这里放上<a href="https://zhuanlan.zhihu.com/p/35668237" target="_blank" rel="noopener">大神的知乎</a>，点击自己按照流程来做就好了，下面我做一个归纳整理，也留作备份。</p><h3 id="安装Node-js">安装Node.js<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#安装Node-js"></a></h3><blockquote><ul><li><p><a href="https://nodejs.org/dist/v12.14.0/node-v12.14.0-x64.msi" target="_blank" rel="noopener">windows下载链接</a></p></li><li><p>下载之后一路next就好，环境变量默认会把帮你配好</p></li><li><p>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p></li><li><p>也有没有自动配的情况，可以手动配一下。</p></li></ul></blockquote><h3 id="添加国内镜像源">添加国内镜像源<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#添加国内镜像源"></a></h3><blockquote><p>如果没有K X S W(这是啥大家都明白吧)的话，可以使用阿里的国内镜像进行加速。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><h3 id="安装Git">安装Git<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#安装Git"></a></h3><blockquote><ul><li><a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git的下载链接</a></li><li>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</li><li>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</li><li>同样如果没有找到版本号需要手动配置</li></ul></blockquote><h3 id="注册Github账号">注册Github账号<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#注册Github账号"></a></h3><blockquote><ul><li><p><a href="https://link.zhihu.com/?target=https%3A//github.com/" target="_blank" rel="noopener">注册地址</a></p></li><li><p>注册完成之后进入主页</p></li><li><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/Screenshot.png" alt="Screenshot" class="article-img"></p><p>点击新建项目</p></li><li><p>项目名称是你的github用户名加.github.io </p><blockquote><p>例如: <code>XXXXX.github.io</code></p><p>同时也可以勾选一下Redme.md</p></blockquote><p>![new p](C:\data\Treeeeeeee.github.io\blog\source_posts\hexo-admin-windows-服务器的综合博客平台\new p.png)</p></li><li><p>然后按照下面的流程你就可以获得一个最简单的博客</p><ul><li><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/m.png" alt="m" class="article-img"></p></li><li><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/2.png" alt="2" class="article-img"></p></li><li><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/3.png" alt="3" class="article-img"></p></li><li><p>进去之后随便选一个</p></li></ul></li></ul></blockquote><h3 id="安装Hexo">安装Hexo<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#安装Hexo"></a></h3><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在<code>D:\study\program\blog</code>目录下。</p><p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p><p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href="https://link.zhihu.com/?target=http%3A//localhost%3A4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，就可以看到我们的博客啦，效果如下：</p><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E5%9B%BE%E7%89%8720191003174050.png" alt="TIM图片20191003174050" class="article-img"></p><p>按<code>ctrl+c</code>关闭本地服务器。</p><h3 id="连接Github与本地">连接Github与本地<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#连接Github与本地"></a></h3><p>首先右键打开git bash，然后输入下面命令：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"godweiyang"</span></span><br><span class="line">git config --global user.email <span class="string">"792321264@qq.com"</span></span><br></pre></td></tr></table></div></figure><p>用户名和邮箱根据你注册github的信息自行修改。</p><p>然后生成密钥SSH key：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"792321264@qq.com"</span></span><br></pre></td></tr></table></div></figure><p>打开<a href="https://link.zhihu.com/?target=http%3A//github.com/" target="_blank" rel="noopener">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>git bash中输入</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></div></figure><p>将输出的内容复制到框中，点击确定保存。</p><p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></div></figure><p>repository或者repo修改为你自己的github项目地址</p><blockquote><p>我这里默认的是使用<code>ssh</code>，如果想使用<code>https</code>点击更换就好了</p><ul><li>我推荐使用ssh，毕竟你已经在你的github中添加了你本机的ssh，免得再输密码</li><li>如果不懂ssh可以先使用https，后面我们做服务器的自动git用ssh会更好，如果不需要，而且是在windows下使用的话那就<code>https</code>的吧，没啥关系，windows有记住密码的功能</li></ul></blockquote><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003175326.png" alt="TIM截图20191003175326" class="article-img"></p><h3 id="写文章、发布文章">写文章、发布文章<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#写文章、发布文章"></a></h3><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p><p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p><blockquote><p>article title 替换成你要写的文章的名字，需要注意一下：</p><ul><li><p>最好使用英文，使用中文的话博客的url会非常长</p></li><li><p>如果想插入图片的话，打开你的博客目录里面的<code>_config.yml</code>找到<code>post_asset_folder:</code>属性，并复制未<code>true</code>，这样生成一篇新文章时，会在</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   \source\_posts</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></li></ul></blockquote><blockquote><p>  目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等。这样在文章中插入图片使用相对路径就可以即在本地书写的时候看到图片，又在生成的博客中看到，例如：</p><p>  <img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003180656.png" alt="TIM截图20191003180656" class="article-img"></p><p>  在文章中直接这样插入，就可以完美插入图片。详细可以借鉴我<a href="https://treeeeeeee.github.io/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87">另外一篇博客</a></p><p>  <img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003180755.png" alt="TIM截图20191003180755" class="article-img"></p><ul><li><p>这里推荐一个超好用加方便的markdown编辑软件<code>Typora</code>，而且恰好支持这种图片资源文件，设置一下可以把任意来源图片直接弄到对应文件夹</p><blockquote><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003183937.png" alt="TIM截图20191003183937" style="zoom: 67%;"><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003184214.png" alt="TIM截图20191003184214" class="article-img"></p><p><strong>这样设置以后你不管是从网络上来的图片还是任意地方拖动的进来的图片都会自动给你放到这个文件夹</strong></p></blockquote></li></ul></blockquote><p>然后打开<code>D:\study\program\blog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p><h3 id="绑定域名">绑定域名<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#绑定域名"></a></h3><p>现在默认的域名还是<code>xxx.github.io</code>，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。</p><p>以我的百度云为例，如下图所示，添加两条解析记录：</p><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/v2-e11377329d5cef129c0aefd10eaa1607_hd.jpg" alt="img" class="article-img"></p><p>然后打开你的github博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存：</p><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/v2-8125794bbf0055917b820178489c7b0f_hd.jpg" alt="img" class="article-img"></p><p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\study\program\blog\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到github。</p><h3 id="备份博客源文件">备份博客源文件<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#备份博客源文件"></a></h3><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p><ul><li><p><strong>我的备份方法</strong></p><blockquote><p>随便找个文件夹，右键打开git bash，依次执行以下命令</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git clone 你的博客仓库地址</span><br><span class="line">&gt; git checkout -b backup</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>然后删除你拉下来的所有东西文件夹，如果你开了隐藏文件夹也可见的话别把<code>.git</code>文件夹删除了，如果没开就放心删除所有文件吧（看见<code>.git</code>别动就对了）</p><p>然后把你你的整个博客文件夹移动到这里，并删除你博客文件下里面所有叫<code>.gitignore</code>的文件，通常来说，博客源码根目录有一个，主题文件夹里面都有</p><blockquote><p><code>.gitignore</code>文件是用来说明那些东西不被git push的，具体请自行百度</p></blockquote><p>然后继续依次执行以下命令</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; git add .</span><br><span class="line">&gt; git commit -s -m &quot;backup&quot;</span><br><span class="line">&gt; git push</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>等待完成就可以在任何地方直接拉下来使用了，在其他地方使用有以下几个要注意的：</p><ul><li><p>环境必须安装这个没得说</p></li><li><p>如果你是使用shh来部署的项目需要把这台设备的生成的ssh添加到你的github账号里</p><blockquote><p>指的是你前面属性<code>repo :</code>是用的https的还是ssh的</p></blockquote></li></ul></blockquote></li><li><p>其他备份方法(该内容是粘贴复制)</p><blockquote><p>首先在github博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git branch -b hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo</code>提交就行了。</p></blockquote></li></ul><h3 id="博客源代码下载">博客源代码下载<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#博客源代码下载"></a></h3><h3 id="个性化设置（matery主题）">个性化设置（matery主题）<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#个性化设置（matery主题）"></a></h3><h3 id="常见问题及解答（FAQ）">常见问题及解答（FAQ）<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#常见问题及解答（FAQ）"></a></h3><h2 id="个性化设置-更换主题">个性化设置|更换主题|<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#个性化设置-更换主题"></a></h2><h3 id="效果图">效果图<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#效果图"></a></h3><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003184704.png" alt="TIM截图20191003184704" class="article-img"></p><p><a href="https://treeeeeeee.github.io">我的博客地址</a>有什么问题可以在文章下评论留言</p><h3 id="inside主题">inside主题<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#inside主题"></a></h3><ul><li><p>直接下载源码放到你的博客源码目录的themes目录里面，并修改<code>_config.yml</code>文件中<code>theme:</code>属性，然后执行：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></div></figure><p>浏览器访问：localhost:4000 就能直接看到效果了</p></li><li><p>具体配置我就不详细说明了可以去看主题制作者的博客：<a href="https://blog.oniuo.com/theme-inside" target="_blank" rel="noopener">链接</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 兴趣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> 浪费了大好青春 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完美的hexo中插入图片的解决方案</title>
      <link href="/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
      <url>/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="完美的hexo中插入图片的解决方案">完美的hexo中插入图片的解决方案<a href="2019/10/01/hexo下完美插入图片#完美的hexo中插入图片的解决方案"></a></h1><p>以下内容来自ETRD的<a href="[http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/](http://etrd.org/2017/01/23/hexo中完美插入本地图片/)">《hexo中完美插入本地图片》</a>，摘录整理关键部分，留作备份。</p><h3 id="Markdown编辑器">Markdown编辑器<a href="2019/10/01/hexo下完美插入图片#Markdown编辑器"></a></h3><ul><li><p><strong>Typora</strong></p><blockquote><p>不需要关注太多markdown语法就能写出比较好看的markdown，支持实时转换</p></blockquote></li></ul><h3 id="Hexo配置文件的设置">Hexo配置文件的设置<a href="2019/10/01/hexo下完美插入图片#Hexo配置文件的设置"></a></h3><p> 确保你的Hexo的配置文件_config.yml里面有个这个选项配置，并将其置为true</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></div></figure><p> 这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new</span><br></pre></td></tr></table></div></figure><p>生成一篇新文章时，会在</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\source\_posts</span><br></pre></td></tr></table></div></figure><p>目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等</p><p><a href="http://etrd.org/2017/01/23/hexo中完美插入本地图片/QQ截图20170123112354.png" target="_blank" rel="noopener"><img src="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/QQ%E6%88%AA%E5%9B%BE20170123112354.png" alt="QQ截图20170123112354"></a></p><p>实际上我通常喜欢自己右键手动去建立一个md文件来写博客，而不使用hexo new命令，此时要达到同样的效果，我同样也需要手动去建立一个同名的文件夹去存放资源，我试过这样做是可行的，并且这样做虽然有点麻烦，但我似乎发现了它的一个优点，那就是当我的文章中没有图片时，我并不需要这个空的资源文件夹。</p><p>有了上面的配置，Hexo在public文件下生成html文件时，会在相应的目录中把那文章对应的资源文件夹中的图片等附件复制过去，例如，这是我生成的一个例子：</p><h3 id="安装hexo-asset-image插件">安装hexo-asset-image插件<a href="2019/10/01/hexo下完美插入图片#安装hexo-asset-image插件"></a></h3><p>你需要安装一个图片路径转换的插件，这个插件名字是<strong>hexo-asset-image</strong>，我目前安装的是最新的0.03版本，使用如下命令安装插件</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></div></figure><p>插件安装完以后，实际上是存放在下面的目录文件夹下</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\blog\node_modules\hexo-asset-image</span><br></pre></td></tr></table></div></figure><p>想要卸载这个插件怎么处理，我听说直接删掉这个文件夹，反正我这么试过了。</p><h3 id="md文件的时间标签">md文件的时间标签<a href="2019/10/01/hexo下完美插入图片#md文件的时间标签"></a></h3><p>hexo-asset-image的原理应该是根据Hexo生成html后以时间的为目录的规则，将我们图片的相对地址转换成了生成后与时间对应目录的绝对地址，因此我认为md文件中应该要有时间标签，一来是为了让Hexo根据md的时间标签来确定文章的新旧排序，如果没有时间标签，Hexo会把md文件的修改时间作为发布时间，这显然是不合理的，再者这个时间标签，我想hexo-asset-image也会引用到，在一篇实际的博文中，我的md文件完整的开头是这样的：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: hexo中完美插入本地图片</span><br><span class="line">date: 2017-01-23 11:00:55</span><br><span class="line">categories: hexo使用</span><br><span class="line">tags: </span><br><span class="line">- hexo</span><br><span class="line">- 本地图片</span><br><span class="line">- hexo-asset-image</span><br></pre></td></tr></table></div></figure><h3 id="插入图片">插入图片<a href="2019/10/01/hexo下完美插入图片#插入图片"></a></h3><p>由于每个md文件都有对应的一个资源文件夹，因此，你首先要把需要插入的图片放到这个资源文件夹下，然后进行路径引用，这是上面插入图片时的实际引用代码</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![QQ截图20170123114005](/hexo中完美插入本地图片/QQ截图20170123114005.png)</span><br></pre></td></tr></table></div></figure><p>使用Typora又有一个十分方便的地方在于，只需要将图片往这里一拖就插入了，但其实际拖入图片后的插入代码是绝对路径的引用，是这样的</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![QQ截图20170123114005](K:\FangCloudSync\Github博客源码\blog\source\_posts\hexo中完美插入本地图片\QQ截图20170123114005.png)</span><br></pre></td></tr></table></div></figure><p>对比上面的两个代码，我只需要将前面的那段绝对路径删掉<del>K:\FangCloudSync\Github博客源码\blog\source_posts</del> ，然后再将剩余的<strong>两个\分别换成/</strong> 就可以了</p><p>当然你要是觉得还是麻烦，可以直接打开typora的偏好设置</p><p><img src="/2019/10/01/hexo下完美插入图片/TIM%E6%88%AA%E5%9B%BE20191230113452.png" alt="TIM截图20191230113452" class="article-img"></p><p>进行如上设置，就不用手动编辑成相对路径了</p><p>这样子，Typora编辑时同时能够看到插入的图片。</p>]]></content>
      
      
      <categories>
          
          <category> 兴趣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于酷q平台的管理机器人</title>
      <link href="/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="酷Q机器人">酷Q机器人<a href="2019/10/01/基于酷q平台的管理机器人#酷Q机器人"></a></h2><hr><p><strong>自从samrtQQ下线之后，很多QQ机器人都失效了。</strong></p><p><strong>但是最近又比较想用这样一个机器人来管理减轻自己的一些工作，于是千方百计的我发现了酷Q。</strong></p><p><strong>这里附上<a href="https://cqp.cc/" target="_blank" rel="noopener">官网链接</a></strong></p><h3 id="开发以及注意事项">开发以及注意事项<a href="2019/10/01/基于酷q平台的管理机器人#开发以及注意事项"></a></h3><ol><li><h5 id="SDK的选择"><a href="2019/10/01/基于酷q平台的管理机器人#SDK的选择" class="headerlink" title="SDK的选择"></a>SDK的选择</h5><p>酷q提供了多种<a href="https://cqp.cc/t/15124" target="_blank" rel="noopener">SDK</a>但是都是我不常用的，官方的支持的SDK是E语言，这语言emmmm好，都好，写，都可以写。虽然提供了java的sdk但是java版本始终不是正统，咬牙学了一天E语言，最后还是吐了。没办法，不习惯，没说E语言不好。害，最后还是选择的java版本。不过但是还没开始使用的时候我看到了更加好用的一个找到一个更加好用方便的SDK-<a href="https://github.com/HyDevelop/PicqBotX" target="_blank" rel="noopener">PicqBotX</a>，这是通过http的插件来与酷q的程序交互。虽然不能像官方网站上提供的那个那样可以直接打包成jar运行但是个人认为开发更加简单。</p></li><li><p><strong>环境以及配置细节</strong></p><p><a href="https://github.com/HyDevelop/PicqBotX" target="_blank" rel="noopener">这里讲得很清楚，以下说明几个坑</a>：</p><ul><li><p>如果使用kotlin代替java进行开发，请最好使用Gradle对项目进行管理，它对kotlin有更加完美的支持。</p></li><li><p><img src="/2019/10/01/基于酷q平台的管理机器人/%E9%85%B7q%E9%85%8D%E7%BD%AE%E5%9D%8F%E5%A2%83%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.jpg" alt class="article-img"></p><p>在介绍readme中的这个位置一定要看准，下载对应版本的工具，否则可能出问题，比较麻烦，而且没有提示难以排查。</p></li><li><p>两个端口号一定要对应于你程序中的机器人的端口号否则会链接失败（建议直接用默认的31091 31092，也可自己选择）</p></li></ul></li></ol><h3 id="本人开发流程">本人开发流程<a href="2019/10/01/基于酷q平台的管理机器人#本人开发流程"></a></h3><ol><li><p>使用idea新建项目选择gradle管理项目<img src="/2019/10/01/基于酷q平台的管理机器人/idea%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.png" alt>java版本任意，需要kotlin开发勾选kotlin</p></li><li><p>导包</p><p><img src="/2019/10/01/基于酷q平台的管理机器人/%E5%AF%BC%E5%8C%85.png" alt class="article-img"></p><p>导入最新的sdk。</p></li><li><p>根据需要复制示例代码更改</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBot</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建机器人对象 ( 传入配置 )</span></span><br><span class="line">        PicqBotX bot = <span class="keyword">new</span> PicqBotX(<span class="keyword">new</span> PicqConfig(<span class="number">31092</span>).setDebug(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加一个机器人账户 ( 名字, 发送URL, 发送端口 )</span></span><br><span class="line">        bot.addAccount(<span class="string">"Bot01"</span>, <span class="string">"127.0.0.1"</span>, <span class="number">31091</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册事件监听器, 可以注册多个监听器</span></span><br><span class="line">        bot.getEventManager().registerListeners(</span><br><span class="line">                <span class="keyword">new</span> TestListener(), </span><br><span class="line">                <span class="keyword">new</span> RequestListener(),</span><br><span class="line">                <span class="keyword">new</span> ExceptionListener()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启用指令管理器</span></span><br><span class="line">        <span class="comment">// 这些字符串是指令前缀, 比如指令"!help"的前缀就是"!"</span></span><br><span class="line">        bot.enableCommandManager(<span class="string">"bot -"</span>, <span class="string">"!"</span>, <span class="string">"/"</span>, <span class="string">"~"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册指令, 可以注册多个指令</span></span><br><span class="line">        bot.getCommandManager().registerCommands(</span><br><span class="line">                <span class="keyword">new</span> CommandSay(),</span><br><span class="line">                <span class="keyword">new</span> CommandTest(),</span><br><span class="line">                <span class="keyword">new</span> CommandVersion()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动机器人, 不会占用主线程</span></span><br><span class="line">        bot.startBot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ol><h3 id="个人实现效果和功能">个人实现效果和功能<a href="2019/10/01/基于酷q平台的管理机器人#个人实现效果和功能"></a></h3><ul><li><p>通知功能</p><img src="/2019/10/01/基于酷q平台的管理机器人/通知.jpg" style="zoom:50%;"></li><li><p>请假功能</p><p>有学生请假则会以json格式文本保存在服务器（或者本地）</p><img src="/2019/10/01/基于酷q平台的管理机器人/请假.jpg" style="zoom: 33%;"></li><li><p>导出请假表格文档，会直接给下载链接</p><img src="/2019/10/01/基于酷q平台的管理机器人/请假文档.jpg" style="zoom: 50%;"></li><li><p>补登请假</p><img src="/2019/10/01/基于酷q平台的管理机器人/补登请假.jpg" style="zoom: 50%;"></li><li><p>还有安卓端的管理app和网页版实时查看数据。</p></li></ul><h3 id="部署机器人">部署机器人<a href="2019/10/01/基于酷q平台的管理机器人#部署机器人"></a></h3><p><strong>在winows server上部署</strong></p><p>太简单了，省略具体步骤，总结解释就是以下步骤：</p><ul><li>电脑上安装上所有酷q，http插件，java所需要的环境，跟你的本地一样（本地会配置，我想server上配置也难不倒聪明的你）</li><li>打包你的机器人，可以是jar可以是其他的，只要是能够将你的代码打包运行就好</li><li>运行酷q，打开http插件，运行你的机器人。</li></ul><p><strong>在linux上部署</strong></p><p>因为酷q是window程序，要想在linux上部署那就必须得使用docker（不知道docker是什么的请百度），由于不是专业运维方向对docker不是很了解，也踩了很多坑。</p><p>这里附上http插件的<a href="https://cqhttp.cc/docs" target="_blank" rel="noopener">官方教程</a>，里面有详细的描述如何安装最新的酷q的docker镜像，如果docker还没安装自行百度安装你的服务器的docker。</p><p>然后基本上和以上步骤都是差不多，但是有个地方需要注意</p><p><img src="/2019/10/01/基于酷q平台的管理机器人/image-20191113001251371.png" alt="image-20191113001251371" class="article-img"></p><p>这里的上报地址，理所当然就是酷q接收到消息之后传递给你的程序去处理，但是在docker中利用127.0.0.1是访问的docker内部，而你的机器人程序并不是在docker内所以，酷q是无法将消息上报给你的机器人的，有以下解决方案：</p><ul><li><p>对于mac和windows可以使用host.docker.internal替换127.0.0.1</p></li><li><p>对于Linux可以创建一个桥接网络(我在网络上查找的，自己在centos上没有尝试成功)<br>下面的localNet是网络名字,可自行修改;关于192.168.0.0这个子网,也可以自行定义.<br>默认按照下面的命令,执行后将可以通过192.168.0.1访问宿主机</p><p><code>docker network create -d bridge --subnet 192.168.0.0/24 --gateway 192.168.0.1 localNet</code></p></li><li><p>若你是在你的服务器上部署的你的机器人，可以直接使用服务器的公网ip</p></li></ul><p>只有这样酷q才能将消息上报到你的机器人处理,否则你的机器人只能发送消息，不能接收消息并作出反应。</p><h3 id="用到的库">用到的库<a href="2019/10/01/基于酷q平台的管理机器人#用到的库"></a></h3><hr><ul><li>阿帕奇的表格框架</li><li>gson</li></ul><p>通知管理机器人源代码地址：<a href>冷漠无情的机器人</a></p><p>因为源代码中有不少私人数据，所以取消。</p>]]></content>
      
      
      <categories>
          
          <category> 兴趣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 世界这么大，当然要多去看看 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
