<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[安卓Drawable]]></title>
    <url>%2F2019%2F11%2F25%2F%E5%AE%89%E5%8D%93Drawable%2F</url>
    <content type="text"><![CDATA[Android Drawable 相信大家都不陌生，本篇我们就来全面深入了解它，Drawable是一种可以在Canvas上进行绘制的抽象的图像，它的子类也相当多，所以在开发中很容易导致我们对不同Drawable的理解产生混乱，因此我们很有必要来全面了解一下Drawable的子类及其使用方式滴，哈~。 一、Drawable的简述 Drawable在我们开发中常被用来作为View的背景图像，一般情况下我们都是通过XML来定义Drawable的，当然我们也可以通过代码创建Drawable，只不过会比较复杂而已。Drawable最大的好处就是可以方便我们做出一些特殊的UI效果，这点比我们自定义View实现的效果来得更容易些。因此深入理解Drawable的用法还是很有必要的，接下来我们来看看Drawable的一些特性： 1、Drawable本身表示的只是一种图像的概念，因此Drawable不仅仅是图片，也可以是颜色构造出来的图像效果（后面会说明）。 2、Drawable本身是一个抽象类，因此具体的实现都是由子类完成的，比如ShapeDrawable，BitmapDrawable等。 3、Drawable的内部宽高可以分别通过getIntrinsicWidth()和getIntrinsicHeight()获取，但并不是所有的Drawable都有内部宽高的属性，比如一个颜色形成的Drawable并没有宽高的概念。在大多数情况下，Drawable并没有大小的概念，因为当Drawable作为View的背景图时，Drawable会被拉伸至View的同等大小。 二、千变万化的Drawable1、BitmapDrawable BitmapDrawable 是对bitmap的一种包装，可以设置它包装的bitmap在BitmapDrawable区域内的绘制方式，如平铺填充、拉伸填充或者保持图片原始大小，也可以在BitmapDrawable区域内部使用gravity指定的对齐方式。其语法如下： 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android" android:src="@[package:]drawable/drawable_resource" android:antialias=["true" | "false"] android:dither=["true" | "false"] android:filter=["true" | "false"] android:gravity=["top" | "bottom" | "left" | "right" | "center_vertical" | "fill_vertical" | "center_horizontal" | "fill_horizontal" | "center" | "fill" | "clip_vertical" | "clip_horizontal"] android:tileMode=["disabled" | "clamp" | "repeat" | "mirror"] /&gt;123456789101112 我们分析一下这些属性的含义：android:src 类型：Drawable resource。必需。 引用一个drawable resource.android:antialias 类型：Boolean。是否开启抗锯齿。开启后图片会变得更平滑些，因此一般建议开启，设置为true即可。android:dither 类型：Boolean。是否允许抖动，如果位图与屏幕的像素配置不同时，开启这个选项可以让高质量的图片在低质量的屏幕上保持较好的显示效果（例如：一个位图的像素设置是 ARGB 8888，但屏幕的设置是RGB 565，开启这个选项可以是图片不过于失真）一般建议开启，为true即可。android:filter 类型：Boolean。是否允许对位图进行滤波。当图片被压缩或者拉伸时，使用滤波可以获得平滑的外观效果。一般建议开启，为true即可android:gravity 当图片小于容器尺寸时，设置此选项可以对图片经典定位，这个属性比较多，不同选项可以使用‘|’来组合使用。 可选项 含义 top 将图片放在容器顶部，不改变图片大小 bottom 将图片放在容器底部，不改变图片大小 left 将图片放在容器左侧，不改变图片大小 right 将图片放在容器右侧，不改变图片大小 center_vertical 图片竖直居中，不改变图片大小 fill_vertical 图片竖直方向填充容器 center_horizontal 图片水平居中，不改变图片大小 fill_horizontal 图片水平方向填充容器 center 使图片在水平方向和竖直方向同时居中，不改变图片大小 fill 图片填充容器，默认值 clip_vertical 竖直方向剪切，很少使用 clip_horizontal 水平方向剪切，很少使用 android:mipMap 纹理映射处理技术，不太懂，不过一般也不用，默认为falseandroid:tileMode 平铺模式。共有以下几个值 disabled ：默认值，表示不使用平铺 clamp ：复制边缘色彩 repeat ：X、Y 轴进行重复图片显示，也就是我们说要说的平铺 mirror ：在水平和垂直方向上使用交替镜像的方式重复图片的绘制 三者区别如下图： BitmapDrawable的xml使用方式比较简单，我们这里就不贴案例了哈。接下来我们来看看在代码中如何使用BitmapDrawable。 实际上我们从BitmapDrawable的源码可以看出，目前Google建议我们创建BitmapDrawable的构造方法有3种 12345public BitmapDrawable(Resources res, Bitmap bitmap) public BitmapDrawable(Resources res, String filepath)public BitmapDrawable(Resources res, java.io.InputStream is)12345 参数比较简单，res就是我们通过getResource()获取到的资源管理对象，bitmap就是我们需要用BitmapDrawable包装的图片对象，filepath，需要包装的图片所在路径，is则是一个图像流，需要转换成 BitmapDrawable。但是在大多数情况下我们还是建议使用xml实现比较好，代码实现我们不打算深究，我们这里直接给出一个代码应用案例： 1234567Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.image1);BitmapDrawable mBitmapDrawable = new BitmapDrawable(getResources()，mBitmap);mBitmapDrawable.setTileModeXY(TileMode.MIRROR, TileMode.MIRROR);//平铺方式mBitmapDrawable.setAntiAlias(true);//抗锯齿mBitmapDrawable.setDither(true);//防抖动//设置到imageView上即可imageView.setImageDrawable(mBitmapDrawable);1234567 2、NinePatchDrawable NinePatchDrawable表示的是我们熟悉的.9格式的图片，.9图片可以在保证图片不失真的情况下任意进行缩放，在实际的使用中我们也是通过Xml来实现即可： 123&lt;nine-patch xmlns:android="http://schemas.android.com/apk/res/android" android:src="drawable/resource" android:dither="[true|false]"/&gt; 123 属性和BitmapDrawable中属性的含义相同，这里不过多描述。一般情况下不建议代码创建.9图，因为Android虽然可以使用Java代码创建NinePatchDrawable，但是极少情况会那么做，这是因为由于Android SDK会在编译工程时对点九图片进行编译，形成特殊格式的图片。使用代码创建NinePatchDrawable时只能针对编译过的点九图片资源，对于没有编译过的点九图片资源都当做BitmapDrawable对待。还有点需要特别注意的是，点九图只能适用于拉伸的情况，对于压缩的情况并不适用，如果需要适配很多分辨率的屏幕时需要把点九图做的小一点。 3、ShapeDrawable ShapeDrawable对于Xml的shape标签，在实际开发中我们经常将其作为背景图片使用，因为ShapeDrawable可以帮助我们通过颜色来构造图片，也可以构造渐变效果的图片，总之，ShapeDrawable足矣满足我们大部分特殊需求下面我们说说其使用方法： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape=["rectangle" | "oval" | "line" | "ring"] &gt; &lt;corners android:radius="integer" android:topLeftRadius="integer" android:topRightRadius="integer" android:bottomLeftRadius="integer" android:bottomRightRadius="integer" /&gt; &lt;gradient android:angle="integer" android:centerX="integer" android:centerY="integer" android:centerColor="integer" android:endColor="color" android:gradientRadius="integer" android:startColor="color" android:type=["linear" | "radial" | "sweep"] android:usesLevel=["true" | "false"] /&gt; &lt;padding android:left="integer" android:top="integer" android:right="integer" android:bottom="integer" /&gt; &lt;size android:width="integer" android:height="integer" /&gt; &lt;solid android:color="color" /&gt; &lt;stroke android:width="integer" android:color="color" android:dashWidth="integer" android:dashGap="integer" /&gt;&lt;/shape&gt;123456789101112131415161718192021222324252627282930313233343536 从代码中我们可以看出Shape的子元素包括、、、、、，我们一个个分析。android:shape 这个属性表示图像的形状，可以是rectangle（矩形）、oval（椭圆）、line（横线）、ring（圆环）。默认为rectangle。这里对于ring值还有几个相关的属性： 属性 含义 android:innerRadius 圆环的半径与android:innerRadiusRatio同时存在时，以android:innerRadius 为准 android:innerRadiusRatio 内半径占整个Drawable宽度的比例，默认值为9.如果为n，那么半径=宽度/n android:thickness 圆环的厚度，即外半径减去内半径的大小与android：thicknessRatio同时存在时以android:thickness为准 android：thicknessRatio 厚度占整个Drawable宽度比例，默认值为3，如果为n，那么厚度=宽度/n android:useLevel 一般都应该使用false，否则可能无法达到预期显示效果，除非它被当做LevelListDrawable来使用。 指定边角的半径，数值越大角越圆，数值越小越趋近于直角，参数为： 123456&lt;cornersandroid:radius="integer"android:topLeftRadius="integer"android:topRightRadius="integer"android:bottomLeftRadius="integer"android:bottomRightRadius="integer" /&gt;123456 Android:radius直接指定4个角的半径，另外4个属性可以单独设置4个角的角度. 设置颜色渐变与为互斥标签，因为solid表示纯色填充，而gradient表示渐变填充。 属性 含义 android:angle 渐变的角度，默认为0，其值务必为45°的倍数，0表示从左到右，90表示从下到上。 android:centerX 渐变中心点的横坐标 android:centerY 渐变的中心点的纵坐标，渐变中心点会影响渐变的具体效果。 android:startColor 渐变的开始颜色 android:centerColor 渐变的中间颜色 android:endColor 渐变的结束颜色 android:gradientRadius 渐变的半径，当android:type=”radial”有效 android:useLevel 一般为false android:type 渐变类别，linear(线性)为默认值，radial（径内渐变），sweep（扫描渐变） angle=0和angle=90的区别(都为线性渐变)： linear(线性)为默认值，radial（径内渐变），sweep（扫描渐变）区别如下： 到这里我们利用前面的介绍的知识点来实现一个环形进度圈的案例，我们将shape属性设置为ring（圆环），然后再设置其内半径以及环的厚度，并设置渐变色调，shape_drawable.xml代码如下： 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:innerRadius="20dp" android:shape="ring" android:thickness="8dp" android:useLevel="false" &gt; &lt;gradient android:angle="0" android:startColor="@color/normal" android:centerColor="#5027844F" android:endColor="#fff" android:useLevel="false" android:type="sweep" /&gt;&lt;/shape&gt;123456789101112131415 效果如下：接着，我们将该自定义环形圈设置给一个旋转动画，并利用该旋转动画自定义成一个环形进度圈的style，最后将该自定义的style赋值给Progress组件。代码如下：自定义旋转动画progress_rotate.xml： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;rotate xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@drawable/shape_drawable" android:pivotX="50%" android:pivotY="50%" android:fromDegrees="0" android:toDegrees="360" &gt;&lt;/rotate&gt;123456789 自定义Progress的style： 1234567&lt;style name="CustomProgressStyle" &gt; &lt;item name="android:indeterminateDrawable"&gt;@drawable/progress_rotate&lt;/item&gt; &lt;item name="android:minWidth"&gt;72dp&lt;/item&gt; &lt;item name="android:maxWidth"&gt;72dp&lt;/item&gt; &lt;item name="android:minHeight"&gt;72dp&lt;/item&gt; &lt;item name="android:maxHeight"&gt;72dp&lt;/item&gt;&lt;/style&gt;1234567 应用到Progress组件 1234567&lt;ProgressBar android:layout_width="100dp" android:layout_height="100dp" android:layout_centerInParent="true" style="@style/CustomProgressStyle" android:indeterminateDuration="700" /&gt;1234567 效果如下： 表示纯色填充，通过android:color设置颜色即可。 描述边框，属性如下： 属性 含义 android:width 描述边框的宽度，数值越大，越边框越厚 android:color 边框的颜色 android:dashWidth 组成虚线的线段宽度 android:dashGap 组成虚线的线段之间的间隔，间隔越大，虚线看起的间隙就越大 有点要明白的是android:dashWidth和android:dashGap有任意一个为0，则虚线无法预期显示。 表示内容或子标签边距，4个属性top、bottom、left、right，需要注意的是这个标签的作用是为内容设置与当前应用此shape的View的边距，而不是设置当前View与父元素的边距。 设置背景大小，width和height俩属性。一般来说这个值不是shape的最终显示大小，因为shape作为背景时会根据View的大小而填充其背景，因此Shape的大小很多时候是View的大小决定的。 到这里，shapeDrawable的基本属性我们都介绍完了，下面我们来实现一个比较常见的效果，我们在微信朋友圈点赞或者发布评论时总会出现一个红色带数字的小圆圈提示，嗯，我们就来模仿一下这个效果的实现,首先我们必须把shape属性设置为oval，并设置其纯填充颜色为红色，给一个临时大小宽高大小相同（之所以称为临时大小，是因为其最终大小由使用的View决定的），这样一个圆形背景图就出现啦。代码如下： 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" &gt; &lt;solid android:color="#D90E0E" /&gt; &lt;size android:height="10dp" android:width="10dp" /&gt;&lt;/shape&gt;1234567 接着应用到我们的TextView属性中 123456789&lt;TextView android:layout_width="30dp" android:layout_height="30dp" android:layout_centerInParent="true" android:gravity="center" android:textColor="#fff" android:text="99" android:background="@drawable/shape_circle_number" /&gt;123456789 最终效果如下： 实际上在开发中我们经常会利用shapeDrawable来自定义出所需要的各种背景图像或者显示图片，同时也有益于减少对美工图片的依赖，另外一个好处通过自定义shapeDrawable图片会比美工图片的size小很多，这样我们就能减少不必要的size，以减轻apk的size，可谓两全其美，因此能用shapeDrawable定义图像时，应该尽量使用它。 4、LayerDrawable 一个LayerDrawable是一个可以管理一组drawable对象的drawable。在LayerDrawable的drawable资源按照列表的顺序绘制，列表的最后一个drawable绘制在最上层。LayerDrawable对于xml的标签是其语法如下： 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-listxmlns:android="http://schemas.android.com/apk/res/android" &gt;&lt;item android:drawable="@[package:]drawable/drawable_resource" android:id="@[+][package:]id/resource_name" android:top="dimension" android:right="dimension" android:bottom="dimension" android:left="dimension" /&gt;&lt;/layer-list&gt;1234567891011 一个layer-list可以包含多个item，而每个item则表示一个Drawable。下面我们来说明一下item的一些属性android:id 资源ID，一个为这个item定义的唯一的资源ID。 使用:”@+id/name”.这样的方式。可以检索或修改这个drawable通过下面的方式：View.findViewById() or Activity.findViewById().android:top Integer，Drawable相对于View的顶部的偏移量，单位像素android:right Integer，Drawable相对于View的右边的偏移量，单位像素android:bottom Integer，Drawable相对于View的底部的偏移量，单位像素android:left Integer，Drawable相对于View的左边的偏移量，单位像素android:drawable Drawable资源，可以引用已有的drawable资源，也可在item中自定义Drawable。默认情况下，layer-list中的Drawable都会被缩放至View的大小，因此在必要的情况下，我们可以使用android:gravity属性来控制图片的展示效果，防止图片变形或者被过度拉伸。 下面我们来利用layer-list的叠层效果实现一个文本输入框的底部横线背景。xml 代码如下： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;shape android:shape="rectangle"&gt; &lt;solid android:color="@color/colorAccent" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:bottom="6dp"&gt; &lt;shape android:shape="rectangle"&gt; &lt;solid android:color="#ffffff"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:bottom="2dp" android:left="2dp" android:right="2dp"&gt; &lt;shape android:shape="rectangle"&gt; &lt;solid android:color="#ffffff" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt;12345678910111213141516171819202122 应用到EditText上的代码： 123456&lt;EditText android:layout_width="200dp" android:layout_height="wrap_content" android:layout_centerInParent="true" android:background="@drawable/layer_drawable" /&gt; 123456 上面代码比较简单，我们就不过的分析，接着我们再利用标签来实现一个带阴影的圆角矩形，layer_list_drawable_2.xml代码如下： 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!-- 灰色阴影 内容距离左边2dp，距离顶部4dp--&gt; &lt;item android:left="2dp" android:top="4dp"&gt; &lt;shape&gt; &lt;solid android:color="@android:color/darker_gray" /&gt; &lt;corners android:radius="10dp" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!-- 白色前景 内容距离底部4dp 右边2dp--&gt; &lt;item android:bottom="4dp" android:right="2dp"&gt; &lt;shape&gt; &lt;solid android:color="#FFFFFF" /&gt; &lt;corners android:radius="10dp" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt;123456789101112131415161718192021 效果如下： 当然我们也可以在代码中实现这里仅给出示例，不深究，还是建议采用xml的方式定义 123456789101112Bitmap bitmap=BitmapFactory.decodeResource(getResources(), R.drawable.image1);Drawable[] drawables=new Drawable[3];drawables[0]=new BitmapDrawable(bitmap);drawables[1]=new BitmapDrawable(bitmap);drawables[2]=new BitmapDrawable(bitmap);LayerDrawable layer=new LayerDrawable(drawables);//设置图层边界距离layer.setLayerInset(0, 20, 20, 0, 0);layer.setLayerInset(1, 40, 40, 0, 0);layer.setLayerInset(2, 60, 60, 0, 0);ImageView imageView=(ImageView)findViewById(R.id.imgView);imageView.setImageDrawable(layer);123456789101112 这样我们的带阴影的圆角矩形就出来啦，可以将其作为其他View的背景使用，美工也就不用提供类似的图了，到这里我们应该已经体会带巧用各种Drawable的威力了。 5、StateListDrawable StateListDrawable对于xml的标签，这个标签可以说是我们最常用的标签了，在开发中，有时候我们需要一个View在点击前显示某种状态，而在点击后又切换到另外一种状态，这时我们就需要利用标签来实现啦。如下案例，我们在点击输入邮件地址前文本框底线是灰色，而在点击后文本框底线就变成蓝色了，这也是标签的应用之一。 StateListDrawable本身也是表示Drawable的集合，每个Drawable就对于View的一种状态，如上面的灰色底线和蓝色底线对应着View的两种V不同时期的状态，因此我们经常使用StateListDrawable来设置View的背景，以便在不同状态下显示不同的效果，从而获得更优的用户体验。其主要语法如下： 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android" android:constantSize=["true" | "false"] android:dither=["true" | "false"] android:variablePadding=["true" | "false"] &gt; &lt;item android:drawable="@[package:]drawable/drawable_resource" android:state_pressed=["true" | "false"] android:state_focused=["true" | "false"] android:state_hovered=["true" | "false"] android:state_selected=["true" | "false"] android:state_checkable=["true" | "false"] android:state_checked=["true" | "false"] android:state_enabled=["true" | "false"] android:state_activated=["true" | "false"] android:state_window_focused=["true" | "false"] /&gt;&lt;/selector&gt;1234567891011121314151617 item的属性介绍如下： 属性 含义 android:drawable 该状态下要显示的图像，可以是Drawable也可以是图片 android:state_pressed 表示是否处于被按下状态 android:state_focused 表示是否已得到焦点状态 android:state_hovered 表示光标是否停留在View的自身大小范围内的状态 android:state_selected 表示是否处于被选中状态 android:state_checkable 表示是否处于可勾选状态 android:state_checked 表示是否处于已勾选状态，一般用于CheckBox android:state_enabled 表示是否处于可用状态 android:state_active 表示是否处于激活状态 android:state_window_focused 表示是否窗口已得到焦点状态 selector标签的属性含义如下：android:constantSize StateListDrawable的固有大小是否随着其状态改变而改变，因为在状态改变后，StateListDrawable会切换到别的Drawable，而不同的Drawable其大小可能不一样。true表示大小不变，这时其固有大小是内容所有Drawable的固有大小的最大值。false则会随着状态改变而改变，默认值为falseandroid:variablePadding 表示 StateListDrawable的padding是否随状态的改变而改变，默认值为false，一般建议设置为false就行。android:dither 是否开启抖动效果，开启后可使高质量的图片在低质量的屏幕上仍然有较好的显示效果，一般建议开启，设置为true。接下来我们来看一个例子，按钮点击前后状态改变。代码如下： 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--获取焦点状态--&gt; &lt;item android:state_focused="true" android:drawable="@color/color_state" /&gt; &lt;!--按下状态--&gt; &lt;item android:state_pressed="true" android:drawable="@color/color_state" /&gt; &lt;!--默认状态下--&gt; &lt;item android:drawable="@color/normal" /&gt;&lt;/selector&gt;123456789101112131415 接着应用到button上： 123456789&lt;Button android:padding="8dp" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:text="Selector_State" android:textColor="#fff" android:background="@drawable/selector_drawable" /&gt;123456789 效果如下： 上面是通过颜色定义不同状态下的显示 效果，当然我们也可以利用shapeDrawable定义各种背景图像然后应用到StateListDrawable中，下面我们定义两个不同状态下的圆角矩形，并应用到button上shape_drawable_for_btn_normal.xml代码如下： 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle" &gt; &lt;solid android:color="@color/normal"&gt;&lt;/solid&gt; &lt;corners android:radius="8dp" /&gt;&lt;/shape&gt;1234567 shape_drawable_for_btn_press.xml代码如下： 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle" &gt; &lt;solid android:color="@color/color_state"&gt;&lt;/solid&gt; &lt;corners android:radius="8dp" /&gt;&lt;/shape&gt;1234567 selector_for_btn.xml代码如下： 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--获取焦点状态--&gt; &lt;item android:state_focused="true" android:drawable="@drawable/shape_drawable_for_btn_press" /&gt; &lt;!--按下状态--&gt; &lt;item android:state_pressed="true" android:drawable="@drawable/shape_drawable_for_btn_press" /&gt; &lt;!--默认状态下--&gt; &lt;item android:drawable="@drawable/shape_drawable_for_btn_normal" /&gt;&lt;/selector&gt;12345678910111213141516 应用到button上 123456789&lt;Button android:padding="8dp" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:text="Selector_State" android:textColor="#fff" android:background="@drawable/selector_for_btn" /&gt;123456789 最终效果如下：最后给出一个通过代码实现的案例给大家参考（建议尽量使用xml定义，代码定义比较复杂）： 123456789101112131415161718192021222324/** 设置Selector。 */ public static StateListDrawable newSelector(Context context, int idNormal, int idPressed, int idFocused, int idUnable) &#123; //相当于&lt;selector&gt;标签 StateListDrawable bg = new StateListDrawable(); Drawable normal = context.getResources().getDrawable(R.drawable.shape_drawable_for_btn_normal); Drawable pressed = context.getResources().getDrawable(R.drawable.shape_drawable_for_btn_press); Drawable focused =context.getResources().getDrawable(R.drawable.shape_drawable_for_btn_press); Drawable unable = context.getResources().getDrawable(R.drawable.shape_drawable_for_btn_unable); //设置每种状态下的Drawable显示 // View.PRESSED_ENABLED_STATE_SET bg.addState(new int[] &#123; android.R.attr.state_pressed, android.R.attr.state_enabled &#125;, pressed); // View.ENABLED_FOCUSED_STATE_SET bg.addState(new int[] &#123; android.R.attr.state_enabled, android.R.attr.state_focused &#125;, focused); // View.ENABLED_STATE_SET bg.addState(new int[] &#123; android.R.attr.state_enabled &#125;, normal); // View.FOCUSED_STATE_SET bg.addState(new int[] &#123; android.R.attr.state_focused &#125;, focused); // View.WINDOW_FOCUSED_STATE_SET bg.addState(new int[] &#123; android.R.attr.state_window_focused &#125;, unable); // View.EMPTY_STATE_SET bg.addState(new int[] &#123;&#125;, normal); return bg; &#125;123456789101112131415161718192021222324 6、LevelListDrawable LevelListDrawable对应于标签，也表示一个Drawable的集合，但集合中的每个Drawable都一个等级。根据不同等级，LevelListDrawable会切换到相应的Drawable。语法如下： 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;item android:drawable="@drawable/drawable_resource" android:maxLevel="integer" android:minLevel="integer" /&gt;&lt;/level-list&gt;12345678 属性说明如下： 属性 含义 android:drawable 该等级下需要展示的图片 android:maxLevel 该项所允许的最大level android:minLevel 该项所允许的最小level 实际上我们也很容易知道标签中的每个Item各表示一个Drawable，并有与之对应的等级，而等级则是由android:maxLevel和android:minLevel所决定的，其等级范围是0-10000，最小为0，默认值，最大则为10000，还是一样的做法，先来看一个案例： 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/image4" android:maxLevel="0" /&gt; &lt;item android:drawable="@drawable/image1" android:maxLevel="1" /&gt; &lt;item android:drawable="@drawable/image2" android:maxLevel="2" /&gt; &lt;item android:drawable="@drawable/image3" android:maxLevel="3" /&gt;&lt;/level-list&gt;123456789101112131415161718 我们定义了4个item，等级分别为0，1，2，3，它们都有与之对应的Drawable，然后我们在java代码中实现一个效果，每过2秒更好一个不同等级的图片，代码如下： 12345678910111213141516171819202122232425262728293031323334353637package com.zejian.drawble;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.widget.ImageView;public class MainActivity extends AppCompatActivity &#123; private static ImageView imageView; static Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; if(msg.what==1)&#123; imageView.getDrawable().setLevel(1); &#125;else if(msg.what==2)&#123; imageView.getDrawable().setLevel(2); &#125;else if(msg.what==3)&#123; imageView.getDrawable().setLevel(3); &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView=(ImageView)findViewById(R.id.image); imageView.setImageResource(R.drawable.level_list_drawable); imageView.setImageLevel(0); for (int i=1;i&lt;4;i++)&#123; handler.sendEmptyMessageDelayed(i,i*2000); &#125; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637 实现效果如下： 实际上我们还可以设置等级范围，当等级在某个范围内时去显示对应范围内的图片，这也是可以的。这个比较简单，这里就不演示了哈。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>新知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea条件断点]]></title>
    <url>%2F2019%2F11%2F07%2Fidea%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9%2F</url>
    <content type="text"><![CDATA[idea的条件断点超简单的使用方法，右键点击你的短点，即可出现条件短点设置，其中condition就是超好用的条件短点的判断语句，语句需要返回结果是bool类型的，可以使用： || &amp;&amp; | &amp; 来链接多个语句，并且可以访问断点所在的作用域里所有可用的变量或者方法。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse的常用15个快捷键]]></title>
    <url>%2F2019%2F10%2F28%2Feclipse%E7%9A%84%E5%B8%B8%E7%94%A815%E4%B8%AA%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[15 个 Eclipse 常用开发快捷键使用技巧 alt+? 或 alt+/：自动补全代码或者提示代码 ctrl+o：快速outline视图 ctrl+shift+r：打开资源列表 ctrl+shift+f：格式化代码 ctrl+e：快速转换编辑器 ctrl+page down 或 ctrl+page up： 选项卡之间快速切换 shift+enter 及 ctrl+shift+enter： 在当前行上或者下边创建空白。 Alt+方向键上下：上下行交换内容或把当前行内容把上或下移动 Control+Alt+方向上下键：复制高亮显示的一行或多行 ctrl+m：当前编辑页面窗口最大化 ctrl+/：自动注释当前行或者选择的多行 ctrl+shift+/：自动注释掉选择的代码块 ctrl+d：删除当前行 ctrl+shift+x 和 ctrl+shift+y ：英文字母大小写的转换 ctrl+shift+o：自动引入包和删除无用包]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编译运行过程详解]]></title>
    <url>%2F2019%2F10%2F23%2Fjava%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[java整个编译以及运行的过程相当繁琐，我就举一个简单的例子说明： Java程序从源文件创建到程序运行要经过两大步骤： 源文件由编译器编译成字节码（ByteCode）； 字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言 （ “semi-interpreted” language） 123456789101112131415161718192021class Animal &#123; private String name; public Animal(String name) &#123; super(); this.name = name; &#125; public void printName() &#123; System.out.println("Animal = " + this.name); &#125;&#125; public class Main &#123; public static void main(String[] args) &#123; Animal animal = new Animal("super_yc"); animal.printName(); &#125;&#125; 第一步（编译）： 创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，如果这个类所依赖的类还没有被编译， 编译器会自动的先编译这个所依赖的类，然后引用。如果java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报 “Cant found sysbol”的异常错误。 编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、 方法引用，成员变量引用等）；方法字节码中放的是各个方法的字节码。 第二步（运行）： java类运行的过程大概分为两个步骤：（1）类的加载 （2）类的执行。需要说明的一点的是：JVM主要在程序第一次运行时主动使用类的 时候，才会立即去加载。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到，不得不加载的时候，才加载进来，而且只加载一次！ 根据上面的程序，详解该程序运行的详细步骤： 在类路径下找到编译好的 java 程序中得到 Test.class 字节码文件后，在命令行上敲 java Test，系统就会启动一个 JVM 进程，JVM进程从classpath路径下找到一个名为Test.class的二进制文件，将Test.class文件中的类信息加载到运行时数据区的方法区中，这一过程叫做类的加载。（只有类信息在方法区中，才能创建对象，使用类中的成员变量） JVM 找到main方法的主函数入口， 持有一个指向当前类(Test)常量池的指针，而常量池中的第一项是发现是一个对Animal对象的符号引用，并且main方法中第一条指令是Animal animal = new Animal(“super_yc”)，就是让JVM创建一个Animal对象，但是方法区中还没有Animal类的类信息，于是JVM就要马上的加载Animal类，将Animal类信息放入到方法区中，于是JVM 以一个直接指向方法区 Animal类的指针替换了常量池中第一项的符号引用。 加载完Animal类的信息以后，JVM虚拟机就会在堆内存中为一个Animal类实例分配内存，然后调用其构造函数初始化Animal实例，这个实例持有指向方法区的Animal类的类型信息（其中包含有方发表，java动态绑定的底层实现）的引用。（animal指向了Animal对象的引用会自动的放在栈中，字符串常量”super_yc”会自动的放在方法区的常量池中，对象会自动的放入堆区） 当使用 animal.pringName()的时候，JVM根据栈中animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型 信息方法表，获得pringName()函数的字节码地址，然后开始运行函数。 参考原文链接，以下做自己的整理备份]]></content>
      <categories>
        <category>java</category>
        <category>课件附页</category>
      </categories>
      <tags>
        <tag>课件附页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@Override浅认识]]></title>
    <url>%2F2019%2F10%2F22%2Fverride%E6%B5%85%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[@Override是伪代码,表示重写可以不写，不过写上有如下好处: 可以当注释用,方便阅读，可以很明显的看到哪些方法是重写的方法； 编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了，这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)。]]></content>
      <categories>
        <category>课件附页</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>课件附页</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面向对象-接口和其他的类]]></title>
    <url>%2F2019%2F10%2F12%2Fjava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[前言：听我讲课也就图一乐，要想真学到东西还是得自己看书。 大学学习最重要的莫过于是自学能力，我归纳的东西也许细节上有可能和书上有差异，因为我毕竟不是专业的，要想深究还是得对照书去看，我这只是对你们的一个引导。 万物皆可为对象那么对象与对象之间肯定不是独立的，上节课谢磊学长讲了类的继承，那是一种最广泛的关系。今天我们了解一点更加抽象一点的东西，但是只要大家认真听我想还是会有所明白。 先来吹吹概念小恐龙镇压，让学习不再困难： ！ 接口 接口最通俗的来讲就是一种统一的规范或者叫做协议，接口这个名称有点晦涩难懂，但是其实接口就是一个基于双方或者多方的协议 下面举几个例子： 你们用的插座的插孔可以被叫做接口（协议），因为这个规范存在，在中国无论你是什么充电器，只要是这个充电口，那么我就会给你输出电流，至于你充什么，干什么我都不管。 你去面试，他说你必须有本科及以上的文凭且必须过了四级才能有面试资格，这也算事接口（协议），因为如果你没有这些东西，就不能去面试，至于你是怎么努力学习拿到本科文凭和怎么努力拿到四级证书的，一律不管。 我今天布置了作业，我要收的是我布置的这些作业，至于你们每个人怎么去做出来我是不管的，那我布置的作业就是接口（协议），你们按照题目实现相应的功能就好，最后验收我也只会根据我布置的作业的应该输出的结果来看你是不是完成作业。（当然，当然我在作业文件中指出你不能用啥，我还是会看的具体细节的） 现在，接口你们应该都应该大致明白是什么了吧。 接口有什么作用？或者接口存在的必要性？ 还是上一节的例子，如果国家没有规定这个插座的标准，那每个厂家的有自己的一套，你买公牛的插座就得买支持公牛插座的电器。出去在中国其他地方旅游你就只有背着各式各样的转接头。嗯，锻炼身体也是好事嘛。 所以国家就制定了标准。 编程中接口也差不多，所以重要性也就凸显出来了 编程中的接口？ 场景案例： 现在开始你就是bat当中的员工之一，你的上级太多了，都要吩咐你做事： 大boss想要员工会帮他给买部手机 二boss想要员工会销售一套房子 三boss想要员工会帮忙搭讪小姐姐 四boss想要员工会跟他一起打游戏 ………….. 一共有不知道多少个boss，总之你是底层员工嘛。 那么问题来了，这个员工类究竟得怎么设计呢，真是一个难题，而且老板们想要叫这个员工去做事的时候怎么知道这个员工会呢？ 答案： 其实很简单，把这些行为统统抽象成接口。 例如： 定义下面一些接口： 1234&gt; public interface BuyCellPhone &#123;&gt; public void buycellphone();&gt; &#125;&gt; 1234&gt; public interface BuyHouse &#123;&gt; public void buyHouse();&gt; &#125;&gt; 1234&gt; public interface TrickGirl &#123;&gt; public void trickGirl();&gt; &#125;&gt; 1234&gt; public interface PlayingGamesTogether &#123;&gt; public void playingGameTogether();&gt; &#125;&gt; ………………………………………………………(此处还有无数个接口) 那么这些接口有什么用呢？ 对应的老板只需要认识熟悉的接口就好（意思是只认你是否实现了这个接口），在需要的时候调用方法就好了，而不需要去了解认识每一个人。下面以大老板为例： 首先必须的有一个实现了这个 12345678910111213141516171819&gt; /**&gt; * 实现了买手机这个功能接口的员工&gt; */&gt; public class Staff implements BuyCellPhone &#123;&gt; &gt; private String name;&gt; private String sex;&gt; &gt; public Staff(String name, String sex) &#123;&gt; this.name = name;&gt; this.sex = sex;&gt; &#125;&gt; &gt; @Override&gt; public void buycellphone() &#123;&gt; System.out.println("屁颠屁颠帮老板去买手机");&gt; &#125;&gt; &#125;&gt; 此时身为老板的只需要只需要这样一个方法，就可以找个员工帮他买手机了，并且他可以完全不用了解这个员工谁，到底是干啥的，但是至少这人是实现了这个接口，就说明是有这个能力的 1234&gt; public void lookingForSomeoneToBuyAMobilePhone(BuyCellPhone buyCellPhone) &#123;&gt; buyCellPhone.buycellphone();&gt; &#125;&gt; 抽象类我都叫抽象类了，你说我抽象不抽象，我觉得我比上面那玩意儿抽象，你说呢？ 黄坤坤告诉你到底有多抽象？抽象？我叫抽象类我就抽象啦？那hljj是jj吗？ 听听抽象类的自白 （抽象类独白）： ​ 天生就是用来被别人来继承的，简而言之，只有当爸爸的命，从不当儿子。可能有些事，必须得儿子去做，别直接叫我去做事。 ”只当爸爸“ 说明被继承是绝对需要，大部分抽象类都是没有完整实现类功能的类，等待子类继承去实现，所以它是不可以被实例化成对像的。 “有些事必须得儿子去做” 说明它可能存在方法是抽象的，必须得子类去具体实现。 “别直接叫我做事” 说明它是不可以直接示例化的。 好了，说完上面牵强的解释，现在我们来看看例子： 好了，开始开飞机了接口基本概念 接口，英文称作interface，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。在Java中，定一个接口的形式如下： 123public interface InterfaceName &#123;&#125; 需要注意的是: 接口中的变量会被隐式地指定为public static final变量 用其他关键词修饰会报错，例如： public static final，private 方法会被隐式地指定为public abstract方法且只能是public abstract方法 用其他关键词会报错，例如： private、protected、static、 final 接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。 可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。 回调可能初识这个名词觉得高大上和陌生，下面我仔细的讲解一下回调到底是什么呢？ 我在知乎上看到一个高赞回答： 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。 这个回答在我学习接口时就看到了，但是当时还是一知半解，下面我们用代码来解释一下。 首先我们定义一个接口Notify，通知接口 123public interface Notify &#123; public void call();&#125; 我们定义一个Shop类 123456789101112131415161718public class Shop &#123; private Notify notify; public void registrationNoticeMethod(Notify notify) &#123; this.notify = notify; &#125; public void tellCustomerOutOfStock() &#123; System.out.println("对不起，我们这没有货了"); &#125; public void arrivalNotice() &#123; if (notify != null) &#123; notify.call(); &#125; &#125;&#125; 定义一个顾客类Customer，并且让顾客类实现Notify这个接口 123456789101112public class Customer implements Notify &#123; long phoneNum = 1234567; @Override public void call() &#123; System.out.println("打电话给" + phoneNum + "通知到货了"); &#125; public void goShopping() &#123; System.out.println("出门购物"); &#125;&#125; 主程序： 12345678910111213141516171819202122232425262728 /** * 主函数 */public class Main &#123; public static void main(String[] args) &#123; //实例化对象 Customer customer = new Customer(); Shop shop = new Shop(); //顾客出门购物 customer.goShopping(); pause(); shop.tellCustomerOutOfStock(); pause(); shop.registrationNoticeMethod(customer); //第二天到货了 System.out.println("第二天"); shop.arrivalNotice(); &#125; /** * 这个函数不用在意，只是为了演示效果，增加暂停 */ private static void pause() &#123; new Scanner(System.in).nextLine(); &#125;&#125; 输出： 代码中的@Override注解说明点击进入 特殊的接口函数式接口 简单来说，就是只有一个方法的接口。 接口继承接口以及java8之后的接口多继承问题详细解释链接可能失效，我这里简述一下。 java中不是没有多继承吗？java8之前 是的，的确java中没有多继承，但是在java中接口是个例外，接口可以多继承，因为接口没有方法体，所以不论实现哪个父接口的中的方法都是没有关系的。 java8之后 java8之后出现了接口的默认实现，就像以下的模式： 12345public interface A &#123; default void hhh() &#123; System.out.println("我是B"); &#125;&#125; 12345public interface B &#123; default void hhh() &#123; System.out.println("我是C"); &#125;&#125; 如果有个接口继承前两个接口，就必须把冲突的方法重写 1234567public interface C extends A, B &#123; @Override default void hhh() &#123; &#125;&#125; 如果有个类同时实现这两个接口也需要实现冲突默认方法 123456public class Test implements B, A &#123; @Override public void hhh() &#123; &#125;&#125; 抽象类定义 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 怎么使用抽象类声明12345678910111213/** * 普通的类 */public class Test&#123; &#125;/** * 抽象类 */public abstract class Test &#123;&#125; 声明一个java抽象类只需要在正常的类的class之前加上abstract 抽象方法声明123abstract class A &#123; public abstract void a();&#125; 使用时需要注意的： 抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。 12345678910111213&gt; /**&gt; * 生物抽象类（因为没有一个具体的实体可以是生物，所以应该被抽象为更高的抽象类）&gt; */&gt; public abstract class Biological &#123;&gt; public void alive() &#123;&gt; &gt; &#125;&gt; &gt; public void death() &#123;&gt; &gt; &#125;&gt; &#125;&gt; 1234567&gt; /**&gt; * 人类，继承生物，可以没有自己的方法，全部是从抽象类继承的非抽象方法（注意：抽象类中有抽象方法子类必须实现）&gt; */&gt; public class Person extends Biological &#123;&gt; &gt; &#125;&gt; 最重要的主程序来了，仔细看注释介绍 1234567891011&gt; /**&gt; * 主程序，以下只是演示，注释最重要&gt; */&gt; public class Main &#123;&gt; public static void main(String[] args) &#123;&gt; Biological biological = new Person();//初始化时将人类的对象赋值给生物的引用时可以的&gt; Person person = new Person();//生成一个人类的对象&gt; biological = person;//将人类的对象复制给生物的引用也是没问题&gt; &#125;&gt; &#125;&gt; 抽象方法必须由子类来进行重写。 抽象类 12345678910111213141516&gt; /**&gt; * 生物类&gt; */&gt; public abstract class Biological &#123;&gt; &gt; public abstract void getEnergy();//增加了获取能量这个抽象方法&gt; &gt; public void alive() &#123;&gt; &gt; &#125;&gt; &gt; public void death() &#123;&gt; &gt; &#125;&gt; &#125;&gt; 人类 1234567891011&gt; /**&gt; * 人类，继承生物，继承了两个非抽象方法，并实现了抽象方法&gt; */&gt; public class Person extends Biological &#123;&gt; &gt; @Override&gt; public void getEnergy() &#123;//实现的抽象抽象方法&gt; &gt; &#125;&gt; &#125;&gt; 只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。 抽象类中可以包含具体的方法，当然也可以不包含抽象方法。 123456/** * 有抽象方法的抽象类 */public abstract class A &#123; public abstract void a();&#125; 12345678/** * 没有抽象方法的抽象类 */public abstract class B &#123; public void a() &#123; &#125;&#125; 子类中的抽象方法不能与父类的抽象方法同名。 abstract不能与final并列修饰同一个类。 这个显而易见，既然是抽象的，就必须需要时需要被子类实现的，所以不可能时final abstract 不能与private、static、final或并列修饰同一个方法。 private:抽象方法，必须是需要被继承的实现的，所以不可以用私有修饰符修饰 static：同样，抽象方法是需要被实现的，但是静态方法是不可以被重写 final：同上 抽象类和接口的区别语法层面上的区别 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法（在java8的之后接口）； 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的； 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 设计层面上的区别 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。 抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是“的关系，而 接口 实现则是 “有没有“的关系。 如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？ ？ 最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 实际的例子下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念： 123456789/** * 门的抽象类 */public abstract class DoorAbstract &#123; public abstract void open(); public abstract void close();&#125; 或者： 123456789/** * 门的接口 */public interface DoorInterface &#123; public void open(); public void close();&#125; 但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路： 将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能； 将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。 很明显这个属性放到以上任何一个的当中都是不合适的，但是报警又是一个比较广泛的属性，java不支持多继承，所以最好将这个方法抽象到一个接口里面，这就是所谓的对行为抽象： 123456/** * 报警的接口，所有实现了这个接口的类都是有报警这个功能 */public interface Alarm &#123; public void alarm();&#125; 然后在对这个可以报警的门进行封装： 1234567891011121314151617181920/** * 可以报警的门 */public class AlarmDoor extends DoorAbstract implements Alarm &#123; @Override public void alarm() &#123; &#125; @Override public void open() &#123; &#125; @Override public void close() &#123; &#125;&#125; 这里其中有个注解@Override我简单说明一下（至于注解是啥，不详细的讲解了下节课会讲到）： @Override是伪代码,表示重写可以不写，不过写上有如下好处: 可以当注释用,方便阅读，可以很明显的看到哪些方法是重写的方法； 编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了，这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)。 对于这里而言第二个作用是没有作用的，因为如果继承了抽象类，如果抽象类中含有抽象方法，必须实现这个方法不然编译器也会报错，接口也是同样的，前面说到接口中的方法默认是public abstract。 内部类 顾名思义：可以将一个类的定义放在另一个类的定义内部，这就是内部类。 怎么用？12345678910/** * 类中定义类 */public class A &#123; class B &#123; &#125;&#125; 好了，你现在已经会了内部类了，你看多简单呐 好了开玩笑的啦。 内部类小飞机为什么要使用内部类？​ 在《Think in java》也就是《java编程思想》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 ​ 在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。 完了上面这么简单的描述还听不懂 ，听不懂没关系，这样说我也不懂，来慢慢分析。 123public interface Father &#123;&#125; 123public interface Mother &#123;&#125; 接下来骚操作来了： 你可以这样子 123public class Son implements Father, Mother &#123;&#125; 也可以这样子 123456public class Daughter implements Father&#123; class Mother implements Mother&#123; &#125;&#125; 但是，不是一个类可以实现多个接口嘛，第二种实现还有什么意义呢。 那么问题来了，如果爸爸妈妈他们不是接口而是一个抽象类或者类呢？现在应该理解更为深刻了。 内部类基础.this和.new语法 当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。 内部类如何访问外围类的东西呢？ 当然直接用变量名就可以访问啦 原因？（凡事要解释得通才行嘛） 其实在内部类对象中保存了一个对外部类对象的引用，当在内部类的成员方法中访问某一变量时，如果在该方法和内部类中都没有定义过这个变量，（如果有这个变量的话，或者外部类的某个成员变量与内部类的成员变量相同eg:在内部类中定义 private String name; 那么访问的则是内部类的这个变量）调用就会被传递给内部类中的那个对外部类对象的引用，通过这个引用去调用这个变量。在内部类调用外部类的方法也是同样的一个道理（还是这个内部类对象保存了一个对外部类的引用）。 内部类如何获取外围类的对象呢？（.this） 这样子： 12345678910111213&gt; /**&gt; * 内部类示例&gt; */&gt; public class A &#123;&gt; String s = "";&gt; &gt; class B &#123;&gt; public void lala() &#123;&gt; A a = A.this; //关键的地方&gt; &#125;&gt; &#125;&gt; &#125;&gt; 如何创建内部类的对象呢？ 在外围类内 123456789101112131415&gt; /**&gt; * 内部类示例&gt; */&gt; public class A &#123;&gt; String s = "";&gt; &gt; public void lala() &#123;&gt; B b = new B(); //关键的地方&gt; &#125;&gt; &gt; class B &#123;&gt; &gt; &#125;&gt; &#125;&gt; 在外围类外（也就是在其他地方）：（.new） 123&gt; A a = new A();&gt; A.B b = a.new B();&gt; 到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为A的外围类和一个名为B的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。 关于java编译运行有兴趣了解自己了解（之前不是很多同学用命令行javac 和 java命令嘛） 内部类的分类成员内部类 成员内部类中不能存在任何static的变量和方法； 成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。 例子： 12345678910/** * 类中定义类 */public class A &#123; class B &#123; &#125;&#125; 对就是这种最简单的内部类 局部内部类 嵌套在方法或者作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题 嵌套在方法中很简单，直接在方法里面写类嘛，到那时嵌套在作用域里面怎么回事，这说明直接随便在一个类中随便找个位置，写个大括号，大括号中中也是可以写局部内部类的 例如：（这个简单例子可能有点绕） 1234567891011&gt;/**&gt; * 含有局部内部类的类B&gt; */&gt;class B&#123;&gt; &#123; //这是一个静态代码块&gt; class C&#123; //这是一个局部内部类，作用域就在静态代码块中&gt; &gt; &#125;&gt; &#125;&gt;&#125;&gt; 通常是想创建一个类来辅助我们的解决方案，但那时又不希望这个类是公共可用的，所以就产生了局部内部类 局部内部类和成员内部类一样被编译，只是它的作用域发生了改变 它只能在该方法和属性中被使用，出了该方法和属性就会失效 首先为了方便，我门先定义一个接口： 123456/** * 口接口A */interface A&#123; &#125; 下面开始正式的例子： 可以返回局部内部类实例化对象的函数（下面有个类B，里面有个方法返回A的引用，并且函数体里面有个实现了接口A的局部内部类C） 1234567891011/** * 含有局部内部类的类B */class B&#123; public A lala() &#123; class C implements A&#123; &#125; return new C(); &#125;&#125; 你可以直接这样子定义然后在方法中使用（作用域在方法内） 123456789101112/** * 含有局部内部类的类B */class B&#123; public void lala() &#123; class C &#123; &#125; C c = new C(); &#125;&#125; 匿名内部类咋写？首先定义一个接口，一个抽象类，和一个简单的类 123456/** * 我是一个冷漠无情的简单接口A */public interface A &#123; public void a();&#125; 123456/** * 我是一个冷漠无情的简单抽象类B */public abstract class B &#123; public abstract void b();&#125; 12345678/** * 我是一个冷漠无情的超简单普通类 */public class C &#123; public void c() &#123; &#125;&#125; 好了，有了上面的基础，我们就来演示一下匿名内部类： 12345678910111213141516171819202122public class D &#123; public static void main(String[] args) &#123; new A() &#123;//继承接口A的匿名内部类 @Override public void a() &#123; &#125; &#125;; new B() &#123;//继承抽象类B的内部类 @Override public void b() &#123; &#125; &#125;; new C() &#123;//继承普通类C的匿名内部类 &#125;; &#125;&#125; 内部类的注意事项 匿名内部类是没有访问修饰符的。 new 匿名内部类，这个类首先是要存在的。如果我们将接口注释掉，就会出现编译出错。 例子同上第二个，如果不用B这个现有的接口的话例如这样子写，是会报错的： 1234567&gt; new () &#123;&gt; @Override&gt; public void b() &#123; //超级错误的写法，谁这样写谁要被打手板&gt; &gt; &#125;&gt; &#125;;&gt; java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final 你是啥意思呀，完全不懂你说的啥啊，这又是啥狗屁啊，小丁学长你在开啥飞机。 emmmmmmm，好的，那我们来举例子 首先我们定义一个接口，做准备。 1234567&gt; /**&gt; * 我是一个冷漠无情的简单接口A&gt; */&gt; public interface A &#123;&gt; public void a();&gt; &#125;&gt; 然后我门再写一个普通类B，后面修改B来挨个测试 1234567891011121314151617&gt; /**&gt; * 我是一个冷漠无情的简单类B&gt; */&gt; public class B &#123;&gt; int a = 0;&gt; public void b() &#123;&gt; int b = 0;&gt; new A() &#123;&gt; @Override&gt; public void a() &#123;&gt; &gt; &#125;&gt; &#125;;&gt; &gt; &#125;&gt; &#125;&gt; 首先我们测试在方法里面的内部类，这个也是我们最常用的。我们在内部类实现的方法里面直接输出b看并且不把变量b设置为final 1234567891011121314151617&gt; /**&gt; * 冷漠无情的简单类B我又来了&gt; */&gt; public class B &#123;&gt; int a = 0;&gt; public void b() &#123;&gt; int b = 0;&gt; new A() &#123;&gt; @Override&gt; public void a() &#123;&gt; System.out.println(b);//编译是能通过的，不会报错的&gt; &#125;&gt; &#125;;&gt; &gt; &#125;&gt; &#125;&gt; 是不是讲错了，咋不需要变量b咋不需要final就能通过，翻车了。 百度谷歌一番，我找到这样一句话。 emmm，那究竟是不是这样子呢？再来康康？我们这次在上面那个内部类直接修改变量b的值。看可不可以呢。 1234567891011121314151617&gt; /**&gt; * 我是一个冷漠无情的简单类B&gt; */&gt; public class B &#123;&gt; int a = 0;&gt; public void b() &#123;&gt; int b = 0;&gt; new A() &#123;&gt; @Override&gt; public void a() &#123;&gt; b = 99; //关键部位（也是报错部位）&gt; &#125;&gt; &#125;;&gt; &gt; &#125;&gt; &#125;&gt; 编译之后，果然报错了，错误如下： 安心了，我们继续开飞机： 下面这两个用法，我估计你今后写10万行代码都遇不上一次这样写的，但是为了验证以上话是正确的，我们得试试。 第二项测试，在匿名内部类中类的静态代码块使用外部作用域里面的变量（因为是java有自动final修饰我们下面几次测试都使用直接更改外部作用域变量来测试【即：直接更改变量b的值】） 1234567891011121314151617181920&gt; /**&gt; * 我是一个冷漠无情的简单类B,我又出现了&gt; */&gt; public class B &#123;&gt; int a = 0;&gt; public void b() &#123;&gt; int b = 0;&gt; new A() &#123;&gt; &#123;&gt; b = 99; //关键部分&gt; &#125;&gt; @Override&gt; public void a() &#123;&gt; &gt; &#125;&gt; &#125;;&gt; &gt; &#125;&gt; &#125;&gt; 好的我来编译一下 好的继续报错，而且还是这个错，nice说明，那句话更加正确了，java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final 那么接下来我们来测试最后一项测试，我们在匿名内部类中访问外围类中的属性，看能不能修改 1234567891011121314151617&gt; /**&gt; * 我是一个冷漠无情的简单类B,我又出现了&gt; */&gt; public class B &#123;&gt; int a = 0;&gt; public void b() &#123;&gt; int b = 0;&gt; new A() &#123;&gt; @Override&gt; public void a() &#123;&gt; a = 99; //关键部分（没报错）&gt; &#125;&gt; &#125;;&gt; &gt; &#125;&gt; &#125;&gt; 编译一下，没错？运行一下，没有报错？woc，emmmmmm， 找找原因，于是我们在再在B类中添加一个普通内部类，如下： 12345678910111213141516171819202122&gt; /**&gt; * 我是一个的简单类B,这次我可不简单了&gt; */&gt; public class B &#123;&gt; int a = 0;&gt; public void b() &#123;&gt; int b = 0;&gt; new A() &#123; //匿名内部类&gt; @Override&gt; public void a() &#123;&gt; a = 99;&gt; &#125;&gt; &#125;;&gt; &#125;&gt; &gt; class C &#123; //简单内部类C&gt; public void c() &#123;&gt; &gt; &#125;&gt; &#125;&gt; &#125;&gt; 前面我们说了，找找原因，为啥没有报错，前面我们说内部类基础得时候，我们说是内部类是持有外围类得引用的，所以会智能的可以直接使用外围类的成员属性。 我们编译B类，然后出现了如下文件： 咦，难道匿名内部类也会储存外围类的引用🐎，是不是我们具体来康康。 我们先来看看B类编译之后反编译的代码 123456789101112131415161718192021222324&gt; public class B &#123;&gt; int a = 0;&gt; &gt; public B() &#123;&gt; &#125;&gt; &gt; public void b() &#123;&gt; int b = false;&gt; A var10001 = new A() &#123;&gt; public void a() &#123;&gt; B.this.a = 99;&gt; &#125;&gt; &#125;;&gt; &#125;&gt; &gt; class C &#123;&gt; C() &#123;&gt; &#125;&gt; &gt; public void c() &#123;&gt; &#125;&gt; &#125;&gt; &#125;&gt; 没有太大的区别，唯一的区别就是变量b，原本的0的值变成了布尔类型，这是为啥呢？ 还问为啥？是要我开火箭嘛，这篇课件不是因为“为啥”会有13000+的字嘛？？你仔细想想，写个程序要那么多为什么吗？？您好要的。最简单的来说这是编译器的一个优化，你这个值没有使用，为啥要给你要存一个整形，整形相对于布尔类型还是蛮大的，自己康康，整整四倍呢。。。。。。 类型 存储需求 bit 数 取值范围 备注 int 4字节 4*8 -2147483648~2147483647 即 (-2)的31次方 ~ (2的31次方) - 1 short 2字节 2*8 -32768~32767 即 (-2)的15次方 ~ (2的15次方) - 1 long 8字节 8*8 即 (-2)的63次方 ~ (2的63次方) - 1 byte 1字节 1*8 -128~127 即 (-2)的7次方 ~ (2的7次方) - 1 float 4字节 4*8 float 类型的数值有一个后缀 F（例如：3.14F） double 8字节 8*8 没有后缀 F 的浮点数值（例如：3.14）默认为 double boolean 1字节 1*8 true、false char 2字节 2*8 Java中，只要是字符，不管是数字还是英文还是汉字，都占两个字节。 再来看看B$C.class，验证是否持有外围类的引用 123456789&gt; class B$C &#123;&gt; B$C(B this$0) &#123;&gt; this.this$0 = this$0;&gt; &#125;&gt; &gt; public void c() &#123;&gt; &#125;&gt; &#125;&gt; 嗯，作为内部类，持有外围类的应用，正解。这里只能看到外围类的引用传进来了，那系统是怎么使用的呢？ 保存和使用是jvm级别的事，这里就详细讲了，我还没怎么看呢。 好的关键部分了，我们再来看看B$1.class反编译的结果 12345678910&gt; class B$1 implements A &#123;&gt; B$1(B this$0) &#123;&gt; this.this$0 = this$0;&gt; &#125;&gt; &gt; public void a() &#123;&gt; this.this$0.a = 99;&gt; &#125;&gt; &#125;&gt; 看到没有，匿名内部类也是会保存外围类的引用的 好了这下说明我上面那句话是对的，nice，那么问题又来了。 为什么一定要是final？？？你们吐血没？？反正我吐了 好的，我们来讲 那么又来了一个名词，“闭包” 闭包是什么呢？来听听大牛的说的他认为最通俗易懂的答案： 一个依赖于外部环境自由变量的函数 这个函数能够访问外部环境里的自由变量 哦豁， 还是不明白，好的，那么你继续听我慢慢分析 首先我们定义一个接口，做准备准备工作。 不准备了，不准备了，自己百度看教程吧，再准备这课件起码到20000字了。 这里附两个java中的final讲解 闭包讲解其实分为java8之前之后 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。 咦，上面不是反编译之后有构造方法吗？ 不对不对，我这说的是使用内部类的时候，不能有构造方法，你都直接，反编译时出现的构造方法是系统在你生成匿名内部类对象时默认调用的构造方法，因为再怎么它也是个类嘛，还是有类的尊严的。 【内部类自白】：怎么人家成为你对象也是条件的嘛，没有构造方法怎么行 静态内部类 非静态内部类在编译完成之后会隐含地保存着一个引用 它的创建是不需要依赖于外围类的 它不能使用任何外围类的非static成员变量和方法。 git链接在手，天下你有，自己去详细学习吧： 史上最浅显易懂的Git教程！ 概念工作区（Working Directory）是我们直接编辑的地方，例如 idea 打开的项目，记事本打开的文本等，肉眼可见，直接操作。 暂存区（Stage 或 Index）数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。 版本库（commit History）存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程仓库了。 常用命令讲解Git 常用命令汇总1、远程仓库相关命令 检出仓库：$ git clone [remoteName] 查看远程仓库：$ git remote -v 添加远程仓库：$ git remote add [name] [url] 删除远程仓库：$ git rm [name] 修改远程仓库：$ git remote set-url –push [name] [newUrl] 拉取远程仓库：$ git pull [remoteName] [localBranchName] 推送远程仓库：$ git push [remoteName] [localBranchName] 如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下： $ git push origin test:master // 提交本地test分支作为远程的master分支 $git push origin test:test // 提交本地test分支作为远程的test分支 2、分支(branch)操作相关命令 查看本地分支：$ git branch 查看远程分支：$ git branch -r 创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支 1git branch test 切换分支：$ git checkout [name] 1git checkout test 创建新分支并立即切换到新分支：$ git checkout -b [name] 1git checkout -b test 删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项 12345git branch -d test#orgit branch -D test 合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并 创建远程分支(本地分支push到远程)：$ git push origin [name] 删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name] 创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔) $git symbolic-ref HEAD refs/heads/[name] $rm .git/index $git clean -fdx 3、版本(tag)操作相关命令 查看版本：$ git tag 创建版本：$ git tag [name] 删除版本：$ git tag -d [name] 查看远程版本：$ git tag -r 创建远程版本(本地版本push到远程)：$ git push origin [name] 删除远程版本：$ git push origin :refs/tags/[name] 合并远程仓库的tag到本地：$ git pull origin –tags 上传本地tag到远程仓库：$ git push origin –tags 创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’ 4、忽略一些文件、文件夹不提交.gitignore文件详解 附页： Git 常用命令速查 git branch 查看本地所有分支 git status 查看当前状态 git commit 提交 git branch -a 查看所有的分支 git branch -r 查看远程所有分支 git commit -am “init” 提交并且加注释 git remote add origin git@192.168.1.119:ndshow git push origin master 将文件给推到服务器上 git remote show origin 显示远程库origin里的资源 git push origin master:develop git push origin master:hb-dev 将本地库与服务器上的库进行关联 git checkout –track origin/dev 切换到远程dev分支 git branch -D master develop 删除本地库develop git checkout -b dev 建立一个新的本地分支dev git merge origin/dev 将分支dev与当前分支进行合并 git checkout dev 切换到本地dev分支 git remote show 查看远程库 git add . git rm 文件名(包括路径) 从git中删除指定文件 git clone git://github.com/schacon/grit.git从服务器上将代码给拉下来 git config –list 看所有用户 git ls-files 看已经被提交的 git rm [file name] 删除一个文件 git commit -a 提交当前repos的所有的改变 git add [file name] 添加一个文件到git index git commit -v 当你用－v参数的时候可以看commit的差异 git commit -m “This is the message describing the commit” 添加commit信息 git commit -a -a是代表add，把所有的change加到git index里然后再commit git commit -a -v 一般提交命令 git log 看你commit的日志 git diff 查看尚未暂存的更新 git rm a.a 移除文件(从暂存区和工作区中删除) git rm –cached a.a 移除文件(只从暂存区中删除) git commit -m “remove” 移除文件(从Git中删除) git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除) git diff –cached 或 $ git diff –staged 查看尚未提交的更新 git stash push 将文件给push到一个临时空间中 git stash pop 将文件从临时空间pop下来 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ git remote add origin it@github.com:username/Hello-World.git git push origin master 将本地项目给提交到服务器中 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ git pull 本地与服务器端同步 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。 git push origin server fix:awesome branch －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ git fetch 相当于是从远程获取最新版本到本地，不会自动merge git commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ： git branch branch_0.1 master 从主分支master创建branch_0.1分支 git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0 git checkout branch_1.0/master 切换到branch_1.0/master分支 du -hs git branch 删除远程branch git push origin:branch_remote_name git branch -r -d branch_remote_name －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ 初始化版本库，并提交到远程服务器端 mkdir 新建一个文件夹，一个空格后接你的文件夹的名字 cd 进入你的名字 git init本地初始化 touch README git add README添加文件 git commit -m ‘first commit’ git remote add origin git@github.com:daixu/WebApp.git增加一个远程服务器端 细讲我怕又是几小时 ，下面我给你们简单介绍几个常用命令，也就是我门作业会用到的。也是今后我们用到最多的。 github注册链接在手，天下你有，自己去注册吧：github注册链接 好了现在你们什么都有了，你就是一个成熟的程序员的了 接下来我们来偷懒你觉得上面的git命令复杂可以先不看，github里面新建工程啥的太麻烦可以先不看。 打开你神奇的idea，并打开你的项目 假如现在你要上传你的项目到你的github，你只需要 点 点 点 这一步如果你还没登陆的话会要求你登陆，我这已经登陆了所以直接弹出了这个框，点击share就会帮你在本地执行git init git add . git add remote 你的github里面创建仓库并把你的整个工程传上去，一把梭爽不爽 爽 好了正式开始你的程序员生活了，如何拉网络去你仓库的更新呢？只需 点 点 ** **点 其实拉取对现阶段的你们还没啥用，毕竟远程的就是你本地的本地提交的，但是你和别人合作开发的时候就需要拉取了，为啥呢，因为可能他改了之后提交到远程了呀，你需要更新本地到远程的最新版 那如何提交呢？ 只需要 点 点 点 中间那个大框框里写你这次提交描述，点击下面的，commit就会提交到本地的版本库，你要是想提交到版本库之后直接把代码更新到远程github的仓库里，右边那个小三角，然后commit and push，提交到本地时同时上传远程，会出现，如下页面： 点击push就可以了。 那么问题来了，要是你就想直接commit在本地，等今天工作完了，再push到远程呢？只需 点 点 点 好了 ，现在为止你已经会了基本的git操作，是不是超简单。 好了我来学习更多的git操作，对你自己说，”我 。 才 。 不 。 要 。 记 。 命 。 令。“ 假如你现在突发奇想有另外一个想法，想创建一个测试分支，来写那个功能，咋啦呢？ 只需 点 点 点 点击最下面的git 就能唤出这个窗口，这个英文应该大家都能看懂吧，这个英文看不懂就退群吧，思考一下怎么上大学几个月就把高中英语忘完了。 好了然后，你写了很多了，也提交了几次之后，你突然发现前面提交的那个有问题，不想提交了那咋办呢？ 只需点 点 点 那就退到你刚刚新提交的那个版本前面一个呗，例如我觉得test2有问题那我就右键点击test1，然后 这样你刚刚的修改的提交就没了，但是如果你选择的时mix的话，你的修改还是会在的，变成没有提交状态了，我来解释一下这四个选项。 soft重置版本库但是暂存区和工作区不会 mixed会充值版本库和暂存区，但是工作区还在 hard会重置版本库暂存区工作区（危险操作，但是找都是可以找回来的） keep重置所有的但是会保留文件 如果你完全不要本地的所有更改了，可以直接hard到最近一个commit（危险操作，虽然我经常做） 好了现在假如你完成了你突发奇想的功能感觉还不错，想把test分支合并到主分支要咋办呢？ 还是点 点 点 先切换回主分支 然后 点击test分支 这样就合并啦 这也太简单了吧]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>课件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh用法及命令]]></title>
    <url>%2F2019%2F10%2F07%2Fssh%E7%94%A8%E6%B3%95%E5%8F%8A%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[原文链接 什么是SSH？简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。这里只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。 中间人攻击SSH之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。 ssh的安装SSH分客户端openssh-client和openssh-server 如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudoapt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server。 Ubuntu缺省已经安装了ssh client。 #配置ssh#1234567891011121314151617181920212223echo -e "\033[31;1m ******************************* \033[0m"echo -e "\033[31;1m ************安装和配置ssh************ \033[0m"sudo apt-get install -y openssh-server 1&gt; /dev/nullsudo sed -i 's/UsePAM no/UsePAM yes/g' /etc/ssh/sshd_configsudo sed -i '8a /etc/init.d/ssh start' /etc/profilesudo /etc/init.d/ssh startps -e | grep sshecho -e "\033[31;1m ssh授权 \033[0m"cd ~/.ssh/ssh-keygen -t rsacat ./id_rsa.pub &gt;&gt; ./authorized_keys $ ps -e|grep ssh 2151 ? 00:00:00 ssh-agent 5313 ? 00:00:00 sshdssh-agent表示ssh-client启动，sshd表示ssh-server启动了。如果缺少sshd，说明ssh服务没有启动或者没有安装。 SSH基本用法SSH远程登录口令登录假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。 1$ ssh user@host 如：ssh pika@192.168.0.111 如果本地用户名与远程用户名一致，登录时可以省略用户名。 1$ ssh host SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。 1$ ssh -p 2222 user@host 上面这条命令表示，ssh直接连接远程主机的2222端口。如果你是第一次登录对方主机，系统会出现下面的提示： 12345$ ssh user@hostThe authenticity of host 'host (12.18.429.21)' can't be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)? 这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。假定经过风险衡量以后，用户决定接受这个远程主机的公钥。 Are you sure you want to continue connecting (yes/no)? yes系统会出现一句提示，表示host主机已经得到认可。 Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.然后，会要求输入密码。 Password: (enter password)如果密码正确，就可以登录了。当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。 如果本地用户名与远程用户名一致，登录时可以省略用户名。 1$ ssh host SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。 1$ ssh -p 2222 user@host 上面这条命令表示，ssh直接连接远程主机的2222端口。如果你是第一次登录对方主机，系统会出现下面的提示： 123The authenticity of host 'host (12.18.429.21)' can't be established. RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d. Are you sure you want to continue connecting (yes/no)? 这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。假定经过风险衡量以后，用户决定接受这个远程主机的公钥。​ Are you sure you want to continue connecting (yes/no)? yes系统会出现一句提示，表示host主机已经得到认可。​ Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.然后，会要求输入密码。​ Password: (enter password)如果密码正确，就可以登录了。当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。 公钥登录使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个： 1$ ssh-keygen 运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。这时再输入下面的命令，将公钥传送到远程主机host上面： 1$ ssh-copy-id user@host 好了，从此你再登录，就不需要输入密码了。如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。 123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 然后，重启远程主机的ssh服务。 12# ubuntu系统service ssh restart 12# debian系统/etc/init.d/ssh restart authorized_keys文件远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程： 1$ ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub 这条命令由多个语句组成，依次分解开来看： “$ ssh user@host”，表示登录远程主机； 单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令： “$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个； ‘cat &gt;&gt; .ssh/authorized_keys’ &lt; /.ssh/id_rsa.pub的作用是，将本地的公钥文件/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。写入authorized_keys文件后，公钥登录的设置就完成了。 然后，重启远程主机的ssh服务。 1234# ubuntu系统service ssh restart# debian系统/etc/init.d/ssh restart authorized_keys文件远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程： 1$ ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub 这条命令由多个语句组成，依次分解开来看：（1）”$ ssh user@host”，表示登录远程主机；（2）单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：（3）”$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；（4）’cat &gt;&gt; .ssh/authorized_keys’ &lt; /.ssh/id_rsa.pub的作用是，将本地的公钥文件/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。写入authorized_keys文件后，公钥登录的设置就完成了。 [SSH原理与运用（一）：远程登录] 使用ssh在远程后台不中断地跑程序Linux关闭ssh（关闭终端等）后运行的程序或者服务自动停止，如python3 a.py &amp;。 解决：使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行。 1nohup python3 a.py &amp; [linux进程管理与SELinux] ssh连接中断如果使用的是iTerm2，要让ssh不断线： profiles -&gt; sessions -&gt; When idel, send ASCII code 其它命令行客户端，通过配置 ServerAliveInterval 来实现，在 ~/.ssh/config 中加入： ServerAliveInterval=30。表示ssh客户端每隔30秒给远程主机发送一个no-op包，no-op是无任何操作的意思，这样远程主机就不会关闭这个SSH会话。 vim ~/.ssh/config，然后新增 Host * ServerAliveInterval 6060秒就好了，而且基本去连的机器都保持，所以配置了*，如果有需要针对某个机器，可以自行配置为需要的serverHostName。 [ssh保持连接不断开] SSH远程操作SSH数据传输SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。 $ ssh user@host ‘mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。下面看几个例子。【例1】将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。 $ cd &amp;&amp; tar czv src | ssh user@host ‘tar xz’【例2】将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。 $ ssh user@host ‘tar cz src’ | tar xzv【例3】查看远程主机是否运行进程httpd。 $ ssh user@host ‘ps ax | grep [h]ttpd’ lz建议使用scp进行远程copy： scp 跨机远程拷贝scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限。 scp命令参数 -1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 scp一般有六种使用方法 本地复制远程文件：（把远程的文件复制到本地） scp root@www.test.com:/val/test/test.tar.gz /val/test/test.tar.gz远程复制本地文件：（把本地的文件复制到远程主机上） scp /val/test.tar.gz root@www.test.com:/val/test.tar.gz本地复制远程目录：（把远程的目录复制到本地） scp -r root@www.test.com:/val/test/ /val/test/远程复制本地目录：（把本地的目录复制到远程主机上） scp -r ./ubuntu_env/ root@192.168.0.111:/home/pipi pika:/media/pika/files/machine_learning/datasets$scp -r SocialNetworks/ piting@192.168.0.172:/media/data/pipi/datasets 本地复制远程文件到指定目录：（把远程的文件复制到本地） scp root@www.test.com:/val/test/test.tar.gz /val/test/远程复制本地文件到指定目录：（把本地的文件复制到远程主机上） scp /val/test.tar.gz root@www.test.com:/val/ ps: scp复制文件时只指定服务器地址不加路径默认复制到哪里??? [12个scp传输文件的命令栗子] [scp 跨机远程拷贝] SSH端口操作绑定本地端口既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写： $ ssh -D 8080 user@hostSSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。 本地端口转发有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）。假定host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。我们在host1执行下面的命令： $ ssh -L 2121:host2:21 host3命令中的L参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。 $ ftp localhost:2121“本地端口转发”使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH隧道”。下面是一个比较有趣的例子。 1$ ssh -L 5900:localhost:5900 host3 它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。另一个例子是通过host3的端口转发，ssh登录host2。 1$ ssh -L 9001:host2:22 host3 这时，只要ssh登录本机的9001端口，就相当于登录host2了。 1$ ssh -p 9001 localhost 上面的-p参数表示指定登录端口。 出错处理：ssh: Could not resolve hostname 192.168..:***: Name or service not known 解决：指定端口不能直接使用ip:端口号，使用-p参数来解决就可以了。 远程端口转发既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，”本地端口转发”就不能用了，怎么办？解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。我们在host3执行下面的命令： 1$ ssh -R 2121:host2:21 host1 R参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。绑定之后，我们在host1就可以连接host2了： 1$ ftp localhost:2121 这里必须指出，”远程端口转发”的前提条件是，host1和host3两台主机都有sshD和ssh客户端。 SSH的其他参数SSH还有一些别的参数，也值得介绍。N参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。 1$ ssh -NT -D 8080 host f参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。 1$ ssh -f -D 8080 host 要关闭这个后台连接，就只有用kill命令去杀掉进程。]]></content>
  </entry>
  <entry>
    <title><![CDATA[提取关键词后端api文档]]></title>
    <url>%2F2019%2F10%2F06%2F%E6%8F%90%E5%8F%96%E5%85%B3%E9%94%AE%E8%AF%8D%E5%90%8E%E7%AB%AFapi%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[Api文档baseUrl：host:port/lihkg 以下所有链接均需要加上baseUrl 测试baseUrl：http://39.108.208.114/lihkg 配置文件config.json配置文件 12345&#123; "filePath" : "C:\\data\\IdeaUProjects\\lihkg\\data", "outputPath" : "C:\\data\\IdeaUProjects\\lihkg\\outData"&#125; filePath ：数据存放目录，所有需要解析的文件需要放到这个目录，请根据实际情况设置绝对路径 outputPath：解析后文件输出目录，所有解析完成的数据都会存放到这个地方，请根据实际情况设置绝对路径 注意： 输出文件夹权限必须为所有用户可写 初始化接口 url：/resolve 说明： 访问该接口会把数据目录里面所有的文件进行解析，数据文件夹务必全部放所需要解析的文件，不可放文件夹，否则可能解析失败，解析完成会把解析完成的数据放置在输出目录,解析完成会有返回，根据服务器不同解析成功时间不同，不建议在主线程执行。 json格式： 123456789&gt;//失败&gt;&#123;&gt; &quot;tip&quot;: &quot;no data file,please check&quot;&gt;&#125;&gt;//成功&gt;&#123;&gt; &quot;tip&quot;: &quot;success resolve&quot;&gt;&#125;&gt; 数据获取接口 url：/keyword （关键词解析数据） url：/organization (组织解析数据) url：/place （地名解析数据） 参数 ：（以上三个接口参数均如下） key value single true\false 不加参数默认为false，返回数据会根据文件将关键词分开，true将把所有关键词统一返回，不区分文件 json格式： 1234567891011121314151617181920212223242526272829303132&gt;//not single&gt;&#123;&gt; "code": "404",&gt; "status": "false",&gt; "message": [&gt; [&gt; "发团队",&gt; "派发团队",&gt; "本团队所"&gt; ],&gt; ……&gt; ……&gt; ……&gt; ……&gt; ]&gt;&#125;&gt;&gt;//single&gt;&#123;&gt; "code": "404",&gt; "status": "false",&gt; "message": [&gt; "发团队",&gt; "派发团队",&gt; "本团队所"，&gt; ……，&gt; ……，&gt; ……，&gt; ……&gt; ]&gt;&#125;&gt; 注意 src文件夹下的config.json需要单独配置，请在打包前在请根据你服务器的文件目录更改ResolveServlet.java行的configPath属性为你部署之后的配置文件的绝对路径。 例： 1static String configPath = "C:\\data\\IdeaUProjects\\lihkg\\src\\config.json"; 打包部署完毕后请将配置文件放在你上一步填写的路径上 github自行提取：github链接]]></content>
      <categories>
        <category>文档</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git push 解决 弹出用户名和密码输入框]]></title>
    <url>%2F2019%2F10%2F04%2Fgit-push-%E8%A7%A3%E5%86%B3-%E5%BC%B9%E5%87%BA%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%2F</url>
    <content type="text"><![CDATA[首先查看你的远程仓库版本12345git remote -v result：origin https://github.com/username/username.github.io.git (fetch)origin https://github.com/username/username.github.io.git (push) 若你没有添加别人的仓库，通常只有这两个 重新设置对应远程仓库成ssh的方式:123git remote rm origingit remote add origin git@github.com:username/repository.gitgit push -u origin master]]></content>
      <categories>
        <category>Git学习备忘</category>
      </categories>
      <tags>
        <tag>知识就是力量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.gitignore忽略文件总结]]></title>
    <url>%2F2019%2F10%2F04%2Fgitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[语法归纳1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 表示此为注释,将被Git忽略*.a 表示忽略所有 .a 结尾的文件!lib.a 表示但lib.a除外/TODO 表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ 表示忽略 build/目录下的所有文件，过滤整个build文件夹；doc/*.txt 表示会忽略doc/notes.txt但不包括 doc/server/arch.txt bin/: 表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件/bin: 表示忽略根目录下的bin文件/*.c: 表示忽略cat.c，不忽略 build/cat.cdebug/*.obj: 表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj**/foo: 表示忽略/foo,a/foo,a/b/foo等a/**/b: 表示忽略a/b, a/x/b,a/x/y/b等!/bin/run.sh 表示不忽略bin目录下的run.sh文件*.log: 表示忽略所有 .log 文件config.php: 表示忽略当前路径的 config.php 文件 /mtk/ 表示过滤整个文件夹*.zip 表示过滤所有.zip文件/mtk/do.c 表示过滤某个具体文件 被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。 需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：!*.zip!/mtk/one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：/mtk/*!/mtk/one.txt 假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！ ----------------------------------------------------------------------------------还有一些规则如下：fd1/*说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； /fd1/*说明：忽略根目录下的 /fd1/ 目录的全部内容； /*!.gitignore!/fw/ /fw/*!/fw/bin/!/fw/sf/说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。 从版本库去除并忽略提交先执行以下任意删除命令123git rm file # 从版本库删除，并删除本地文件git rm --cached file # 从版本库删除文件并保留本地文件git rm -r --cached loggers # -r 是允许递归删除，当要删除的是文件夹的时候有用 在.gitignore文件中添加提醒.gitignore忽略规则的匹配语法每一行的忽略规则的语法如下： 空格不匹配任意文件，可作为分隔符，可用反斜杠转义 以“＃”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。 可以使用标准的glob模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。 以斜杠”/“开头表示目录；”/“结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；”/“开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。 以星号”**”通配多个字符，即匹配多个任意字符；使用两个星号”*“ 表示匹配任意中间目录，比如`a//z`可以匹配 a/z, a/b/z 或 a/b/c/z等。 以问号”?“通配单个字符，即匹配一个任意字符； 以方括号”[]“包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。 以叹号”!“表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用”!”规则是不起作用的。也就是说”!”开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用”!”也不会再次被包含。可以使用反斜杠进行转义。 需要谨记：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； .gitignore忽略规则的优先级在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）： 从命令行中读取可用的忽略规则 当前目录定义的规则 父级目录定义的规则，依次递推 $GIT_DIR/info/exclude 文件中定义的规则 core.excludesfile中定义的全局规则]]></content>
      <categories>
        <category>Git学习备忘</category>
      </categories>
      <tags>
        <tag>知识就是力量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行后台运行程序命令]]></title>
    <url>%2F2019%2F10%2F03%2Flinux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[后台执行命令：&amp;和nohup归纳：ps -ef或者grep查看进程kill XX杀死进程，XX替换为进程PID命令后加&amp;后台运行，但生命周期受窗口限制nohup 命令 &amp;完全后台运行原文链接，本文归纳梳理，便于自己记忆。 后台运行命令&amp;断开链接或者关闭窗口仍然会终止程序 在命令后面加上&amp; 实现后台运行。例如： 1sh test.sh &amp; 适合在后台运行的命令有find、费时的排序及一些shell脚本。 需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。 后台运行一样会将结果输出到屏幕上，干扰你的工作。 如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中 命令 &gt; out.file 2&gt;&amp;1 &amp; 1 这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。 当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它 (ps -ef | grep 进程号 或者 kill -9 进程号） nohup 可退出命令窗口使用 使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用 一但把当前控制台关掉(退出帐户时)，作业就会停止运行。 nohup命令可以在你退出帐户之后继续运行相应的进程。 nohup就是不挂起的意思( no hang up)。该命令的一般形式为： 1nohup 命令 &amp;1 如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件： 1nohup command &gt; myout.file 2&gt;&amp;1 &amp;1 注意使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。 ctrl + z可以将一个正在前台执行的命令放到后台，并且处于暂停状态。 ctrl+c终止前台命令。 jobs查看当前有多少在后台运行的命令。jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。 2&gt;&amp;1解析 1command &gt;out.file 2&gt;&amp;1 &amp;1 command&gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。 2&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行。 试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>知识就是力量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows脚本转移Linux上git命令出现错误]]></title>
    <url>%2F2019%2F10%2F03%2Fwindows%E8%84%9A%E6%9C%AC%E8%BD%AC%E7%A7%BBLinux%E4%B8%8Agit%E5%91%BD%E4%BB%A4%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[场景在我将整个hexo博客源码从windows10转移到linux（centos7）中时，脚本中的git命令没有例外的出现了这个错误 1234567git: 'pull' is not a git command. See 'git --help'. Did you mean one of these? pullgit: 'push' is not a git command. See 'git --help'. Did you mean one of these? push 这是什么人间疾苦，于是我Google，找到最接近的答案就是这个 https://stackoverflow.com/questions/1465398/git-pull-broken 这是十年前的一个issue，很明显不是这个问题。git早已经修正了这个issue。 那么问题来了，这到底是什么原因导致git认为你认为完全正确的命令是有问题的呢： 首先我保证绝对不是git版本的问题，我反复在服务器上更替了不同版本的git，无论是直接安装编译好的版本还是自己编译都多次尝试过，但是无一例外出错了。还是相同的错误。 其次脚本绝对是可运行的，在windows上可以正确无误的执行。 服务器镜像问题？没钱换服务器，况且服务器上运行了不少东西，不好更换，但我觉得的应该不是，其他脚本命令是可以运行的。 那到底是哪的问题呢？ 解决最后我几乎快完全丧失解决它的希望时，我进行了最后一次尝试。 用在linux vim重写脚本，发现在写的途中有些命令写出现和原来的颜色是不一样的 最后脚本运行成功。 所以千万别用windows10的记事本写代码，应该是编码的问题，还是建议用专业的编辑器写脚本]]></content>
      <categories>
        <category>错误记录</category>
      </categories>
      <tags>
        <tag>巨坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误记录：System limit for number of file watchers reached]]></title>
    <url>%2F2019%2F10%2F03%2FSystem-limit-for-number-of-file-watchers-reached-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[我在执行hexo server -d 时报错Error: ENOSPC: System limit for number of file watchers reached, watch ‘/root/blog/Treeeeeeee.github.io/blog/themes/inside/node_modules/hexo/lib/plugins/tag/index.js’ at FSWatcher.start (internal/fs/watchers.js:165:26) at Object.watch (fs.js:1258:11) at createFsWatchInstance (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:38:15) at setFsWatchListener (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:81:15) at FSWatcher.NodeFsHandler._watchWithNodeFs (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:233:14) at FSWatcher.NodeFsHandler._handleFile (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:262:21) at FSWatcher. (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:495:21) at FSReqWrap.oncomplete (fs.js:154:5) 文中说我达到文件监视程序数量的系统限制，不是很明白]]></content>
      <categories>
        <category>错误记录</category>
      </categories>
      <tags>
        <tag>不是特别坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+admin+windows服务器的综合博客平台]]></title>
    <url>%2F2019%2F10%2F03%2Fhexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[windows下的hexo+github博客搭建博客搭建不多说这里放上大神的知乎，点击自己按照流程来做就好了，下面我做一个归纳整理，也留作备份。 安装Node.js windows下载链接 下载之后一路next就好，环境变量默认会把帮你配好 最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。 也有没有自动配的情况，可以手动配一下。 添加国内镜像源 如果没有K X S W(这是啥大家都明白吧)的话，可以使用阿里的国内镜像进行加速。 12&gt; npm config set registry https://registry.npm.taobao.org&gt; 安装Git Git的下载链接 安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。 安装完成后在命令提示符中输入git --version验证是否安装成功。 同样如果没有找到版本号需要手动配置 注册Github账号 注册地址 注册完成之后进入主页 点击新建项目 项目名称是你的github用户名加.github.io 例如: XXXXX.github.io 同时也可以勾选一下Redme.md ![new p](C:\data\Treeeeeeee.github.io\blog\source_posts\hexo-admin-windows-服务器的综合博客平台\new p.png) 然后按照下面的流程你就可以获得一个最简单的博客 进去之后随便选一个 安装Hexo在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在D:\study\program\blog目录下。 在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。 定位到该目录下，输入npm i hexo-cli -g安装Hexo。会有几个报错，无视它就行。 安装完后输入hexo -v验证是否安装成功。 然后就要初始化我们的网站，输入hexo init初始化文件夹，接着输入npm install安装必备的组件。 这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以看到我们的博客啦，效果如下： 按ctrl+c关闭本地服务器。 连接Github与本地首先右键打开git bash，然后输入下面命令： 12git config --global user.name "godweiyang"git config --global user.email "792321264@qq.com" 用户名和邮箱根据你注册github的信息自行修改。 然后生成密钥SSH key： 1ssh-keygen -t rsa -C "792321264@qq.com" 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。 git bash中输入 1cat ~/.ssh/id_rsa.pub 将输出的内容复制到框中，点击确定保存。 输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了。 打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。 修改最后一行的配置： 1234deploy: type: git repo: branch: master repository或者repo修改为你自己的github项目地址 我这里默认的是使用ssh，如果想使用https点击更换就好了 我推荐使用ssh，毕竟你已经在你的github中添加了你本机的ssh，免得再输密码 如果不懂ssh可以先使用https，后面我们做服务器的自动git用ssh会更好，如果不需要，而且是在windows下使用的话那就https的吧，没啥关系，windows有记住密码的功能 写文章、发布文章首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。 然后输入hexo new post &quot;article title&quot;，新建一篇文章。 article title 替换成你要写的文章的名字，需要注意一下： 最好使用英文，使用中文的话博客的url会非常长 如果想插入图片的话，打开你的博客目录里面的_config.yml找到post_asset_folder:属性，并复制未true，这样生成一篇新文章时，会在 12&gt; \source\_posts&gt; 目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等。这样在文章中插入图片使用相对路径就可以即在本地书写的时候看到图片，又在生成的博客中看到，例如： 在文章中直接这样插入，就可以完美插入图片。详细可以借鉴我另外一篇博客 这里推荐一个超好用加方便的markdown编辑软件Typora，而且恰好支持这种图片资源文件，设置一下可以把任意来源图片直接弄到对应文件夹 这样设置以后你不管是从网络上来的图片还是任意地方拖动的进来的图片都会自动给你放到这个文件夹 然后打开D:\study\program\blog\source\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。 编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。 绑定域名现在默认的域名还是xxx.github.io，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。 以我的百度云为例，如下图所示，添加两条解析记录： 然后打开你的github博客项目，点击settings，拉到下面Custom domain处，填上你自己的域名，保存： 这时候你的项目根目录应该会出现一个名为CNAME的文件了。如果没有的话，打开你本地博客/source目录，我的是D:\study\program\blog\source，新建CNAME文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行hexo g、hexo d上传到github。 备份博客源文件有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。 我的备份方法 随便找个文件夹，右键打开git bash，依次执行以下命令 123&gt; git clone 你的博客仓库地址&gt; git checkout -b backup&gt; 然后删除你拉下来的所有东西文件夹，如果你开了隐藏文件夹也可见的话别把.git文件夹删除了，如果没开就放心删除所有文件吧（看见.git别动就对了） 然后把你你的整个博客文件夹移动到这里，并删除你博客文件下里面所有叫.gitignore的文件，通常来说，博客源码根目录有一个，主题文件夹里面都有 .gitignore文件是用来说明那些东西不被git push的，具体请自行百度 然后继续依次执行以下命令 1234&gt; git add .&gt; git commit -s -m &quot;backup&quot;&gt; git push&gt; 等待完成就可以在任何地方直接拉下来使用了，在其他地方使用有以下几个要注意的： 环境必须安装这个没得说 如果你是使用shh来部署的项目需要把这台设备的生成的ssh添加到你的github账号里 指的是你前面属性repo :是用的https的还是ssh的 其他备份方法(该内容是粘贴复制) 首先在github博客仓库下新建一个分支hexo，然后git clone到本地，把.git文件夹拿出来，放在博客根目录下。 然后git branch -b hexo切换到hexo分支，然后git add .，然后git commit -m &quot;xxx&quot;，最后git push origin hexo提交就行了。 博客源代码下载个性化设置（matery主题）常见问题及解答（FAQ）个性化设置|更换主题|效果图 我的博客地址有什么问题可以在文章下评论留言 inside主题 直接下载源码放到你的博客源码目录的themes目录里面，并修改_config.yml文件中theme:属性，然后执行： 12hexo ghexo s 浏览器访问：localhost:4000 就能直接看到效果了 具体配置我就不详细说明了可以去看主题制作者的博客：链接]]></content>
      <categories>
        <category>兴趣</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
        <tag>浪费了大好青春</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完美的hexo中插入图片的解决方案]]></title>
    <url>%2F2019%2F10%2F01%2Fhexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[完美的hexo中插入图片的解决方案以下内容来自ETRD的《hexo中完美插入本地图片》，摘录整理关键部分，留作备份。 Markdown编辑器 Typora 不需要关注太多markdown语法就能写出比较好看的markdown，支持实时转换 Hexo配置文件的设置 确保你的Hexo的配置文件_config.yml里面有个这个选项配置，并将其置为true 1post_asset_folder: true 这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用 1hexo new 生成一篇新文章时，会在 1\source\_posts 目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等 实际上我通常喜欢自己右键手动去建立一个md文件来写博客，而不使用hexo new命令，此时要达到同样的效果，我同样也需要手动去建立一个同名的文件夹去存放资源，我试过这样做是可行的，并且这样做虽然有点麻烦，但我似乎发现了它的一个优点，那就是当我的文章中没有图片时，我并不需要这个空的资源文件夹。 有了上面的配置，Hexo在public文件下生成html文件时，会在相应的目录中把那文章对应的资源文件夹中的图片等附件复制过去，例如，这是我生成的一个例子： 安装hexo-asset-image插件你需要安装一个图片路径转换的插件，这个插件名字是hexo-asset-image，我目前安装的是最新的0.03版本，使用如下命令安装插件 1npm install https://github.com/CodeFalling/hexo-asset-image --save 插件安装完以后，实际上是存放在下面的目录文件夹下 1\blog\node_modules\hexo-asset-image 想要卸载这个插件怎么处理，我听说直接删掉这个文件夹，反正我这么试过了。 md文件的时间标签hexo-asset-image的原理应该是根据Hexo生成html后以时间的为目录的规则，将我们图片的相对地址转换成了生成后与时间对应目录的绝对地址，因此我认为md文件中应该要有时间标签，一来是为了让Hexo根据md的时间标签来确定文章的新旧排序，如果没有时间标签，Hexo会把md文件的修改时间作为发布时间，这显然是不合理的，再者这个时间标签，我想hexo-asset-image也会引用到，在一篇实际的博文中，我的md文件完整的开头是这样的： 1---title: hexo中完美插入本地图片date: 2017-01-23 11:00:55categories: hexo使用tags: - hexo- 本地图片- hexo-asset-image--- 插入图片由于每个md文件都有对应的一个资源文件夹，因此，你首先要把需要插入的图片放到这个资源文件夹下，然后进行路径引用，这是上面插入图片时的实际引用代码 1![QQ截图20170123114005](/hexo中完美插入本地图片/QQ截图20170123114005.png) 使用Typora又有一个十分方便的地方在于，只需要将图片往这里一拖就插入了，但其实际拖入图片后的插入代码是绝对路径的引用，是这样的 1![QQ截图20170123114005](K:\FangCloudSync\Github博客源码\blog\source\_posts\hexo中完美插入本地图片\QQ截图20170123114005.png) 对比上面的两个代码，我只需要将前面的那段绝对路径删掉K:\FangCloudSync\Github博客源码\blog\source_posts ，然后再将剩余的两个\分别换成/ 就可以了 这样子，Typora编辑时同时能够看到插入的图片。 生成测试在很多网友的文章中，这么做就可以了，你可以尝试一下生成并本地测试，看看是否博客的首页及博文的正文页都能够正确显示图片，或者打开博文生成的html源文件，找到图片插入的地方看看src路径是否是对应public后的绝对路径，如下示例这样 1&lt;p&gt;&lt;img src=&quot;/2017/01/22/Windows下远程桌面连接树莓派3代/QQ截图20170122163331.png&quot; alt=&quot;QQ截图20170122163331&quot;&gt;&lt;/p&gt; 如果本地预览主页和博文正文页显示图片都没有问题，并且html源文件内的图片源地址是上面的格式，那你真幸运没有遇到什么麻烦。 生成绝对路径不完整的问题我发现我做了上面的工作后，生成并本地测试查看，图片并不能正确显示，我查看了html文件，它生成的路径是这样的 1&lt;p&gt;&lt;img src=&quot;/22/imagetest/500.jpg&quot; alt=&quot;500&quot;&gt;&lt;/p&gt; 看起来hexo-asset-image的确起了点作用，但似乎有点问题，它生成的绝对路径不完整，仿佛只获取了日，年月没获取到，因为这个md文件的时间是2017-01-22，所以”/2017/01” 似乎没有生成啊，对比上面正确正常的绝对路径，我不明白这是什么原因导致的，也许有可能是我使用的hexo懒人包导致的，Google了一晚上好像就我一个人有这种情况，最后我也在Github上向该插件的作者递交了我遇到的麻烦，但估计等到作者回复不知道是何时了。 今天早上，我受到自定义修改插件，更便捷的使用七牛空间 这篇文章的启发，决定自己也尝试修改插件代码试试能否解决。虽然完全不懂js代码，但还是尝试阅读了那段极其简练的代码，这是其中一段： 1var link = data.permalink;var beginPos = getPosition(link, &apos;/&apos;, 3) + 1;// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.var endPos = link.lastIndexOf(&apos;/&apos;) + 1; link = link.substring(beginPos, endPos); 可以猜测出来这段点大概是在获取博文生成的绝对路径，然后最后与md文件中的相对路径做一个拼接，但这个函数中 1var beginPos = getPosition(link, &apos;/&apos;, 3) + 1; 为什么是寻找第3个’/‘？虽然我不知道，但这样做肯定有作者的意图，只是我不懂其中的原理不理解，不可能这个关键的数字是错的。但我假设如果完整的路径应该是/2017/01/22，那么第3个/似乎正好是日期里面的日，跟我的html生成的不完整的路径点似乎有点关联，因此如果这个数字修改为1，那么是不是就能将/2017/01补上了，试试看吧，然而，幸运的是，成功了！ 1var beginPos = getPosition(link, &apos;/&apos;, 1) + 1;//just by launcher 小结需要插入本地图片，并让Hexo启用资源文件的功能，每个md文件对应一个资源文件夹，然而这只是方便了资源的管理，插入图片时不推荐使用hexo官方说的不伦不类的标签插入方法，因为编辑md文件时无法预览图片，而需要安装hexo-asset-image插件，这样正常使用markdown语法对图片的相对路径引用，即可实现编辑时可预览图片，且发布时插件自动将相对路径转为绝对路径。如果碰到与我同样的生成的绝对路径不完全的情况，尝试修改插件的js代码，但修改器建议先备份它，我认为我所解决我遇到问题的方法可能是一种巧合，但我暂时先这么使用了，最终的原因和处理方法可能还需要等待Github上该插件作者的官方回应。]]></content>
      <categories>
        <category>兴趣</category>
      </categories>
      <tags>
        <tag>hexo配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于酷q平台的管理机器人]]></title>
    <url>%2F2019%2F10%2F01%2F%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[酷Q机器人 自从samrtQQ下线之后，很多QQ机器人都失效了。 但是最近又比较想用这样一个机器人来管理减轻自己的一些工作，于是千方百计的我发现了酷Q。 这里附上官网链接 开发以及注意事项 SDK的选择酷q提供了多种SDK但是都是我不常用的，官方的支持的SDK是E语言，这语言emmmm好，都好，写，都可以写。虽然提供了java的sdk但是java版本始终不是正统，咬牙学了一天E语言，最后还是吐了。没办法，不习惯，没说E语言不好。害，最后还是选择的java版本。不过但是还没开始使用的时候我看到了更加好用的一个找到一个更加好用方便的SDK-PicqBotX，这是通过http的插件来与酷q的程序交互。虽然不能像官方网站上提供的那个那样可以直接打包成jar运行但是个人认为开发更加简单。 环境以及配置细节 这里讲得很清楚，以下说明几个坑： 如果使用kotlin代替java进行开发，请最好使用Gradle对项目进行管理，它对kotlin有更加完美的支持。 在介绍readme中的这个位置一定要看准，下载对应版本的工具，否则可能出问题，比较麻烦，而且没有提示难以排查。 两个端口号一定要对应于你程序中的机器人的端口号否则会链接失败（建议直接用默认的31091 31092，也可自己选择） 本人开发流程 使用idea新建项目选择gradle管理项目java版本任意，需要kotlin开发勾选kotlin 导包 导入最新的sdk。 根据需要复制示例代码更改 1234567891011121314151617181920212223242526272829303132public class TestBot&#123; public static void main(String[] args) &#123; // 创建机器人对象 ( 传入配置 ) PicqBotX bot = new PicqBotX(new PicqConfig(31092).setDebug(true)); // 添加一个机器人账户 ( 名字, 发送URL, 发送端口 ) bot.addAccount("Bot01", "127.0.0.1", 31091); // 注册事件监听器, 可以注册多个监听器 bot.getEventManager().registerListeners( new TestListener(), new RequestListener(), new ExceptionListener() ); // 启用指令管理器 // 这些字符串是指令前缀, 比如指令"!help"的前缀就是"!" bot.enableCommandManager("bot -", "!", "/", "~"); // 注册指令, 可以注册多个指令 bot.getCommandManager().registerCommands( new CommandSay(), new CommandTest(), new CommandVersion() ); // 启动机器人, 不会占用主线程 bot.startBot(); &#125;&#125; 个人实现效果和功能 通知功能 请假功能 有学生请假则会以json格式文本保存在服务器（或者本地） 导出请假表格文档，会直接给下载链接 补登请假 还有安卓端的管理app和网页版实时查看数据。 部署机器人在winows server上部署 太简单了，省略具体步骤，总结解释就是以下步骤： 电脑上安装上所有酷q，http插件，java所需要的环境，跟你的本地一样（本地会配置，我想server上配置也难不倒聪明的你） 打包你的机器人，可以是jar可以是其他的，只要是能够将你的代码打包运行就好 运行酷q，打开http插件，运行你的机器人。 在linux上部署 因为酷q是window程序，要想在linux上部署那就必须得使用docker（不知道docker是什么的请百度），由于不是专业运维方向对docker不是很了解，也踩了很多坑。 这里附上http插件的官方教程，里面有详细的描述如何安装最新的酷q的docker镜像，如果docker还没安装自行百度安装你的服务器的docker。 然后基本上和以上步骤都是差不多，但是有个地方需要注意 这里的上报地址，理所当然就是酷q接收到消息之后传递给你的程序去处理，但是在docker中利用127.0.0.1是访问的docker内部，而你的机器人程序并不是在docker内所以，酷q是无法将消息上报给你的机器人的，这里建议换成以下两种： 你的服务器ip：http://服务器ip:端口号 本地访问：http://host.docker.internal:端口号 只有这样酷q才能将消息上报到你的机器人处理。 用到的库 阿帕奇的表格框架 gson 通知管理机器人源代码地址：冷漠无情的机器人 因为源代码中有不少私人数据，所以取消。]]></content>
      <categories>
        <category>兴趣</category>
      </categories>
      <tags>
        <tag>世界这么大，当然要多去看看</tag>
      </tags>
  </entry>
</search>
