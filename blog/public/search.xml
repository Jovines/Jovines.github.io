<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>@Override浅认识</title>
      <link href="/2019/10/22/verride%E6%B5%85%E8%AE%A4%E8%AF%86/"/>
      <url>/2019/10/22/verride%E6%B5%85%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><code>@Override</code>是伪代码,表示重写可以不写，不过写上有如下好处: </p><ul><li>可以当注释用,方便阅读，可以很明显的看到哪些方法是重写的方法；</li><li>编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了，这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课件附页 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 课件附页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面向对象-接口和其他的类</title>
      <link href="/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/"/>
      <url>/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言：">前言：<a href="2019/10/12/java面向对象-接口和其他的类#前言："></a></h1><p><strong>听我讲课也就图一乐，要想真学到东西还是得自己看书。</strong></p><p><strong>大学学习最重要的莫过于是自学能力，我归纳的东西也许细节上有可能和书上有差异，因为我毕竟不是专业的，要想深究还是得对照书去看，我这只是对你们的一个引导</strong>。</p><p><strong>万物皆可为对象那么对象与对象之间肯定不是独立的，上节课谢磊学长讲了类的继承，那是一种最广泛的关系。今天我们了解一点更加抽象一点的东西，但是只要大家认真听我想还是会有所明白。</strong></p><h1 id="先来吹吹概念">先来吹吹概念 <img src="/2019/10/12/java面向对象-接口和其他的类/6af89bc8gw1f8tzvsvn8gj20a00a00tp.jpg" alt="这和吃饭时扶碗是一个概念" style="zoom:25%;"><a href="2019/10/12/java面向对象-接口和其他的类#先来吹吹概念"></a></h1><h2 id="接口">接口<a href="2019/10/12/java面向对象-接口和其他的类#接口"></a></h2><h3 id="什么是接口？">什么是接口？<a href="2019/10/12/java面向对象-接口和其他的类#什么是接口？"></a></h3><blockquote><p>接口最通俗的来讲就是一种统一的规范或者叫做协议，接口这个名称有点晦涩难懂，但是其实接口就是一个基于双方或者多方的协议</p><p>下面举几个例子：</p><ul><li>你们用的插座的插孔可以被叫做接口（协议），因为这个规范存在，在中国无论你是什么充电器，只要是这个充电口，那么我就会给你输出电流，至于你充什么，干什么我都不管。</li><li>你去面试，他说你必须有本科及以上的文凭且必须过了四级才能有面试资格，这也算事接口（协议），因为如果你没有这些东西，就不能去面试，至于你是怎么努力学习拿到本科文凭和怎么努力拿到四级证书的，一律不管。</li><li>我今天布置了作业，我要收的是我布置的这些作业，至于你们每个人怎么去做出来我是不管的，那我布置的作业就是接口（协议），你们按照题目实现相应的功能就好，最后验收我也只会根据我布置的作业的应该输出的结果来看你是不是完成作业。（当然，当然我在作业文件中指出你不能用啥，我还是会看的具体细节的）</li></ul><p>现在，接口你们应该都应该大致明白是什么了吧。</p></blockquote><h3 id="接口有什么作用？或者接口存在的必要性？">接口有什么作用？或者接口存在的必要性？<a href="2019/10/12/java面向对象-接口和其他的类#接口有什么作用？或者接口存在的必要性？"></a></h3><blockquote><p>还是上一节的例子，如果国家没有规定这个插座的标准，那每个厂家的有自己的一套，你买公牛的插座就得买支持公牛插座的电器。出去在中国其他地方旅游你就只有背着各式各样的转接头。嗯，锻炼身体也是好事嘛。</p><p>所以国家就制定了标准。</p><p>所以编程中接口的重要性也就凸显出来了</p></blockquote><h3 id="编程中的接口？">编程中的接口？<a href="2019/10/12/java面向对象-接口和其他的类#编程中的接口？"></a></h3><blockquote><p><strong>场景</strong>：</p><p>假设你已经是精通java的能人异士，这一天你的老板要你做个实现一个类，但是你的老板马上就要出差了，而且你老板还买不起手机，无法跟你交流。那么该怎么办呢？</p><p>答案：</p><p>老板设计一个接口，然后让员工实现这个接口。那么老板回来之后直接用员工写的东西就好。因为员工写的类实现老板设计的接口，那么就必须要有那些实现，至于员工到底怎么实现的，老板根本不用在意。</p></blockquote><h2 id="抽象类">抽象类<a href="2019/10/12/java面向对象-接口和其他的类#抽象类"></a></h2><p><strong>我都叫抽象类了，你说我抽象不抽象，我觉得我比上面那玩意儿抽象，你说呢？</strong></p><h3 id="黄坤坤告诉你到底有多抽象？"><img src="/2019/10/12/java面向对象-接口和其他的类/164336559DA3C001F7D365CBC0A67998.jpg" alt="164336559DA3C001F7D365CBC0A67998" style="zoom:25%;">  黄坤坤告诉你到底有多抽象？<a href="2019/10/12/java面向对象-接口和其他的类#黄坤坤告诉你到底有多抽象？"></a></h3><p><strong>抽象？我叫抽象类我就抽象啦？那hljj是jj吗？</strong></p><ul><li><p><strong>听听抽象类的自白</strong></p><p><strong>（抽象类独白）</strong>：</p><p>​        天生就是用来被别人来继承的，简而言之，只有当爸爸的命，从不当儿子。可能有些事，必须得儿子去做，别直接叫我去做事。</p></li><li><p>”<strong>只当爸爸</strong>“</p><p>说明被继承是绝对需要，大部分抽象类都是没有完整实现类功能的类，等待子类继承去实现，所以它是不可以被实例化成对像的。</p></li><li><p>“<strong>有些事必须得儿子去做</strong>”</p><p>说明它可能存在方法是抽象的，必须得子类去具体实现。</p></li><li><p>“<strong>别直接叫我做事</strong>”  </p><p>说明它是不可以直接示例化的。</p></li></ul><h3 id="好了，说完上面牵强的解释，现在我们来看看例子：">好了，说完上面牵强的解释，现在我们来看看例子：<a href="2019/10/12/java面向对象-接口和其他的类#好了，说完上面牵强的解释，现在我们来看看例子："></a></h3><p><img src="/2019/10/12/java面向对象-接口和其他的类/ceeb653ejw1fai8r9ct23j205c05q3yn.jpg" alt="爸爸在呢 有事快说 - 和爸爸斗图 斗图+表情_爸爸_斗图表情" class="article-img"></p><h1 id="好了，开始开飞机了">好了，开始开飞机了<a href="2019/10/12/java面向对象-接口和其他的类#好了，开始开飞机了"></a></h1><h2 id="接口-1">接口<a href="2019/10/12/java面向对象-接口和其他的类#接口-1"></a></h2><h3 id="基本概念">基本概念<a href="2019/10/12/java面向对象-接口和其他的类#基本概念"></a></h3><p> 接口，英文称作<strong>interface</strong>，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对<strong>行为</strong>的抽象。在Java中，定一个接口的形式如下： </p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>需要注意的是:</p><ul><li><p>接口中的变量会被隐式地指定为public static final变量 </p><blockquote><p>用其他关键词修饰会报错，例如：</p><ul><li><code>public static final</code>，<code>private</code></li></ul></blockquote></li><li><p>方法会被隐式地指定为public abstract方法且只能是public abstract方法 </p><blockquote><p>用其他关键词会报错，例如：</p><ul><li><code>private</code>、<code>protected</code>、<code>static</code>、 <code>final</code></li></ul></blockquote><p>接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。 </p><p>可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。 </p></li></ul><h3 id="回调">回调<a href="2019/10/12/java面向对象-接口和其他的类#回调"></a></h3><p>可能初识这个名词觉得高大上和陌生，下面我仔细的讲解一下回调到底是什么呢？</p><p><strong>我在知乎上看到一个高赞回答：</strong></p><blockquote><p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。</p></blockquote><p>这个回答在我学习接口时就看到了，但是当时还是一知半解，下面我们用代码来解释一下。</p><p>首先我们定义一个接口<code>Notify</code>，通知接口</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Notify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>我们定义一个<code>Shop</code>类</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Notify notify;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registrationNoticeMethod</span><span class="params">(Notify notify)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.notify = notify;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tellCustomerOutOfStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对不起，我们这没有货了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrivalNotice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (notify != <span class="keyword">null</span>) &#123;</span><br><span class="line">            notify.call();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>定义一个顾客类<code>Customer</code>，并且让顾客类实现<code>Notify</code>这个接口</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Notify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> phoneNum = <span class="number">1234567</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话给"</span> + phoneNum + <span class="string">"通知到货了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goShopping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出门购物"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>主程序：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 主函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实例化对象</span></span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">        Shop shop = <span class="keyword">new</span> Shop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//顾客出门购物</span></span><br><span class="line">        customer.goShopping();</span><br><span class="line">        pause();</span><br><span class="line">        shop.tellCustomerOutOfStock();</span><br><span class="line">        pause();</span><br><span class="line">        shop.registrationNoticeMethod(customer);</span><br><span class="line">        <span class="comment">//第二天到货了</span></span><br><span class="line">        System.out.println(<span class="string">"第二天"</span>);</span><br><span class="line"></span><br><span class="line">        shop.arrivalNotice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个函数不用在意，只是为了演示效果，增加暂停</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).nextLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>输出：</p><p><img src="/2019/10/12/java面向对象-接口和其他的类/TIM%E6%88%AA%E5%9B%BE20191022120614.png" alt="TIM截图20191022120614" class="article-img"></p><p><a href="2019/10/12/java面向对象-接口和其他的类#这里其中有个注解">代码中的@Override注解说明</a>点击进入</p><h3 id="特殊的接口">特殊的接口<a href="2019/10/12/java面向对象-接口和其他的类#特殊的接口"></a></h3><h3 id="接口继承接口以及java8之后的接口多继承问题">接口继承接口以及java8之后的接口多继承问题<a href="2019/10/12/java面向对象-接口和其他的类#接口继承接口以及java8之后的接口多继承问题"></a></h3><p><a href="https://colobu.com/2014/11/04/Java-8-default-method-and-multiple-inheritance/" target="_blank" rel="noopener">详细解释链接</a>可能失效，我这里简述一下。</p><h4 id="java中不是没有多继承吗？">java中不是没有多继承吗？<a href="2019/10/12/java面向对象-接口和其他的类#java中不是没有多继承吗？"></a></h4><p><strong>java8之前</strong></p><p>是的，的确java中没有多继承，但是在java中接口是个例外，接口可以多继承，因为接口没有方法体，所以不论实现哪个父接口的中的方法都是没有关系的。</p><p><strong>java8之后</strong></p><p>java8之后出现了接口的默认实现，就像以下的模式：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>如果有个接口继承前两个接口，就必须把冲突的方法重写</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>如果有个类同时实现这两个接口也需要实现冲突默认方法</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">B</span>, <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hhh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>那么问题来了</p><h2 id="抽象类-1">抽象类<a href="2019/10/12/java面向对象-接口和其他的类#抽象类-1"></a></h2><h3 id="定义">定义<a href="2019/10/12/java面向对象-接口和其他的类#定义"></a></h3><ul><li>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</li><li>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</li><li>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</li><li>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</li><li>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><h3 id="怎么使用">怎么使用<a href="2019/10/12/java面向对象-接口和其他的类#怎么使用"></a></h3><h4 id="抽象类声明">抽象类声明<a href="2019/10/12/java面向对象-接口和其他的类#抽象类声明"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>声明一个java抽象类只需要在正常的类的class之前加上<code>abstract</code></p><h4 id="抽象方法声明">抽象方法声明<a href="2019/10/12/java面向对象-接口和其他的类#抽象方法声明"></a></h4><h3 id="使用时需要注意的：">使用时需要注意的：<a href="2019/10/12/java面向对象-接口和其他的类#使用时需要注意的："></a></h3><ul><li><p>抽象类<strong>不能被实例化</strong>，实例化的工作应该交<strong>由它的子类来完成</strong>，它<strong>只需要有一个引用即可</strong>。</p><blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 生物抽象类（因为没有一个具体的实体可以是生物，所以应该被抽象为更高的抽象类）</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Biological</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">death</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 人类，继承生物，可以没有自己的方法，全部是从抽象类继承的非抽象方法（注意：抽象类中有抽象方法子类必须实现）</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Biological</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>最重要的主程序来了，仔细看注释介绍</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 主程序，以下只是演示，注释最重要</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;         Biological biological = <span class="keyword">new</span> Person();<span class="comment">//初始化时将人类的对象赋值给生物的引用时可以的</span></span><br><span class="line">&gt;         Person person = <span class="keyword">new</span> Person();<span class="comment">//生成一个人类的对象</span></span><br><span class="line">&gt;         biological = person;<span class="comment">//将人类的对象复制给生物的引用也是没问题</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote></li><li><p><strong>抽象方法</strong>必须<strong>由子类来进行重写</strong>。</p><blockquote><p><strong>抽象类</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 生物类</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Biological</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getEnergy</span><span class="params">()</span></span>;<span class="comment">//增加了获取能量这个抽象方法</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">death</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>人类</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 人类，继承生物，继承了两个非抽象方法，并实现了抽象方法</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Biological</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEnergy</span><span class="params">()</span> </span>&#123;<span class="comment">//实现的抽象</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote></li><li><p>只要<strong>包含一个抽象方法的抽象类</strong>，该方法<strong>必须要定义成抽象类</strong>，不管是否还包含有其他方法。</p></li><li><p>抽象类中<strong>可以包含具体的方法</strong>，当然<strong>也可以不包含抽象方法</strong>。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有抽象方法的抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有抽象方法的抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p>子类中的抽象方法<strong>不能</strong>与父类的抽象方法<strong>同名</strong>。</p></li><li><p><code>abstract</code>不能与<code>final</code>并列修饰同一个类。</p><blockquote><p>这个显而易见，既然是抽象的，就必须需要时需要被子类实现的，所以不可能时final</p></blockquote></li><li><p><code>abstract</code> 不能与<code>private</code>、<code>static</code>、<code>final</code>或并列修饰同一个方法。</p><blockquote><p><code>private</code>:抽象方法，必须是需要被继承的实现的，所以不可以用私有修饰符修饰</p><p><code>static</code>：同样，抽象方法是需要被实现的，但是静态方法是不可以被重写</p><p>final：同上</p></blockquote></li></ul><h2 id="抽象类和接口的区别">抽象类和接口的区别<a href="2019/10/12/java面向对象-接口和其他的类#抽象类和接口的区别"></a></h2><h3 id="语法层面上的区别">语法层面上的区别<a href="2019/10/12/java面向对象-接口和其他的类#语法层面上的区别"></a></h3><ul><li><strong>抽象类</strong>可以提供<strong>成员方法的实现细节</strong>，而<strong>接口</strong>中只能存在<strong>public abstract 方法</strong>；</li><li><strong>抽象类</strong>中的成员变量可以是<strong>各种类型</strong>的，而<strong>接口</strong>中的成员变量只能是<strong>public static final类型</strong>的；</li><li><strong>接口</strong>中<strong>不能含有静态代码块</strong>以及<strong>静态方法</strong>，而<strong>抽象类</strong>可以有<strong>静态代码块</strong>和<strong>静态方法</strong>；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><h3 id="设计层面上的区别">设计层面上的区别<a href="2019/10/12/java面向对象-接口和其他的类#设计层面上的区别"></a></h3><ul><li><p>抽象类是对一种<strong>事物的抽象</strong>，即<strong>对类抽象</strong>，而接口是<strong>对行为的抽象</strong>。</p></li><li><p>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</p></li><li><p>举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，<strong>继承</strong>是一个 “<strong>是不是</strong>“的关系，而 <strong>接口</strong> 实现则是 “<strong>有没有</strong>“的关系。</p></li><li><p>如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而<strong>接口实现则是有没有</strong>、<strong>具备不具备的关系</strong>，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p></li><li><p>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种模板式设计。什么是模板式设计？</p><blockquote><p> 最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p></blockquote></li></ul><h3 id="实际的例子">实际的例子<a href="2019/10/12/java面向对象-接口和其他的类#实际的例子"></a></h3><p>下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 门的抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DoorAbstract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>　　或者：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 门的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DoorInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>但是现在如果我们需要门具有<strong>报警alarm( )</strong>的功能，那么该如何实现？下面提供两种思路：</p><ul><li>将这三个功能都放在抽象类里面，但是这样一来<strong>所有继承于这个抽象类的子类都具备了报警功能</strong>，但是有的门并不一定具备报警功能；</li><li>将这三个功能都放在接口里面，需要用到<strong>报警功能的类就需要实现这个接口中的open( )和close( )</strong>，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</li></ul><p>很明显这个属性放到以上任何一个的当中都是不合适的，但是报警又是一个比较广泛的属性，java不支持多继承，所以最好将这个方法抽象到一个接口里面，这就是所谓的对行为抽象：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 报警的接口，所有实现了这个接口的类都是有报警这个功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>然后在对这个可以报警的们进行封装：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以报警的门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">DoorAbstract</span> <span class="keyword">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="这里其中有个注解">这里其中有个注解<a href="2019/10/12/java面向对象-接口和其他的类#这里其中有个注解"></a></h4><p>@Override我简单说明一下（至于注解是啥，不详细的讲解了下节课会讲到）：</p><p><code>@Override</code>是伪代码,表示重写可以不写，不过写上有如下好处: </p><ul><li>可以当注释用,方便阅读，可以很明显的看到哪些方法是重写的方法；</li><li>编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了，这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)。</li></ul><p>对于这里而言第二个作用是没有作用的，因为如果继承了抽象类，如果抽象类中含有抽象方法，必须实现这个方法不然编译器也会报错，接口也是同样的，前面说到接口中的方法默认是<code>public abstract</code>。</p><h2 id="内部类">内部类<a href="2019/10/12/java面向对象-接口和其他的类#内部类"></a></h2><p> 顾名思义：可以将一个类的定义放在另一个类的定义内部，这就是内部类。 </p><h3 id="怎么用？">怎么用？<a href="2019/10/12/java面向对象-接口和其他的类#怎么用？"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类中定义类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>好了，你现在已经会了内部类了，你看多简单呐     <img src="/2019/10/12/java面向对象-接口和其他的类/v2-8da4b48b8262d2786486cb942571be4c_hd.jpg" alt="img"></p><p>好了开玩笑的啦。</p><h3 id="内部类小飞机">内部类小飞机<a href="2019/10/12/java面向对象-接口和其他的类#内部类小飞机"></a></h3><h4 id="为什么要使用内部类？">为什么要使用内部类？<a href="2019/10/12/java面向对象-接口和其他的类#为什么要使用内部类？"></a></h4><p>​        在《Think in java》也就是《java编程思想》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 </p><p>​        在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p><p><img src="/2019/10/12/java面向对象-接口和其他的类/v2-acb2c980db4a235ed0538f34d9c2918d_hd-1571748707404.jpg" alt="img">完了上面这么简单的描述还听不懂 ，听不懂没关系，这样说我也不懂，来慢慢分析。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 课件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh用法及命令</title>
      <link href="/2019/10/07/ssh%E7%94%A8%E6%B3%95%E5%8F%8A%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/10/07/ssh%E7%94%A8%E6%B3%95%E5%8F%8A%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/pipisorry/article/details/52269785" target="_blank" rel="noopener">原文链接</a></p><h1 id="什么是SSH？">什么是SSH？<a href="2019/10/07/ssh用法及命令#什么是SSH？"></a></h1><p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。<br>SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。这里只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。</p><h2 id="中间人攻击">中间人攻击<a href="2019/10/07/ssh用法及命令#中间人攻击"></a></h2><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。<br>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。<br>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。<br>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。</p><h1 id="ssh的安装">ssh的安装<a href="2019/10/07/ssh用法及命令#ssh的安装"></a></h1><p>SSH分客户端openssh-client和openssh-server</p><p>如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudoapt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server。</p><p>Ubuntu缺省已经安装了ssh client。</p><h2 id="配置ssh">#配置ssh#<a href="2019/10/07/ssh用法及命令#配置ssh"></a></h2><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">echo -e "\033[31;1m ******************************* \033[0m"</span><br><span class="line">echo -e "\033[31;1m ************安装和配置ssh************ \033[0m"</span><br><span class="line">sudo apt-get install -y openssh-server 1&gt; /dev/null</span><br><span class="line">sudo sed -i 's/UsePAM no/UsePAM yes/g' /etc/ssh/sshd_config</span><br><span class="line">sudo sed -i '8a /etc/init.d/ssh start' /etc/profile</span><br><span class="line">sudo /etc/init.d/ssh start</span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line">echo -e "\033[31;1m ssh授权 \033[0m"</span><br><span class="line">cd ~/.ssh/</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">cat ./id_rsa.pub &gt;&gt; ./authorized_keys</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -e|grep ssh</span></span><br><span class="line"> 2151 ?        00:00:00 ssh-agent</span><br><span class="line"></span><br><span class="line"> 5313 ?        00:00:00 sshd</span><br><span class="line"></span><br><span class="line">ssh-agent表示ssh-client启动，sshd表示ssh-server启动了。</span><br><span class="line"></span><br><span class="line">如果缺少sshd，说明ssh服务没有启动或者没有安装。</span><br></pre></td></tr></table></div></figure><h1 id="SSH基本用法">SSH基本用法<a href="2019/10/07/ssh用法及命令#SSH基本用法"></a></h1><h2 id="SSH远程登录">SSH远程登录<a href="2019/10/07/ssh用法及命令#SSH远程登录"></a></h2><h3 id="口令登录">口令登录<a href="2019/10/07/ssh用法及命令#口令登录"></a></h3><p>假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host  如：ssh pika@192.168.0.111</span></span><br></pre></td></tr></table></div></figure><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh host</span></span><br></pre></td></tr></table></div></figure><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -p 2222 user@host</span></span><br></pre></td></tr></table></div></figure><p>上面这条命令表示，ssh直接连接远程主机的2222端口。<br>如果你是第一次登录对方主机，系统会出现下面的提示：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host</span></span><br><span class="line"></span><br><span class="line">The authenticity of host 'host (12.18.429.21)' can't be established.</span><br><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></div></figure><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？<br>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。<br>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。<br>    　　<code>Are you sure you want to continue connecting (yes/no)? yes</code><br>系统会出现一句提示，表示host主机已经得到认可。<br>    　　<code>Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.</code><br>然后，会要求输入密码。<br>    　　<code>Password: (enter password)</code><br>如果密码正确，就可以登录了。<br>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh host</span></span><br></pre></td></tr></table></div></figure><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -p 2222 user@host</span></span><br></pre></td></tr></table></div></figure><p>上面这条命令表示，ssh直接连接远程主机的2222端口。<br>如果你是第一次登录对方主机，系统会出现下面的提示：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host 'host (12.18.429.21)' can't be established.</span><br><span class="line">    　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">    　　Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></div></figure><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？<br>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。<br>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。<br>​    　　<code>Are you sure you want to continue connecting (yes/no)? yes</code><br>系统会出现一句提示，表示host主机已经得到认可。<br>​    　　<code>Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.</code><br>然后，会要求输入密码。<br>​    　　<code>Password: (enter password)</code><br>如果密码正确，就可以登录了。<br>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p><h3 id="公钥登录">公钥登录<a href="2019/10/07/ssh用法及命令#公钥登录"></a></h3><p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。<br>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen</span></span><br></pre></td></tr></table></div></figure><p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。<br>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。<br>这时再输入下面的命令，将公钥传送到远程主机host上面：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-copy-id user@host</span></span><br></pre></td></tr></table></div></figure><p>好了，从此你再登录，就不需要输入密码了。<br>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></div></figure><p>然后，重启远程主机的ssh服务。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu系统</span></span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debian系统</span></span><br><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></div></figure><p>authorized_keys文件<br>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。<br>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host <span class="string">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></div></figure><p>这条命令由多个语句组成，依次分解开来看：</p><ol><li>“$ ssh user@host”，表示登录远程主机；</li><li>单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：</li><li>“$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；</li><li>‘cat &gt;&gt; .ssh/authorized_keys’ &lt; <del>/.ssh/id_rsa.pub的作用是，将本地的公钥文件</del>/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。</li></ol><p>然后，重启远程主机的ssh服务。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ubuntu系统</span></span><br><span class="line">service ssh restart</span><br><span class="line"><span class="meta">#</span><span class="bash"> debian系统</span></span><br><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></div></figure><p>authorized_keys文件<br>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。<br>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host <span class="string">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></div></figure><p>这条命令由多个语句组成，依次分解开来看：（1）”$ ssh user@host”，表示登录远程主机；（2）单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：（3）”$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；（4）’cat &gt;&gt; .ssh/authorized_keys’ &lt; <del>/.ssh/id_rsa.pub的作用是，将本地的公钥文件</del>/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。</p><p>[SSH原理与运用（一）：远程登录]</p><p>使用ssh在远程后台不中断地跑程序<br>Linux关闭ssh（关闭终端等）后运行的程序或者服务自动停止，如python3 a.py &amp;。</p><p>解决：使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup python3 a.py &amp;</span><br></pre></td></tr></table></div></figure><p>[linux进程管理与SELinux]</p><h2 id="ssh连接中断">ssh连接中断<a href="2019/10/07/ssh用法及命令#ssh连接中断"></a></h2><p>如果使用的是iTerm2，要让ssh不断线： profiles -&gt; sessions -&gt; When idel, send ASCII code</p><p>其它命令行客户端，通过配置 ServerAliveInterval 来实现，在 ~/.ssh/config 中加入： ServerAliveInterval=30。表示ssh客户端每隔30秒给远程主机发送一个no-op包，no-op是无任何操作的意思，这样远程主机就不会关闭这个SSH会话。</p><p>vim ~/.ssh/config，然后新增</p><p>Host *<br>    ServerAliveInterval 60<br>60秒就好了，而且基本去连的机器都保持，所以配置了*，如果有需要针对某个机器，可以自行配置为需要的serverHostName。</p><p>[ssh保持连接不断开]</p><h2 id="SSH远程操作">SSH远程操作<a href="2019/10/07/ssh用法及命令#SSH远程操作"></a></h2><h3 id="SSH数据传输">SSH数据传输<a href="2019/10/07/ssh用法及命令#SSH数据传输"></a></h3><p>SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。<br>    　　$ ssh user@host ‘mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub<br>单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。<br>这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。<br>下面看几个例子。<br>【例1】<br>将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。<br>    　　$ cd &amp;&amp; tar czv src | ssh user@host ‘tar xz’<br>【例2】<br>将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。<br>    　　$ ssh user@host ‘tar cz src’ | tar xzv<br>【例3】<br>查看远程主机是否运行进程httpd。<br>    　　$ ssh user@host ‘ps ax | grep [h]ttpd’</p><p>lz建议使用scp进行远程copy：</p><p>scp 跨机远程拷贝<br>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限。</p><h3 id="scp命令参数">scp命令参数<a href="2019/10/07/ssh用法及命令#scp命令参数"></a></h3><ul><li>-1 强制scp命令使用协议ssh1</li><li>-2 强制scp命令使用协议ssh2</li><li>-4 强制scp命令只使用IPv4寻址</li><li>-6 强制scp命令只使用IPv6寻址</li><li>-B 使用批处理模式（传输过程中不询问传输口令或短语）</li><li>-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li><li>-p 留原文件的修改时间，访问时间和访问权限。</li><li>-q 不显示传输进度条。</li><li>-r 递归复制整个目录。</li><li>-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li><li>-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li><li>-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li><li>-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li><li>-l limit 限定用户所能使用的带宽，以Kbit/s为单位。</li><li>-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，</li><li>-P port 注意是大写的P, port是指定数据传输用到的端口号</li><li>-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li><li>scp一般有六种使用方法<ul><li>本地复制远程文件：（把远程的文件复制到本地）</li><li>scp <a href="mailto:root@www.test.com" target="_blank" rel="noopener">root@www.test.com</a>:/val/test/test.tar.gz /val/test/test.tar.gz<br>远程复制本地文件：（把本地的文件复制到远程主机上）</li><li>scp /val/test.tar.gz <a href="mailto:root@www.test.com" target="_blank" rel="noopener">root@www.test.com</a>:/val/test.tar.gz<br>本地复制远程目录：（把远程的目录复制到本地）</li><li>scp -r <a href="mailto:root@www.test.com" target="_blank" rel="noopener">root@www.test.com</a>:/val/test/ /val/test/<br>远程复制本地目录：（把本地的目录复制到远程主机上）</li><li>scp -r ./ubuntu_env/ <a href="mailto:root@192.168.0.111" target="_blank" rel="noopener">root@192.168.0.111</a>:/home/pipi</li><li>pika:/media/pika/files/machine_learning/datasets$scp -r SocialNetworks/ </li><li><a href="mailto:piting@192.168.0.172" target="_blank" rel="noopener">piting@192.168.0.172</a>:/media/data/pipi/datasets</li></ul></li><li>本地复制远程文件到指定目录：（把远程的文件复制到本地）</li><li>scp <a href="mailto:root@www.test.com" target="_blank" rel="noopener">root@www.test.com</a>:/val/test/test.tar.gz /val/test/<br>远程复制本地文件到指定目录：（把本地的文件复制到远程主机上）</li><li>scp /val/test.tar.gz <a href="mailto:root@www.test.com" target="_blank" rel="noopener">root@www.test.com</a>:/val/</li></ul><p>ps: scp复制文件时只指定服务器地址不加路径默认复制到哪里???</p><p>[12个scp传输文件的命令栗子]</p><p>[scp 跨机远程拷贝]</p><h2 id="SSH端口操作">SSH端口操作<a href="2019/10/07/ssh用法及命令#SSH端口操作"></a></h2><h3 id="绑定本地端口">绑定本地端口<a href="2019/10/07/ssh用法及命令#绑定本地端口"></a></h3><p>既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。<br>假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：<br>    　　$ ssh -D 8080 user@host<br>SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。</p><h3 id="本地端口转发">本地端口转发<a href="2019/10/07/ssh用法及命令#本地端口转发"></a></h3><p>有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）。<br>假定host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。<br>我们在host1执行下面的命令：<br>    　　$ ssh -L 2121:host2:21 host3<br>命令中的L参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。<br>这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。<br>    　　$ ftp localhost:2121<br>“本地端口转发”使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH隧道”。<br>下面是一个比较有趣的例子。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -L 5900:localhost:5900 host3</span></span><br></pre></td></tr></table></div></figure><p>它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。<br>另一个例子是通过host3的端口转发，ssh登录host2。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -L 9001:host2:22 host3</span></span><br></pre></td></tr></table></div></figure><p>这时，只要ssh登录本机的9001端口，就相当于登录host2了。 　　</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -p 9001 localhost</span></span><br></pre></td></tr></table></div></figure><p>上面的-p参数表示指定登录端口。</p><p>出错处理：ssh: Could not resolve hostname 192.168.<em>.</em>:***: Name or service not known</p><p>解决：指定端口不能直接使用ip:端口号，使用-p参数来解决就可以了。</p><h3 id="远程端口转发">远程端口转发<a href="2019/10/07/ssh用法及命令#远程端口转发"></a></h3><p>既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。<br>还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，”本地端口转发”就不能用了，怎么办？<br>解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。<br>我们在host3执行下面的命令：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -R 2121:host2:21 host1</span></span><br></pre></td></tr></table></div></figure><p>R参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。<br>绑定之后，我们在host1就可以连接host2了：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ftp localhost:2121</span></span><br></pre></td></tr></table></div></figure><p>这里必须指出，”远程端口转发”的前提条件是，host1和host3两台主机都有sshD和ssh客户端。</p><h1 id="SSH的其他参数">SSH的其他参数<a href="2019/10/07/ssh用法及命令#SSH的其他参数"></a></h1><p>SSH还有一些别的参数，也值得介绍。<br>N参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -NT -D 8080 host</span></span><br></pre></td></tr></table></div></figure><p>f参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -f -D 8080 host</span></span><br></pre></td></tr></table></div></figure><p>要关闭这个后台连接，就只有用kill命令去杀掉进程。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>提取关键词后端api文档</title>
      <link href="/2019/10/06/%E6%8F%90%E5%8F%96%E5%85%B3%E9%94%AE%E8%AF%8D%E5%90%8E%E7%AB%AFapi%E6%96%87%E6%A1%A3/"/>
      <url>/2019/10/06/%E6%8F%90%E5%8F%96%E5%85%B3%E9%94%AE%E8%AF%8D%E5%90%8E%E7%AB%AFapi%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Api文档">Api文档<a href="2019/10/06/提取关键词后端api文档#Api文档"></a></h2><p><strong>baseUrl：<code>host:port/lihkg</code></strong></p><p><strong>以下所有链接均需要加上baseUrl</strong></p><p><strong>测试baseUrl：<code>http://39.108.208.114/lihkg</code></strong></p><h3 id="配置文件">配置文件<a href="2019/10/06/提取关键词后端api文档#配置文件"></a></h3><p><code>config.json</code>配置文件</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="attr">"filePath"</span> : <span class="string">"C:\\data\\IdeaUProjects\\lihkg\\data"</span>, </span><br><span class="line">    </span><br><span class="line">    <span class="attr">"outputPath"</span> : <span class="string">"C:\\data\\IdeaUProjects\\lihkg\\outData"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li><p>filePath ：数据存放目录，所有需要解析的文件需要放到这个目录，请根据实际情况设置绝对路径</p></li><li><p>outputPath：解析后文件输出目录，所有解析完成的数据都会存放到这个地方，请根据实际情况设置绝对路径</p></li><li><p><strong>注意：</strong></p><p>输出文件夹权限必须为所有用户可写</p></li></ul><h3 id="初始化接口">初始化接口<a href="2019/10/06/提取关键词后端api文档#初始化接口"></a></h3><ul><li><p>url：<code>/resolve</code></p></li><li><p>说明：</p><blockquote><p>访问该接口会把数据目录里面所有的文件进行解析，数据文件夹务必全部放所需要解析的文件，不可放文件夹，否则可能解析失败，解析完成会把解析完成的数据放置在输出目录,解析完成会有返回，根据服务器不同解析成功时间不同，不建议在主线程执行。</p></blockquote></li><li><p>json格式：</p><blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;//失败</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;  &quot;tip&quot;: &quot;no data file,please check&quot;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;//成功</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;  &quot;tip&quot;: &quot;success resolve&quot;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote></blockquote></li></ul><h3 id="数据获取接口">数据获取接口<a href="2019/10/06/提取关键词后端api文档#数据获取接口"></a></h3><ul><li><p>url：<code>/keyword</code> （关键词解析数据）</p></li><li><p>url：<code>/organization</code> (组织解析数据)</p></li><li><p>url：<code>/place</code> （地名解析数据）</p></li><li><p>参数 ：（以上三个接口参数均如下）</p><table><thead><tr><th>key</th><th></th><th align="center">value</th><th></th><th></th></tr></thead><tbody><tr><td>single</td><td></td><td align="center">true\false</td><td></td><td>不加参数默认为false，返回数据会根据文件将关键词分开，true将把所有关键词统一返回，不区分文件</td></tr></tbody></table></li><li><p>json格式：</p><blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;//not single</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;"code": "404",</span><br><span class="line">&gt;"status": "false",</span><br><span class="line">&gt;"message": [</span><br><span class="line">&gt;[</span><br><span class="line">&gt;"发团队",</span><br><span class="line">&gt;"派发团队",</span><br><span class="line">&gt;"本团队所"</span><br><span class="line">&gt;],</span><br><span class="line">&gt;        ……</span><br><span class="line">&gt;        ……</span><br><span class="line">&gt;        ……</span><br><span class="line">&gt;        ……</span><br><span class="line">&gt;    ]</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt;//single</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;"code": "404",</span><br><span class="line">&gt;"status": "false",</span><br><span class="line">&gt;"message": [</span><br><span class="line">&gt;"发团队",</span><br><span class="line">&gt;"派发团队",</span><br><span class="line">&gt;"本团队所"，</span><br><span class="line">&gt;        ……，</span><br><span class="line">&gt;       ……，</span><br><span class="line">&gt;       ……，</span><br><span class="line">&gt;       ……</span><br><span class="line">&gt;    ]</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote></blockquote></li></ul><h2 id="注意">注意<a href="2019/10/06/提取关键词后端api文档#注意"></a></h2><ul><li><p>src文件夹下的config.json需要单独配置，请在打包前在请根据你服务器的文件目录更改<code>ResolveServlet.java</code>行的<code>configPath</code>属性为你部署之后的配置文件的绝对路径。</p><p>例：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String configPath = <span class="string">"C:\\data\\IdeaUProjects\\lihkg\\src\\config.json"</span>;</span><br></pre></td></tr></table></div></figure></li><li><p>打包部署完毕后请将配置文件放在你上一步填写的路径上</p></li></ul><p><img src="/2019/10/06/提取关键词后端api文档/TIM%E6%88%AA%E5%9B%BE20191006182248.png" alt="TIM截图20191006182248" class="article-img"></p><p><strong>github自行提取：<a href="https://github.com/Treeeeeeee/lihkg" target="_blank" rel="noopener">github链接</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git push 解决 弹出用户名和密码输入框</title>
      <link href="/2019/10/04/git-push-%E8%A7%A3%E5%86%B3-%E5%BC%B9%E5%87%BA%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86/"/>
      <url>/2019/10/04/git-push-%E8%A7%A3%E5%86%B3-%E5%BC%B9%E5%87%BA%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86/</url>
      
        <content type="html"><![CDATA[<h2 id="首先查看你的远程仓库版本">首先查看你的远程仓库版本<a href="2019/10/04/git-push-解决-弹出用户名和密码输入框#首先查看你的远程仓库版本"></a></h2><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v </span><br><span class="line"></span><br><span class="line">result：</span><br><span class="line">origin  https://github.com/username/username.github.io.git (fetch)</span><br><span class="line">origin  https://github.com/username/username.github.io.git (push)</span><br></pre></td></tr></table></div></figure><p>若你没有添加别人的仓库，通常只有这两个</p><h2 id="重新设置对应远程仓库成ssh的方式">重新设置对应远程仓库成ssh的方式:<a href="2019/10/04/git-push-解决-弹出用户名和密码输入框#重新设置对应远程仓库成ssh的方式"></a></h2><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@github.com:username/repository.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> Git学习备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识就是力量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.gitignore忽略文件总结</title>
      <link href="/2019/10/04/gitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/04/gitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="语法归纳">语法归纳<a href="2019/10/04/gitignore忽略文件总结#语法归纳"></a></h2><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#               表示此为注释,将被Git忽略</span></span><br><span class="line">*.a             表示忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a          表示但lib.a除外</span><br><span class="line">/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；</span><br><span class="line">doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt</span><br><span class="line"> </span><br><span class="line">bin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件</span><br><span class="line">/bin:           表示忽略根目录下的bin文件</span><br><span class="line">/*.c:           表示忽略cat.c，不忽略 build/cat.c</span><br><span class="line">debug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj</span><br><span class="line">**/foo:         表示忽略/foo,a/foo,a/b/foo等</span><br><span class="line">a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等</span><br><span class="line">!/bin/run.sh    表示不忽略bin目录下的run.sh文件</span><br><span class="line">*.<span class="built_in">log</span>:          表示忽略所有 .<span class="built_in">log</span> 文件</span><br><span class="line">config.php:     表示忽略当前路径的 config.php 文件</span><br><span class="line"> </span><br><span class="line">/mtk/           表示过滤整个文件夹</span><br><span class="line">*.zip           表示过滤所有.zip文件</span><br><span class="line">/mtk/do.c       表示过滤某个具体文件</span><br><span class="line"> </span><br><span class="line">被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。</span><br><span class="line"> </span><br><span class="line">需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：</span><br><span class="line">!*.zip</span><br><span class="line">!/mtk/one.txt</span><br><span class="line"> </span><br><span class="line">唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？</span><br><span class="line">想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：</span><br><span class="line">/mtk/*</span><br><span class="line">!/mtk/one.txt</span><br><span class="line"> </span><br><span class="line">假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</span><br><span class="line">注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！</span><br><span class="line"> </span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">还有一些规则如下：</span><br><span class="line">fd1/*</span><br><span class="line">说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；</span><br><span class="line"> </span><br><span class="line">/fd1/*</span><br><span class="line">说明：忽略根目录下的 /fd1/ 目录的全部内容；</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">!.gitignore</span><br><span class="line">!/fw/ </span><br><span class="line">/fw/*</span><br><span class="line">!/fw/bin/</span><br><span class="line">!/fw/sf/</span><br><span class="line">说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。</span><br></pre></td></tr></table></div></figure><h2 id="从版本库去除并忽略提交">从版本库去除并忽略提交<a href="2019/10/04/gitignore忽略文件总结#从版本库去除并忽略提交"></a></h2><h3 id="先执行以下任意删除命令">先执行以下任意删除命令<a href="2019/10/04/gitignore忽略文件总结#先执行以下任意删除命令"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm file<span class="comment"># 从版本库删除，并删除本地文件</span></span><br><span class="line">git rm --cached file<span class="comment"># 从版本库删除文件并保留本地文件</span></span><br><span class="line">git rm -r --cached loggers  <span class="comment"># -r 是允许递归删除，当要删除的是文件夹的时候有用</span></span><br></pre></td></tr></table></div></figure><h3 id="在-gitignore文件中添加">在.gitignore文件中添加<a href="2019/10/04/gitignore忽略文件总结#在-gitignore文件中添加"></a></h3><h2 id="提醒">提醒<a href="2019/10/04/gitignore忽略文件总结#提醒"></a></h2><h3 id="gitignore忽略规则的匹配语法">.gitignore忽略规则的匹配语法<a href="2019/10/04/gitignore忽略文件总结#gitignore忽略规则的匹配语法"></a></h3><p>每一行的忽略规则的语法如下：</p><ul><li><strong>空格</strong>不匹配任意文件，可作为分隔符，可用反斜杠转义</li><li>以“<strong>＃</strong>”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。</li><li>可以使用标准的<strong>glob</strong>模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。</li><li>以斜杠”<strong>/</strong>“开头表示目录；”/“结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；”/“开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。</li><li>以星号”<strong><em>**”通配多个字符，即匹配多个任意字符；使用两个星号”</em></strong>*<strong>“ 表示匹配任意中间目录，比如`a/</strong>/z`可以匹配 a/z, a/b/z 或 a/b/c/z等。</li><li>以问号”<strong>?</strong>“通配单个字符，即匹配一个任意字符；</li><li>以方括号”<strong>[]</strong>“包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。</li><li>以叹号”<strong>!</strong>“表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：<strong>如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用”!”规则是不起作用的</strong>。也就是说”!”开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用”!”也不会再次被包含。可以使用反斜杠进行转义。</li></ul><p><strong>需要谨记</strong>：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p><h3 id="gitignore忽略规则的优先级">.gitignore忽略规则的优先级<a href="2019/10/04/gitignore忽略文件总结#gitignore忽略规则的优先级"></a></h3><p>在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：</p><ul><li>从命令行中读取可用的忽略规则</li><li>当前目录定义的规则</li><li>父级目录定义的规则，依次递推</li><li>$GIT_DIR/info/exclude 文件中定义的规则</li><li>core.excludesfile中定义的全局规则</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git学习备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识就是力量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行后台运行程序命令</title>
      <link href="/2019/10/03/linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/10/03/linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="后台执行命令：-amp-和nohup">后台执行命令：&amp;和nohup<a href="2019/10/03/linux后台运行程序#后台执行命令：-amp-和nohup"></a></h1><h2 id="归纳：">归纳：<a href="2019/10/03/linux后台运行程序#归纳："></a></h2><h4 id="ps-ef或者grep查看进程"><code>ps -ef</code>或者<code>grep</code>查看进程<a href="2019/10/03/linux后台运行程序#ps-ef或者grep查看进程"></a></h4><h4 id="kill-XX杀死进程，XX替换为进程PID"><code>kill XX</code>杀死进程，<code>XX</code>替换为进程PID<a href="2019/10/03/linux后台运行程序#kill-XX杀死进程，XX替换为进程PID"></a></h4><h4 id="命令后加-amp-后台运行，但生命周期受窗口限制">命令后加<code>&amp;</code>后台运行，但生命周期受窗口限制<a href="2019/10/03/linux后台运行程序#命令后加-amp-后台运行，但生命周期受窗口限制"></a></h4><h4 id="nohup-命令-amp-完全后台运行"><code>nohup 命令 &amp;</code>完全后台运行<a href="2019/10/03/linux后台运行程序#nohup-命令-amp-完全后台运行"></a></h4><p><a href="https://blog.csdn.net/liuyanfeier/article/details/62422742" target="_blank" rel="noopener"><strong>原文链接</strong></a>，本文归纳梳理，便于自己记忆。</p><h2 id="后台运行命令">后台运行命令<a href="2019/10/03/linux后台运行程序#后台运行命令"></a></h2><h3 id="amp">&amp;<a href="2019/10/03/linux后台运行程序#amp"></a></h3><p><code>断开链接或者关闭窗口仍然会终止程序</code></p><blockquote><p>在命令后面加上&amp; 实现后台运行。例如：</p></blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh test.sh &amp;</span><br></pre></td></tr></table></div></figure><blockquote><ul><li><p>适合在后台运行的命令有find、费时的排序及一些shell脚本。</p></li><li><p>需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。</p></li><li><p>后台运行一样会将结果输出到屏幕上，干扰你的工作。</p></li><li><p>如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中</p></li></ul><p><code>命令  &gt;  out.file  2&gt;&amp;1  &amp; 1</code></p><p>这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。</p><ul><li><p>当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它</p><p><strong>(ps -ef | grep 进程号 或者 kill -9 进程号）</strong></p></li></ul></blockquote><h3 id="nohup">nohup<a href="2019/10/03/linux后台运行程序#nohup"></a></h3><p> <code>可退出命令窗口使用</code></p><blockquote><ul><li><p>使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用</p></li><li><p>一但把当前控制台关掉(退出帐户时)，作业就会停止运行。</p></li><li><p><strong>nohup命令</strong>可以在你退出帐户之后继续运行相应的进程。</p><blockquote><p>nohup就是不挂起的意思( no hang up)。该命令的一般形式为：</p></blockquote></li></ul></blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup 命令 &amp;1</span><br></pre></td></tr></table></div></figure><p>如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup command &gt; myout.file 2&gt;&amp;1 &amp;1</span><br></pre></td></tr></table></div></figure><h2 id="注意">注意<a href="2019/10/03/linux后台运行程序#注意"></a></h2><p>使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。</p><ul><li>ctrl + z<br>可以将一个正在前台执行的命令放到后台，并且处于暂停状态。</li><li>ctrl+c<br>终止前台命令。</li><li>jobs<br>查看当前有多少在后台运行的命令。<br>jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。</li><li>2&gt;&amp;1解析</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt;out.file 2&gt;&amp;1 &amp;1</span><br></pre></td></tr></table></div></figure><ol><li>command&gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。</li><li>2&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行。</li><li>试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识就是力量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows脚本转移Linux上git命令出现错误</title>
      <link href="/2019/10/03/windows%E8%84%9A%E6%9C%AC%E8%BD%AC%E7%A7%BBLinux%E4%B8%8Agit%E5%91%BD%E4%BB%A4%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF/"/>
      <url>/2019/10/03/windows%E8%84%9A%E6%9C%AC%E8%BD%AC%E7%A7%BBLinux%E4%B8%8Agit%E5%91%BD%E4%BB%A4%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="场景">场景<a href="2019/10/03/windows脚本转移Linux上git命令出现错误#场景"></a></h2><p>在我将整个hexo博客源码从windows10转移到linux（centos7）中时，脚本中的git命令没有例外的出现了这个错误</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git: <span class="string">'pull'</span> is not a git <span class="built_in">command</span>. See <span class="string">'git --help'</span>.  </span><br><span class="line">Did you mean one of these? </span><br><span class="line">pull</span><br><span class="line"></span><br><span class="line">git: <span class="string">'push'</span> is not a git <span class="built_in">command</span>. See <span class="string">'git --help'</span>.  </span><br><span class="line">Did you mean one of these? </span><br><span class="line">push</span><br></pre></td></tr></table></div></figure><p>这是什么人间疾苦，于是我Google，找到最接近的答案就是这个</p><p><a href="https://stackoverflow.com/questions/1465398/git-pull-broken" target="_blank" rel="noopener">https://stackoverflow.com/questions/1465398/git-pull-broken</a></p><p>这是十年前的一个issue，很明显不是这个问题。git早已经修正了这个issue。</p><p><strong>那么问题来了，这到底是什么原因导致git认为你认为完全正确的命令是有问题的呢：</strong></p><ul><li>首先我保证绝对不是git版本的问题，我反复在服务器上更替了不同版本的git，无论是直接安装编译好的版本还是自己编译都多次尝试过，但是无一例外出错了。还是相同的错误。</li><li>其次脚本绝对是可运行的，在windows上可以正确无误的执行。</li><li>服务器镜像问题？没钱换服务器，况且服务器上运行了不少东西，不好更换，但我觉得的应该不是，其他脚本命令是可以运行的。</li></ul><p>那到底是哪的问题呢？</p><h2 id="解决">解决<a href="2019/10/03/windows脚本转移Linux上git命令出现错误#解决"></a></h2><p>最后我几乎快完全丧失解决它的希望时，我进行了最后一次尝试。</p><p><strong>用在linux  vim重写脚本，发现在写的途中有些命令写出现和原来的颜色是不一样的</strong></p><p>最后脚本运行成功。</p><p><strong>所以千万别用windows10的记事本写代码，应该是编码的问题，还是建议用专业的编辑器写脚本</strong></p>]]></content>
      
      
      <categories>
          
          <category> 错误记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 巨坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错误记录：System limit for number of file watchers reached</title>
      <link href="/2019/10/03/System-limit-for-number-of-file-watchers-reached-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/10/03/System-limit-for-number-of-file-watchers-reached-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="我在执行hexo-server-d-时报错">我在执行hexo server -d 时报错<a href="2019/10/03/System-limit-for-number-of-file-watchers-reached-错误记录#我在执行hexo-server-d-时报错"></a></h3><p>Error: ENOSPC: System limit for number of file watchers reached, watch ‘/root/blog/Treeeeeeee.github.io/blog/themes/inside/node_modules/hexo/lib/plugins/tag/index.js’<br>    at FSWatcher.start (internal/fs/watchers.js:165:26)<br>    at Object.watch (fs.js:1258:11)<br>    at createFsWatchInstance (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:38:15)<br>    at setFsWatchListener (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:81:15)<br>    at FSWatcher.NodeFsHandler._watchWithNodeFs (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:233:14)<br>    at FSWatcher.NodeFsHandler._handleFile (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:262:21)<br>    at FSWatcher.<anonymous> (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:495:21)<br>    at FSReqWrap.oncomplete (fs.js:154:5)</anonymous></p><p><strong>文中说我达到文件监视程序数量的系统限制，不是很明白</strong></p>]]></content>
      
      
      <categories>
          
          <category> 错误记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不是特别坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+admin+windows+linux服务器的综合博客平台</title>
      <link href="/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/"/>
      <url>/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="windows下的hexo-github博客搭建">windows下的hexo+github博客搭建<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#windows下的hexo-github博客搭建"></a></h1><h2 id="博客搭建">博客搭建<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#博客搭建"></a></h2><p>不多说这里放上<a href="https://zhuanlan.zhihu.com/p/35668237" target="_blank" rel="noopener">大神的知乎</a>，点击自己按照流程来做就好了，下面我做一个归纳整理，也留作备份。</p><h3 id="安装Node-js">安装Node.js<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#安装Node-js"></a></h3><blockquote><ul><li><p><a href="https://link.zhihu.com/?target=https%3A//nodejs.org/dist/v9.11.1/node-v9.11.1-x64.msi" target="_blank" rel="noopener">windows下载链接</a></p></li><li><p>下载之后一路next就好，环境变量默认会把帮你配好</p></li><li><p>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p></li><li><p>也有没有自动配的情况，可以手动配一下。</p></li></ul></blockquote><h3 id="添加国内镜像源">添加国内镜像源<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#添加国内镜像源"></a></h3><blockquote><p>如果没有K X S W(这是啥大家都明白吧)的话，可以使用阿里的国内镜像进行加速。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><h3 id="安装Git">安装Git<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#安装Git"></a></h3><blockquote><ul><li><a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git的下载链接</a></li><li>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</li><li>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</li><li>同样如果没有找到版本号需要手动配置</li></ul></blockquote><h3 id="注册Github账号">注册Github账号<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#注册Github账号"></a></h3><blockquote><ul><li><p><a href="https://link.zhihu.com/?target=https%3A//github.com/" target="_blank" rel="noopener">注册地址</a></p></li><li><p>注册完成之后进入主页</p></li><li><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/Screenshot.png" alt="Screenshot" class="article-img"></p><p>点击新建项目</p></li><li><p>项目名称是你的github用户名加.github.io </p><blockquote><p>例如: <code>XXXXX.github.io</code></p><p>同时也可以勾选一下Redme.md</p></blockquote><p>![new p](C:\data\Treeeeeeee.github.io\blog\source_posts\hexo-admin-windows-服务器的综合博客平台\new p.png)</p></li><li><p>然后按照下面的流程你就可以获得一个最简单的博客</p><ul><li><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/m.png" alt="m" class="article-img"></p></li><li><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/2.png" alt="2" class="article-img"></p></li><li><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/3.png" alt="3" class="article-img"></p></li><li><p>进去之后随便选一个</p></li></ul></li></ul></blockquote><h3 id="安装Hexo">安装Hexo<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#安装Hexo"></a></h3><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在<code>D:\study\program\blog</code>目录下。</p><p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p><p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href="https://link.zhihu.com/?target=http%3A//localhost%3A4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，就可以看到我们的博客啦，效果如下：</p><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E5%9B%BE%E7%89%8720191003174050.png" alt="TIM图片20191003174050" class="article-img"></p><p>按<code>ctrl+c</code>关闭本地服务器。</p><h3 id="连接Github与本地">连接Github与本地<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#连接Github与本地"></a></h3><p>首先右键打开git bash，然后输入下面命令：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"godweiyang"</span></span><br><span class="line">git config --global user.email <span class="string">"792321264@qq.com"</span></span><br></pre></td></tr></table></div></figure><p>用户名和邮箱根据你注册github的信息自行修改。</p><p>然后生成密钥SSH key：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"792321264@qq.com"</span></span><br></pre></td></tr></table></div></figure><p>打开<a href="https://link.zhihu.com/?target=http%3A//github.com/" target="_blank" rel="noopener">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>git bash中输入</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></div></figure><p>将输出的内容复制到框中，点击确定保存。</p><p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></div></figure><p>repository或者repo修改为你自己的github项目地址</p><blockquote><p>我这里默认的是使用<code>ssh</code>，如果想使用<code>https</code>点击更换就好了</p><ul><li>我推荐使用ssh，毕竟你已经在你的github中添加了你本机的ssh，免得再输密码</li><li>如果不懂ssh可以先使用https，后面我们做服务器的自动git用ssh会更好，如果不需要，而且是在windows下使用的话那就<code>https</code>的吧，没啥关系，windows有记住密码的功能</li></ul></blockquote><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003175326.png" alt="TIM截图20191003175326" class="article-img"></p><h3 id="写文章、发布文章">写文章、发布文章<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#写文章、发布文章"></a></h3><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p><p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p><blockquote><p>article title 替换成你要写的文章的名字，需要注意一下：</p><ul><li><p>最好使用英文，使用中文的话博客的url会非常长</p></li><li><p>如果想插入图片的话，打开你的博客目录里面的<code>_config.yml</code>找到<code>post_asset_folder:</code>属性，并复制未<code>true</code>，这样生成一篇新文章时，会在</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   \source\_posts</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></li></ul></blockquote><blockquote><p>  目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等。这样在文章中插入图片使用相对路径就可以即在本地书写的时候看到图片，又在生成的博客中看到，例如：</p><p>  <img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003180656.png" alt="TIM截图20191003180656" class="article-img"></p><p>  在文章中直接这样插入，就可以完美插入图片。详细可以借鉴我<a href="https://treeeeeeee.github.io/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87">另外一篇博客</a></p><p>  <img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003180755.png" alt="TIM截图20191003180755" class="article-img"></p><ul><li><p>这里推荐一个超好用加方便的markdown编辑软件<code>Typora</code>，而且恰好支持这种图片资源文件，设置一下可以把任意来源图片直接弄到对应文件夹</p><blockquote><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003183937.png" alt="TIM截图20191003183937" style="zoom: 67%;"><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003184214.png" alt="TIM截图20191003184214" class="article-img"></p><p><strong>这样设置以后你不管是从网络上来的图片还是任意地方拖动的进来的图片都会自动给你放到这个文件夹</strong></p></blockquote></li></ul></blockquote><p>然后打开<code>D:\study\program\blog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p><h3 id="绑定域名">绑定域名<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#绑定域名"></a></h3><p>现在默认的域名还是<code>xxx.github.io</code>，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。</p><p>以我的百度云为例，如下图所示，添加两条解析记录：</p><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/v2-e11377329d5cef129c0aefd10eaa1607_hd.jpg" alt="img" class="article-img"></p><p>然后打开你的github博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存：</p><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/v2-8125794bbf0055917b820178489c7b0f_hd.jpg" alt="img" class="article-img"></p><p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\study\program\blog\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到github。</p><h3 id="备份博客源文件">备份博客源文件<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#备份博客源文件"></a></h3><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p><ul><li><p><strong>我的备份方法</strong></p><blockquote><p>随便找个文件夹，右键打开git bash，依次执行以下命令</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git clone 你的博客仓库地址</span><br><span class="line">&gt; git checkout -b backup</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>然后删除你拉下来的所有东西文件夹，如果你开了隐藏文件夹也可见的话别把<code>.git</code>文件夹删除了，如果没开就放心删除所有文件吧（看见<code>.git</code>别动就对了）</p><p>然后把你你的整个博客文件夹移动到这里，并删除你博客文件下里面所有叫<code>.gitignore</code>的文件，通常来说，博客源码根目录有一个，主题文件夹里面都有</p><blockquote><p><code>.gitignore</code>文件是用来说明那些东西不被git push的，具体请自行百度</p></blockquote><p>然后继续依次执行以下命令</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; git add .</span><br><span class="line">&gt; git commit -s -m &quot;backup&quot;</span><br><span class="line">&gt; git push</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>等待完成就可以在任何地方直接拉下来使用了，在其他地方使用有以下几个要注意的：</p><ul><li><p>环境必须安装这个没得说</p></li><li><p>如果你是使用shh来部署的项目需要把这台设备的生成的ssh添加到你的github账号里</p><blockquote><p>指的是你前面属性<code>repo :</code>是用的https的还是ssh的</p></blockquote></li></ul></blockquote></li><li><p>其他备份方法(该内容是粘贴复制)</p><blockquote><p>首先在github博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git branch -b hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo</code>提交就行了。</p></blockquote></li></ul><h3 id="博客源代码下载">博客源代码下载<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#博客源代码下载"></a></h3><h3 id="个性化设置（matery主题）">个性化设置（matery主题）<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#个性化设置（matery主题）"></a></h3><h3 id="常见问题及解答（FAQ）">常见问题及解答（FAQ）<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#常见问题及解答（FAQ）"></a></h3><h2 id="个性化设置-更换主题">个性化设置|更换主题|<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#个性化设置-更换主题"></a></h2><h3 id="效果图">效果图<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#效果图"></a></h3><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003184704.png" alt="TIM截图20191003184704" class="article-img"></p><p><a href="https://treeeeeeee.github.io">我的博客地址</a>有什么问题可以在文章下评论留言</p><h3 id="inside主题">inside主题<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#inside主题"></a></h3><ul><li><p>直接下载源码放到你的博客源码目录的themes目录里面，并修改<code>_config.yml</code>文件中<code>theme:</code>属性，然后执行：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></div></figure><p>浏览器访问：localhost:4000 就能直接看到效果了</p></li><li><p>具体配置我就不详细说明了可以去看主题制作者的博客：<a href="https://blog.oniuo.com/theme-inside" target="_blank" rel="noopener">链接</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 兴趣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> 浪费了大好青春 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完美的hexo中插入图片的解决方案</title>
      <link href="/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
      <url>/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="完美的hexo中插入图片的解决方案">完美的hexo中插入图片的解决方案<a href="2019/10/01/hexo下完美插入图片#完美的hexo中插入图片的解决方案"></a></h1><p>以下内容来自ETRD的<a href="[http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/](http://etrd.org/2017/01/23/hexo中完美插入本地图片/)">《hexo中完美插入本地图片》</a>，摘录整理关键部分，留作备份。</p><h3 id="Markdown编辑器">Markdown编辑器<a href="2019/10/01/hexo下完美插入图片#Markdown编辑器"></a></h3><ul><li><p><strong>Typora</strong></p><blockquote><p>不需要关注太多markdown语法就能写出比较好看的markdown，支持实时转换</p></blockquote></li></ul><h3 id="Hexo配置文件的设置">Hexo配置文件的设置<a href="2019/10/01/hexo下完美插入图片#Hexo配置文件的设置"></a></h3><p> 确保你的Hexo的配置文件_config.yml里面有个这个选项配置，并将其置为true</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></div></figure><p> 这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new</span><br></pre></td></tr></table></div></figure><p>生成一篇新文章时，会在</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\source\_posts</span><br></pre></td></tr></table></div></figure><p>目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等</p><p><a href="http://etrd.org/2017/01/23/hexo中完美插入本地图片/QQ截图20170123112354.png" target="_blank" rel="noopener"><img src="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/QQ%E6%88%AA%E5%9B%BE20170123112354.png" alt="QQ截图20170123112354"></a></p><p>实际上我通常喜欢自己右键手动去建立一个md文件来写博客，而不使用hexo new命令，此时要达到同样的效果，我同样也需要手动去建立一个同名的文件夹去存放资源，我试过这样做是可行的，并且这样做虽然有点麻烦，但我似乎发现了它的一个优点，那就是当我的文章中没有图片时，我并不需要这个空的资源文件夹。</p><p>有了上面的配置，Hexo在public文件下生成html文件时，会在相应的目录中把那文章对应的资源文件夹中的图片等附件复制过去，例如，这是我生成的一个例子：</p><p><a href="http://etrd.org/2017/01/23/hexo中完美插入本地图片/QQ截图20170123114005.png" target="_blank" rel="noopener"><img src="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/QQ%E6%88%AA%E5%9B%BE20170123114005.png" alt="QQ截图20170123114005"></a></p><h3 id="安装hexo-asset-image插件">安装hexo-asset-image插件<a href="2019/10/01/hexo下完美插入图片#安装hexo-asset-image插件"></a></h3><p>你需要安装一个图片路径转换的插件，这个插件名字是<strong>hexo-asset-image</strong>，我目前安装的是最新的0.03版本，使用如下命令安装插件</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></div></figure><p>插件安装完以后，实际上是存放在下面的目录文件夹下</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\blog\node_modules\hexo-asset-image</span><br></pre></td></tr></table></div></figure><p>想要卸载这个插件怎么处理，我听说直接删掉这个文件夹，反正我这么试过了。</p><h3 id="md文件的时间标签">md文件的时间标签<a href="2019/10/01/hexo下完美插入图片#md文件的时间标签"></a></h3><p>hexo-asset-image的原理应该是根据Hexo生成html后以时间的为目录的规则，将我们图片的相对地址转换成了生成后与时间对应目录的绝对地址，因此我认为md文件中应该要有时间标签，一来是为了让Hexo根据md的时间标签来确定文章的新旧排序，如果没有时间标签，Hexo会把md文件的修改时间作为发布时间，这显然是不合理的，再者这个时间标签，我想hexo-asset-image也会引用到，在一篇实际的博文中，我的md文件完整的开头是这样的：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---title: hexo中完美插入本地图片date: 2017-01-23 11:00:55categories: hexo使用tags: - hexo- 本地图片- hexo-asset-image---</span><br></pre></td></tr></table></div></figure><h3 id="插入图片">插入图片<a href="2019/10/01/hexo下完美插入图片#插入图片"></a></h3><p>由于每个md文件都有对应的一个资源文件夹，因此，你首先要把需要插入的图片放到这个资源文件夹下，然后进行路径引用，这是上面插入图片时的实际引用代码</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![QQ截图20170123114005](/hexo中完美插入本地图片/QQ截图20170123114005.png)</span><br></pre></td></tr></table></div></figure><p>使用Typora又有一个十分方便的地方在于，只需要将图片往这里一拖就插入了，但其实际拖入图片后的插入代码是绝对路径的引用，是这样的</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![QQ截图20170123114005](K:\FangCloudSync\Github博客源码\blog\source\_posts\hexo中完美插入本地图片\QQ截图20170123114005.png)</span><br></pre></td></tr></table></div></figure><p>对比上面的两个代码，我只需要将前面的那段绝对路径删掉<del>K:\FangCloudSync\Github博客源码\blog\source_posts</del> ，然后再将剩余的<strong>两个\分别换成/</strong> 就可以了</p><p>这样子，Typora编辑时同时能够看到插入的图片。</p><h3 id="生成测试">生成测试<a href="2019/10/01/hexo下完美插入图片#生成测试"></a></h3><p>在很多网友的文章中，这么做就可以了，你可以尝试一下生成并本地测试，看看是否博客的首页及博文的正文页都能够正确显示图片，或者打开博文生成的html源文件，找到图片插入的地方看看src路径是否是对应public后的绝对路径，如下示例这样</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;img src=&quot;/2017/01/22/Windows下远程桌面连接树莓派3代/QQ截图20170122163331.png&quot; alt=&quot;QQ截图20170122163331&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></div></figure><p>如果本地预览主页和博文正文页显示图片都没有问题，并且html源文件内的图片源地址是上面的格式，那你真幸运没有遇到什么麻烦。</p><h3 id="生成绝对路径不完整的问题">生成绝对路径不完整的问题<a href="2019/10/01/hexo下完美插入图片#生成绝对路径不完整的问题"></a></h3><p>我发现我做了上面的工作后，生成并本地测试查看，图片并不能正确显示，我查看了html文件，它生成的路径是这样的</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;img src=&quot;/22/imagetest/500.jpg&quot; alt=&quot;500&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></div></figure><p>看起来hexo-asset-image的确起了点作用，但似乎有点问题，它生成的绝对路径不完整，仿佛只获取了日，年月没获取到，因为这个md文件的时间是2017-01-22，所以”/2017/01” 似乎没有生成啊，对比上面正确正常的绝对路径，我不明白这是什么原因导致的，也许有可能是我使用的hexo懒人包导致的，Google了一晚上好像就我一个人有这种情况，最后我也在Github上向该插件的作者递交了我遇到的麻烦，但估计等到作者回复不知道是何时了。</p><p>今天早上，我受到<a href="http://error408.com/2016/08/02/Hexo七牛图床使用/" target="_blank" rel="noopener">自定义修改插件，更便捷的使用七牛空间</a> 这篇文章的启发，决定自己也尝试修改插件代码试试能否解决。虽然完全不懂js代码，但还是尝试阅读了那段极其简练的代码，这是其中一段：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var link = data.permalink;var beginPos = getPosition(link, &apos;/&apos;, 3) + 1;// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.var endPos = link.lastIndexOf(&apos;/&apos;) + 1;   link = link.substring(beginPos, endPos);</span><br></pre></td></tr></table></div></figure><p>可以猜测出来这段点大概是在获取博文生成的绝对路径，然后最后与md文件中的相对路径做一个拼接，但这个函数中</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var beginPos = getPosition(link, &apos;/&apos;, 3) + 1;</span><br></pre></td></tr></table></div></figure><p>为什么是寻找第3个’/‘？虽然我不知道，但这样做肯定有作者的意图，只是我不懂其中的原理不理解，不可能这个关键的数字是错的。但我假设如果完整的路径应该是/2017/01/22，那么第3个/似乎正好是日期里面的日，跟我的html生成的不完整的路径点似乎有点关联，因此如果这个数字修改为1，那么是不是就能将/2017/01补上了，试试看吧，然而，幸运的是，成功了！</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var beginPos = getPosition(link, &apos;/&apos;, 1) + 1;//just by launcher</span><br></pre></td></tr></table></div></figure><h3 id="小结">小结<a href="2019/10/01/hexo下完美插入图片#小结"></a></h3><p>需要插入本地图片，并让Hexo启用资源文件的功能，每个md文件对应一个资源文件夹，然而这只是方便了资源的管理，插入图片时不推荐使用hexo官方说的不伦不类的标签插入方法，因为编辑md文件时无法预览图片，而需要安装hexo-asset-image插件，这样正常使用markdown语法对图片的相对路径引用，即可实现编辑时可预览图片，且发布时插件自动将相对路径转为绝对路径。如果碰到与我同样的生成的绝对路径不完全的情况，尝试修改插件的js代码，但修改器建议先备份它，我认为我所解决我遇到问题的方法可能是一种巧合，但我暂时先这么使用了，最终的原因和处理方法可能还需要等待Github上该插件作者的官方回应。</p>]]></content>
      
      
      <categories>
          
          <category> 兴趣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于酷q平台的管理机器人</title>
      <link href="/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="酷Q机器人">酷Q机器人<a href="2019/10/01/基于酷q平台的管理机器人#酷Q机器人"></a></h2><hr><p><strong>自从samrtQQ下线之后，很多QQ机器人都失效了。</strong></p><p><strong>但是最近又比较想用这样一个机器人来管理减轻自己的一些工作，于是千方百计的我发现了酷Q。</strong></p><p><strong>这里附上<a href="https://cqp.cc/" target="_blank" rel="noopener">官网链接</a></strong></p><h3 id="开发以及注意事项">开发以及注意事项<a href="2019/10/01/基于酷q平台的管理机器人#开发以及注意事项"></a></h3><ol><li><h5 id="SDK的选择"><a href="2019/10/01/基于酷q平台的管理机器人#SDK的选择" class="headerlink" title="SDK的选择"></a>SDK的选择</h5><p>酷q提供了多种<a href="https://cqp.cc/t/15124" target="_blank" rel="noopener">SDK</a>但是都是我不常用的，官方的支持的SDK是E语言，这语言emmmm好，都好，写，都可以写。虽然提供了java的sdk但是java版本始终不是正统，咬牙学了一天E语言，最后还是吐了。没办法，不习惯，没说E语言不好。害，最后还是选择的java版本。不过但是还没开始使用的时候我看到了更加好用的一个找到一个更加好用方便的SDK-<a href="https://github.com/HyDevelop/PicqBotX" target="_blank" rel="noopener">PicqBotX</a>，这是通过http的插件来与酷q的程序交互。虽然不能像官方网站上提供的那个那样可以直接打包成jar运行但是个人认为开发更加简单。</p></li><li><p><strong>环境以及配置细节</strong></p><p><a href="https://github.com/HyDevelop/PicqBotX" target="_blank" rel="noopener">这里讲得很清楚，以下说明几个坑</a>：</p><ul><li><p>如果使用kotlin代替java进行开发，请最好使用Gradle对项目进行管理，它对kotlin有更加完美的支持。</p></li><li><p><img src="/2019/10/01/基于酷q平台的管理机器人/%E9%85%B7q%E9%85%8D%E7%BD%AE%E5%9D%8F%E5%A2%83%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.jpg" alt class="article-img"></p><p>在介绍readme中的这个位置一定要看准，下载对应版本的工具，否则可能出问题，比较麻烦，而且没有提示难以排查。</p></li><li><p>两个端口号一定要对应于你程序中的机器人的端口号否则会链接失败（建议直接用默认的31091 31092，也可自己选择）</p></li></ul></li></ol><h3 id="本人开发流程">本人开发流程<a href="2019/10/01/基于酷q平台的管理机器人#本人开发流程"></a></h3><ol><li><p>使用idea新建项目选择gradle管理项目<img src="/2019/10/01/基于酷q平台的管理机器人/idea%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.png" alt>java版本任意，需要kotlin开发勾选kotlin</p></li><li><p>导包</p><p><img src="/2019/10/01/基于酷q平台的管理机器人/%E5%AF%BC%E5%8C%85.png" alt class="article-img"></p><p>导入最新的sdk。</p></li><li><p>根据需要复制示例代码更改</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBot</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建机器人对象 ( 传入配置 )</span></span><br><span class="line">        PicqBotX bot = <span class="keyword">new</span> PicqBotX(<span class="keyword">new</span> PicqConfig(<span class="number">31092</span>).setDebug(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加一个机器人账户 ( 名字, 发送URL, 发送端口 )</span></span><br><span class="line">        bot.addAccount(<span class="string">"Bot01"</span>, <span class="string">"127.0.0.1"</span>, <span class="number">31091</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册事件监听器, 可以注册多个监听器</span></span><br><span class="line">        bot.getEventManager().registerListeners(</span><br><span class="line">                <span class="keyword">new</span> TestListener(), </span><br><span class="line">                <span class="keyword">new</span> RequestListener(),</span><br><span class="line">                <span class="keyword">new</span> ExceptionListener()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启用指令管理器</span></span><br><span class="line">        <span class="comment">// 这些字符串是指令前缀, 比如指令"!help"的前缀就是"!"</span></span><br><span class="line">        bot.enableCommandManager(<span class="string">"bot -"</span>, <span class="string">"!"</span>, <span class="string">"/"</span>, <span class="string">"~"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册指令, 可以注册多个指令</span></span><br><span class="line">        bot.getCommandManager().registerCommands(</span><br><span class="line">                <span class="keyword">new</span> CommandSay(),</span><br><span class="line">                <span class="keyword">new</span> CommandTest(),</span><br><span class="line">                <span class="keyword">new</span> CommandVersion()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动机器人, 不会占用主线程</span></span><br><span class="line">        bot.startBot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ol><h3 id="个人实现效果和功能">个人实现效果和功能<a href="2019/10/01/基于酷q平台的管理机器人#个人实现效果和功能"></a></h3><ul><li><p>通知功能</p><img src="/2019/10/01/基于酷q平台的管理机器人/通知.jpg" style="zoom:50%;"></li><li><p>请假功能</p><p>有学生请假则会以json格式文本保存在服务器（或者本地）</p><img src="/2019/10/01/基于酷q平台的管理机器人/请假.jpg" style="zoom: 33%;"></li><li><p>导出请假表格文档，会直接给下载链接</p><img src="/2019/10/01/基于酷q平台的管理机器人/请假文档.jpg" style="zoom: 50%;"></li><li><p>补登请假</p><img src="/2019/10/01/基于酷q平台的管理机器人/补登请假.jpg" style="zoom: 50%;"></li><li><p>还有安卓端的管理app和网页版实时查看数据。</p></li></ul><h3 id="部署机器人">部署机器人<a href="2019/10/01/基于酷q平台的管理机器人#部署机器人"></a></h3><h3 id="用到的库">用到的库<a href="2019/10/01/基于酷q平台的管理机器人#用到的库"></a></h3><hr><ul><li>阿帕奇的表格框架</li><li>gson</li></ul><p>通知管理机器人源代码地址：<a href>冷漠无情的机器人</a></p><p>因为源代码中有不少私人数据，所以取消。</p>]]></content>
      
      
      <categories>
          
          <category> 兴趣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 世界这么大，当然要多去看看 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
