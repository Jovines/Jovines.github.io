<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>.gitignore忽略文件总结</title>
      <link href="/2019/10/04/gitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/04/gitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="语法归纳">语法归纳<a href="2019/10/04/gitignore忽略文件总结#语法归纳"></a></h2><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#               表示此为注释,将被Git忽略</span></span><br><span class="line">*.a             表示忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a          表示但lib.a除外</span><br><span class="line">/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；</span><br><span class="line">doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt</span><br><span class="line"> </span><br><span class="line">bin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件</span><br><span class="line">/bin:           表示忽略根目录下的bin文件</span><br><span class="line">/*.c:           表示忽略cat.c，不忽略 build/cat.c</span><br><span class="line">debug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj</span><br><span class="line">**/foo:         表示忽略/foo,a/foo,a/b/foo等</span><br><span class="line">a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等</span><br><span class="line">!/bin/run.sh    表示不忽略bin目录下的run.sh文件</span><br><span class="line">*.<span class="built_in">log</span>:          表示忽略所有 .<span class="built_in">log</span> 文件</span><br><span class="line">config.php:     表示忽略当前路径的 config.php 文件</span><br><span class="line"> </span><br><span class="line">/mtk/           表示过滤整个文件夹</span><br><span class="line">*.zip           表示过滤所有.zip文件</span><br><span class="line">/mtk/do.c       表示过滤某个具体文件</span><br><span class="line"> </span><br><span class="line">被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。</span><br><span class="line"> </span><br><span class="line">需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：</span><br><span class="line">!*.zip</span><br><span class="line">!/mtk/one.txt</span><br><span class="line"> </span><br><span class="line">唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？</span><br><span class="line">想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：</span><br><span class="line">/mtk/*</span><br><span class="line">!/mtk/one.txt</span><br><span class="line"> </span><br><span class="line">假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</span><br><span class="line">注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！</span><br><span class="line"> </span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">还有一些规则如下：</span><br><span class="line">fd1/*</span><br><span class="line">说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；</span><br><span class="line"> </span><br><span class="line">/fd1/*</span><br><span class="line">说明：忽略根目录下的 /fd1/ 目录的全部内容；</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">!.gitignore</span><br><span class="line">!/fw/ </span><br><span class="line">/fw/*</span><br><span class="line">!/fw/bin/</span><br><span class="line">!/fw/sf/</span><br><span class="line">说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。</span><br></pre></td></tr></table></div></figure><h2 id="从版本库去除并忽略提交">从版本库去除并忽略提交<a href="2019/10/04/gitignore忽略文件总结#从版本库去除并忽略提交"></a></h2><h3 id="先执行以下任意删除命令">先执行以下任意删除命令<a href="2019/10/04/gitignore忽略文件总结#先执行以下任意删除命令"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm file<span class="comment"># 从版本库删除，并删除本地文件</span></span><br><span class="line">git rm --cached file<span class="comment"># 从版本库删除文件并保留本地文件</span></span><br><span class="line">git rm -r --cached loggers  <span class="comment"># -r 是允许递归删除，当要删除的是文件夹的时候有用</span></span><br></pre></td></tr></table></div></figure><h3 id="在-gitignore文件中添加">在.gitignore文件中添加<a href="2019/10/04/gitignore忽略文件总结#在-gitignore文件中添加"></a></h3><h2 id="提醒">提醒<a href="2019/10/04/gitignore忽略文件总结#提醒"></a></h2><h3 id="gitignore忽略规则的匹配语法">.gitignore忽略规则的匹配语法<a href="2019/10/04/gitignore忽略文件总结#gitignore忽略规则的匹配语法"></a></h3><p>每一行的忽略规则的语法如下：</p><ul><li><strong>空格</strong>不匹配任意文件，可作为分隔符，可用反斜杠转义</li><li>以“<strong>＃</strong>”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。</li><li>可以使用标准的<strong>glob</strong>模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。</li><li>以斜杠”<strong>/</strong>“开头表示目录；”/“结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；”/“开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。</li><li>以星号”<strong><em>**”通配多个字符，即匹配多个任意字符；使用两个星号”</em></strong>*<strong>“ 表示匹配任意中间目录，比如`a/</strong>/z`可以匹配 a/z, a/b/z 或 a/b/c/z等。</li><li>以问号”<strong>?</strong>“通配单个字符，即匹配一个任意字符；</li><li>以方括号”<strong>[]</strong>“包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。</li><li>以叹号”<strong>!</strong>“表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：<strong>如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用”!”规则是不起作用的</strong>。也就是说”!”开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用”!”也不会再次被包含。可以使用反斜杠进行转义。</li></ul><p><strong>需要谨记</strong>：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p><h3 id="gitignore忽略规则的优先级">.gitignore忽略规则的优先级<a href="2019/10/04/gitignore忽略文件总结#gitignore忽略规则的优先级"></a></h3><p>在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：</p><ul><li>从命令行中读取可用的忽略规则</li><li>当前目录定义的规则</li><li>父级目录定义的规则，依次递推</li><li>$GIT_DIR/info/exclude 文件中定义的规则</li><li>core.excludesfile中定义的全局规则</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git学习备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识就是力量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux后台运行程序命令</title>
      <link href="/2019/10/03/linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/10/03/linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="linux后台执行命令：-amp-和nohup">linux后台执行命令：&amp;和nohup<a href="2019/10/03/linux后台运行程序#linux后台执行命令：-amp-和nohup"></a></h1><h2 id="归纳：">归纳：<a href="2019/10/03/linux后台运行程序#归纳："></a></h2><h4 id="ps-ef或者grep查看进程"><code>ps -ef</code>或者<code>grep</code>查看进程<a href="2019/10/03/linux后台运行程序#ps-ef或者grep查看进程"></a></h4><h4 id="kill-XX杀死进程，XX替换为进程PID"><code>kill XX</code>杀死进程，<code>XX</code>替换为进程PID<a href="2019/10/03/linux后台运行程序#kill-XX杀死进程，XX替换为进程PID"></a></h4><h4 id="命令后加-amp-后台运行，但生命周期受窗口限制">命令后加<code>&amp;</code>后台运行，但生命周期受窗口限制<a href="2019/10/03/linux后台运行程序#命令后加-amp-后台运行，但生命周期受窗口限制"></a></h4><h4 id="nohup-命令-amp-完全后台运行"><code>nohup 命令 &amp;</code>完全后台运行<a href="2019/10/03/linux后台运行程序#nohup-命令-amp-完全后台运行"></a></h4><p><a href="https://blog.csdn.net/liuyanfeier/article/details/62422742" target="_blank" rel="noopener"><strong>原文链接</strong></a>，本文归纳梳理，便于自己记忆。</p><h2 id="后台运行命令">后台运行命令<a href="2019/10/03/linux后台运行程序#后台运行命令"></a></h2><h3 id="amp">&amp;<a href="2019/10/03/linux后台运行程序#amp"></a></h3><p><code>断开链接或者关闭窗口仍然会终止程序</code></p><blockquote><p>在命令后面加上&amp; 实现后台运行。例如：</p></blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh test.sh &amp;</span><br></pre></td></tr></table></div></figure><blockquote><ul><li><p>适合在后台运行的命令有find、费时的排序及一些shell脚本。</p></li><li><p>需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。</p></li><li><p>后台运行一样会将结果输出到屏幕上，干扰你的工作。</p></li><li><p>如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中</p></li></ul><p><code>命令  &gt;  out.file  2&gt;&amp;1  &amp; 1</code></p><p>这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。</p><ul><li><p>当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它</p><p><strong>(ps -ef | grep 进程号 或者 kill -9 进程号）</strong></p></li></ul></blockquote><h3 id="nohup">nohup<a href="2019/10/03/linux后台运行程序#nohup"></a></h3><p> <code>可退出命令窗口使用</code></p><blockquote><ul><li><p>使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用</p></li><li><p>一但把当前控制台关掉(退出帐户时)，作业就会停止运行。</p></li><li><p><strong>nohup命令</strong>可以在你退出帐户之后继续运行相应的进程。</p><blockquote><p>nohup就是不挂起的意思( no hang up)。该命令的一般形式为：</p></blockquote></li></ul></blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup 命令 &amp;1</span><br></pre></td></tr></table></div></figure><p>如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup command &gt; myout.file 2&gt;&amp;1 &amp;1</span><br></pre></td></tr></table></div></figure><h2 id="注意">注意<a href="2019/10/03/linux后台运行程序#注意"></a></h2><p>使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。</p><ul><li>ctrl + z<br>可以将一个正在前台执行的命令放到后台，并且处于暂停状态。</li><li>ctrl+c<br>终止前台命令。</li><li>jobs<br>查看当前有多少在后台运行的命令。<br>jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。</li><li>2&gt;&amp;1解析</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt;out.file 2&gt;&amp;1 &amp;1</span><br></pre></td></tr></table></div></figure><ol><li>command&gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。</li><li>2&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行。</li><li>试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识就是力量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows脚本转移Linux上git命令出现错误</title>
      <link href="/2019/10/03/windows%E8%84%9A%E6%9C%AC%E8%BD%AC%E7%A7%BBLinux%E4%B8%8Agit%E5%91%BD%E4%BB%A4%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF/"/>
      <url>/2019/10/03/windows%E8%84%9A%E6%9C%AC%E8%BD%AC%E7%A7%BBLinux%E4%B8%8Agit%E5%91%BD%E4%BB%A4%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="场景">场景<a href="2019/10/03/windows脚本转移Linux上git命令出现错误#场景"></a></h2><p>在我将整个hexo博客源码从windows10转移到linux（centos7）中时，脚本中的git命令没有例外的出现了这个错误</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git: <span class="string">'pull'</span> is not a git <span class="built_in">command</span>. See <span class="string">'git --help'</span>.  </span><br><span class="line">Did you mean one of these? </span><br><span class="line">pull</span><br><span class="line"></span><br><span class="line">git: <span class="string">'push'</span> is not a git <span class="built_in">command</span>. See <span class="string">'git --help'</span>.  </span><br><span class="line">Did you mean one of these? </span><br><span class="line">push</span><br></pre></td></tr></table></div></figure><p>这是什么人间疾苦，于是我Google，找到最接近的答案就是这个</p><p><a href="https://stackoverflow.com/questions/1465398/git-pull-broken" target="_blank" rel="noopener">https://stackoverflow.com/questions/1465398/git-pull-broken</a></p><p>这是十年前的一个issue，很明显不是这个问题。git早已经修正了这个issue。</p><p><strong>那么问题来了，这到底是什么原因导致git认为你认为完全正确的命令是有问题的呢：</strong></p><ul><li>首先我保证绝对不是git版本的问题，我反复在服务器上更替了不同版本的git，无论是直接安装编译好的版本还是自己编译都多次尝试过，但是无一例外出错了。还是相同的错误。</li><li>其次脚本绝对是可运行的，在windows上可以正确无误的执行。</li><li>服务器镜像问题？没钱换服务器，况且服务器上运行了不少东西，不好更换，但我觉得的应该不是，其他脚本命令是可以运行的。</li></ul><p>那到底是哪的问题呢？</p><h2 id="解决">解决<a href="2019/10/03/windows脚本转移Linux上git命令出现错误#解决"></a></h2><p>最后我几乎快完全丧失解决它的希望时，我进行了最后一次尝试。</p><p><strong>用在linux  vim重写脚本，发现在写的途中有些命令写出现和原来的颜色是不一样的</strong></p><p>最后脚本运行成功。</p><p><strong>所以千万别用windows10的记事本写代码，应该是编码的问题，还是建议用专业的编辑器写脚本</strong></p>]]></content>
      
      
      <categories>
          
          <category> 错误记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 巨坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错误记录：System limit for number of file watchers reached</title>
      <link href="/2019/10/03/System-limit-for-number-of-file-watchers-reached-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/10/03/System-limit-for-number-of-file-watchers-reached-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="我在执行hexo-server-d-时报错">我在执行hexo server -d 时报错<a href="2019/10/03/System-limit-for-number-of-file-watchers-reached-错误记录#我在执行hexo-server-d-时报错"></a></h3><p>Error: ENOSPC: System limit for number of file watchers reached, watch ‘/root/blog/Treeeeeeee.github.io/blog/themes/inside/node_modules/hexo/lib/plugins/tag/index.js’<br>    at FSWatcher.start (internal/fs/watchers.js:165:26)<br>    at Object.watch (fs.js:1258:11)<br>    at createFsWatchInstance (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:38:15)<br>    at setFsWatchListener (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:81:15)<br>    at FSWatcher.NodeFsHandler._watchWithNodeFs (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:233:14)<br>    at FSWatcher.NodeFsHandler._handleFile (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:262:21)<br>    at FSWatcher.<anonymous> (/root/blog/Treeeeeeee.github.io/blog/node_modules/chokidar/lib/nodefs-handler.js:495:21)<br>    at FSReqWrap.oncomplete (fs.js:154:5)</anonymous></p><p><strong>文中说我达到文件监视程序数量的系统限制，不是很明白</strong></p>]]></content>
      
      
      <categories>
          
          <category> 错误记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不是特别坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+admin+windows+linux服务器的综合博客平台</title>
      <link href="/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/"/>
      <url>/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="windows下的hexo-github博客搭建">windows下的hexo+github博客搭建<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#windows下的hexo-github博客搭建"></a></h1><h2 id="博客搭建">博客搭建<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#博客搭建"></a></h2><p>不多说这里放上<a href="https://zhuanlan.zhihu.com/p/35668237" target="_blank" rel="noopener">大神的知乎</a>，点击自己按照流程来做就好了，下面我做一个归纳整理，也留作备份。</p><h3 id="安装Node-js">安装Node.js<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#安装Node-js"></a></h3><blockquote><ul><li><p><a href="https://link.zhihu.com/?target=https%3A//nodejs.org/dist/v9.11.1/node-v9.11.1-x64.msi" target="_blank" rel="noopener">windows下载链接</a></p></li><li><p>下载之后一路next就好，环境变量默认会把帮你配好</p></li><li><p>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p></li><li><p>也有没有自动配的情况，可以手动配一下。</p></li></ul></blockquote><h3 id="添加国内镜像源">添加国内镜像源<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#添加国内镜像源"></a></h3><blockquote><p>如果没有K X S W(这是啥大家都明白吧)的话，可以使用阿里的国内镜像进行加速。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><h3 id="安装Git">安装Git<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#安装Git"></a></h3><blockquote><ul><li><a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git的下载链接</a></li><li>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</li><li>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</li><li>同样如果没有找到版本号需要手动配置</li></ul></blockquote><h3 id="注册Github账号">注册Github账号<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#注册Github账号"></a></h3><blockquote><ul><li><p><a href="https://link.zhihu.com/?target=https%3A//github.com/" target="_blank" rel="noopener">注册地址</a></p></li><li><p>注册完成之后进入主页</p></li><li><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/Screenshot.png" alt="Screenshot" class="article-img"></p><p>点击新建项目</p></li><li><p>项目名称是你的github用户名加.github.io </p><blockquote><p>例如: <code>XXXXX.github.io</code></p><p>同时也可以勾选一下Redme.md</p></blockquote><p>![new p](C:\data\Treeeeeeee.github.io\blog\source_posts\hexo-admin-windows-服务器的综合博客平台\new p.png)</p></li><li><p>然后按照下面的流程你就可以获得一个最简单的博客</p><ul><li><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/m.png" alt="m" class="article-img"></p></li><li><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/2.png" alt="2" class="article-img"></p></li><li><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/3.png" alt="3" class="article-img"></p></li><li><p>进去之后随便选一个</p></li></ul></li></ul></blockquote><h3 id="安装Hexo">安装Hexo<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#安装Hexo"></a></h3><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在<code>D:\study\program\blog</code>目录下。</p><p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p><p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href="https://link.zhihu.com/?target=http%3A//localhost%3A4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，就可以看到我们的博客啦，效果如下：</p><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E5%9B%BE%E7%89%8720191003174050.png" alt="TIM图片20191003174050" class="article-img"></p><p>按<code>ctrl+c</code>关闭本地服务器。</p><h3 id="连接Github与本地">连接Github与本地<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#连接Github与本地"></a></h3><p>首先右键打开git bash，然后输入下面命令：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"godweiyang"</span></span><br><span class="line">git config --global user.email <span class="string">"792321264@qq.com"</span></span><br></pre></td></tr></table></div></figure><p>用户名和邮箱根据你注册github的信息自行修改。</p><p>然后生成密钥SSH key：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"792321264@qq.com"</span></span><br></pre></td></tr></table></div></figure><p>打开<a href="https://link.zhihu.com/?target=http%3A//github.com/" target="_blank" rel="noopener">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>git bash中输入</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></div></figure><p>将输出的内容复制到框中，点击确定保存。</p><p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></div></figure><p>repository或者repo修改为你自己的github项目地址</p><blockquote><p>我这里默认的是使用<code>ssh</code>，如果想使用<code>https</code>点击更换就好了</p><ul><li>我推荐使用ssh，毕竟你已经在你的github中添加了你本机的ssh，免得再输密码</li><li>如果不懂ssh可以先使用https，后面我们做服务器的自动git用ssh会更好，如果不需要，而且是在windows下使用的话那就<code>https</code>的吧，没啥关系，windows有记住密码的功能</li></ul></blockquote><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003175326.png" alt="TIM截图20191003175326" class="article-img"></p><h3 id="写文章、发布文章">写文章、发布文章<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#写文章、发布文章"></a></h3><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p><p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p><blockquote><p>article title 替换成你要写的文章的名字，需要注意一下：</p><ul><li><p>最好使用英文，使用中文的话博客的url会非常长</p></li><li><p>如果想插入图片的话，打开你的博客目录里面的<code>_config.yml</code>找到<code>post_asset_folder:</code>属性，并复制未<code>true</code>，这样生成一篇新文章时，会在</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   \source\_posts</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></li></ul></blockquote><blockquote><p>  目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等。这样在文章中插入图片使用相对路径就可以即在本地书写的时候看到图片，又在生成的博客中看到，例如：</p><p>  <img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003180656.png" alt="TIM截图20191003180656" class="article-img"></p><p>  在文章中直接这样插入，就可以完美插入图片。详细可以借鉴我<a href="https://treeeeeeee.github.io/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87">另外一篇博客</a></p><p>  <img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003180755.png" alt="TIM截图20191003180755" class="article-img"></p><ul><li><p>这里推荐一个超好用加方便的markdown编辑软件<code>Typora</code>，而且恰好支持这种图片资源文件，设置一下可以把任意来源图片直接弄到对应文件夹</p><blockquote><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003183937.png" alt="TIM截图20191003183937" style="zoom: 67%;"><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003184214.png" alt="TIM截图20191003184214" class="article-img"></p><p><strong>这样设置以后你不管是从网络上来的图片还是任意地方拖动的进来的图片都会自动给你放到这个文件夹</strong></p></blockquote></li></ul></blockquote><p>然后打开<code>D:\study\program\blog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p><h3 id="绑定域名">绑定域名<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#绑定域名"></a></h3><p>现在默认的域名还是<code>xxx.github.io</code>，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。</p><p>以我的百度云为例，如下图所示，添加两条解析记录：</p><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/v2-e11377329d5cef129c0aefd10eaa1607_hd.jpg" alt="img" class="article-img"></p><p>然后打开你的github博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存：</p><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/v2-8125794bbf0055917b820178489c7b0f_hd.jpg" alt="img" class="article-img"></p><p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\study\program\blog\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到github。</p><h3 id="备份博客源文件">备份博客源文件<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#备份博客源文件"></a></h3><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p><ul><li><p><strong>我的备份方法</strong></p><blockquote><p>随便找个文件夹，右键打开git bash，依次执行以下命令</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git clone 你的博客仓库地址</span><br><span class="line">&gt; git checkout -b backup</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>然后删除你拉下来的所有东西文件夹，如果你开了隐藏文件夹也可见的话别把<code>.git</code>文件夹删除了，如果没开就放心删除所有文件吧（看见<code>.git</code>别动就对了）</p><p>然后把你你的整个博客文件夹移动到这里，并删除你博客文件下里面所有叫<code>.gitignore</code>的文件，通常来说，博客源码根目录有一个，主题文件夹里面都有</p><blockquote><p><code>.gitignore</code>文件是用来说明那些东西不被git push的，具体请自行百度</p></blockquote><p>然后继续依次执行以下命令</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; git add .</span><br><span class="line">&gt; git commit -s -m &quot;backup&quot;</span><br><span class="line">&gt; git push</span><br><span class="line">&gt;</span><br></pre></td></tr></table></div></figure></blockquote><blockquote><p>等待完成就可以在任何地方直接拉下来使用了，在其他地方使用有以下几个要注意的：</p><ul><li><p>环境必须安装这个没得说</p></li><li><p>如果你是使用shh来部署的项目需要把这台设备的生成的ssh添加到你的github账号里</p><blockquote><p>指的是你前面属性<code>repo :</code>是用的https的还是ssh的</p></blockquote></li></ul></blockquote></li><li><p>其他备份方法(该内容是粘贴复制)</p><blockquote><p>首先在github博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git branch -b hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo</code>提交就行了。</p></blockquote></li></ul><h3 id="博客源代码下载">博客源代码下载<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#博客源代码下载"></a></h3><h3 id="个性化设置（matery主题）">个性化设置（matery主题）<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#个性化设置（matery主题）"></a></h3><h3 id="常见问题及解答（FAQ）">常见问题及解答（FAQ）<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#常见问题及解答（FAQ）"></a></h3><h2 id="个性化设置-更换主题">个性化设置|更换主题|<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#个性化设置-更换主题"></a></h2><h3 id="效果图">效果图<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#效果图"></a></h3><p><img src="/2019/10/03/hexo-admin-windows-服务器的综合博客平台/TIM%E6%88%AA%E5%9B%BE20191003184704.png" alt="TIM截图20191003184704" class="article-img"></p><p><a href="https://treeeeeeee.github.io">我的博客地址</a>有什么问题可以在文章下评论留言</p><h3 id="inside主题">inside主题<a href="2019/10/03/hexo-admin-windows-服务器的综合博客平台#inside主题"></a></h3><ul><li><p>直接下载源码放到你的博客源码目录的themes目录里面，并修改<code>_config.yml</code>文件中<code>theme:</code>属性，然后执行：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></div></figure><p>浏览器访问：localhost:4000 就能直接看到效果了</p></li><li><p>具体配置我就不详细说明了可以去看主题制作者的博客：<a href="https://blog.oniuo.com/theme-inside" target="_blank" rel="noopener">链接</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 兴趣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> 浪费了大好青春 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完美的hexo中插入图片的解决方案</title>
      <link href="/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
      <url>/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="完美的hexo中插入图片的解决方案">完美的hexo中插入图片的解决方案<a href="2019/10/01/hexo下完美插入图片#完美的hexo中插入图片的解决方案"></a></h1><p>以下内容来自ETRD的<a href="[http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/](http://etrd.org/2017/01/23/hexo中完美插入本地图片/)">《hexo中完美插入本地图片》</a>，摘录整理关键部分，留作备份。</p><h3 id="Markdown编辑器">Markdown编辑器<a href="2019/10/01/hexo下完美插入图片#Markdown编辑器"></a></h3><ul><li><p><strong>Typora</strong></p><blockquote><p>不需要关注太多markdown语法就能写出比较好看的markdown，支持实时转换</p></blockquote></li></ul><h3 id="Hexo配置文件的设置">Hexo配置文件的设置<a href="2019/10/01/hexo下完美插入图片#Hexo配置文件的设置"></a></h3><p> 确保你的Hexo的配置文件_config.yml里面有个这个选项配置，并将其置为true</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></div></figure><p> 这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new</span><br></pre></td></tr></table></div></figure><p>生成一篇新文章时，会在</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\source\_posts</span><br></pre></td></tr></table></div></figure><p>目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等</p><p><a href="http://etrd.org/2017/01/23/hexo中完美插入本地图片/QQ截图20170123112354.png" target="_blank" rel="noopener"><img src="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/QQ%E6%88%AA%E5%9B%BE20170123112354.png" alt="QQ截图20170123112354"></a></p><p>实际上我通常喜欢自己右键手动去建立一个md文件来写博客，而不使用hexo new命令，此时要达到同样的效果，我同样也需要手动去建立一个同名的文件夹去存放资源，我试过这样做是可行的，并且这样做虽然有点麻烦，但我似乎发现了它的一个优点，那就是当我的文章中没有图片时，我并不需要这个空的资源文件夹。</p><p>有了上面的配置，Hexo在public文件下生成html文件时，会在相应的目录中把那文章对应的资源文件夹中的图片等附件复制过去，例如，这是我生成的一个例子：</p><p><a href="http://etrd.org/2017/01/23/hexo中完美插入本地图片/QQ截图20170123114005.png" target="_blank" rel="noopener"><img src="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/QQ%E6%88%AA%E5%9B%BE20170123114005.png" alt="QQ截图20170123114005"></a></p><h3 id="安装hexo-asset-image插件">安装hexo-asset-image插件<a href="2019/10/01/hexo下完美插入图片#安装hexo-asset-image插件"></a></h3><p>你需要安装一个图片路径转换的插件，这个插件名字是<strong>hexo-asset-image</strong>，我目前安装的是最新的0.03版本，使用如下命令安装插件</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></div></figure><p>插件安装完以后，实际上是存放在下面的目录文件夹下</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\blog\node_modules\hexo-asset-image</span><br></pre></td></tr></table></div></figure><p>想要卸载这个插件怎么处理，我听说直接删掉这个文件夹，反正我这么试过了。</p><h3 id="md文件的时间标签">md文件的时间标签<a href="2019/10/01/hexo下完美插入图片#md文件的时间标签"></a></h3><p>hexo-asset-image的原理应该是根据Hexo生成html后以时间的为目录的规则，将我们图片的相对地址转换成了生成后与时间对应目录的绝对地址，因此我认为md文件中应该要有时间标签，一来是为了让Hexo根据md的时间标签来确定文章的新旧排序，如果没有时间标签，Hexo会把md文件的修改时间作为发布时间，这显然是不合理的，再者这个时间标签，我想hexo-asset-image也会引用到，在一篇实际的博文中，我的md文件完整的开头是这样的：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---title: hexo中完美插入本地图片date: 2017-01-23 11:00:55categories: hexo使用tags: - hexo- 本地图片- hexo-asset-image---</span><br></pre></td></tr></table></div></figure><h3 id="插入图片">插入图片<a href="2019/10/01/hexo下完美插入图片#插入图片"></a></h3><p>由于每个md文件都有对应的一个资源文件夹，因此，你首先要把需要插入的图片放到这个资源文件夹下，然后进行路径引用，这是上面插入图片时的实际引用代码</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![QQ截图20170123114005](/hexo中完美插入本地图片/QQ截图20170123114005.png)</span><br></pre></td></tr></table></div></figure><p>使用Typora又有一个十分方便的地方在于，只需要将图片往这里一拖就插入了，但其实际拖入图片后的插入代码是绝对路径的引用，是这样的</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![QQ截图20170123114005](K:\FangCloudSync\Github博客源码\blog\source\_posts\hexo中完美插入本地图片\QQ截图20170123114005.png)</span><br></pre></td></tr></table></div></figure><p>对比上面的两个代码，我只需要将前面的那段绝对路径删掉<del>K:\FangCloudSync\Github博客源码\blog\source_posts</del> ，然后再将剩余的<strong>两个\分别换成/</strong> 就可以了</p><p>这样子，Typora编辑时同时能够看到插入的图片。</p><h3 id="生成测试">生成测试<a href="2019/10/01/hexo下完美插入图片#生成测试"></a></h3><p>在很多网友的文章中，这么做就可以了，你可以尝试一下生成并本地测试，看看是否博客的首页及博文的正文页都能够正确显示图片，或者打开博文生成的html源文件，找到图片插入的地方看看src路径是否是对应public后的绝对路径，如下示例这样</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;img src=&quot;/2017/01/22/Windows下远程桌面连接树莓派3代/QQ截图20170122163331.png&quot; alt=&quot;QQ截图20170122163331&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></div></figure><p>如果本地预览主页和博文正文页显示图片都没有问题，并且html源文件内的图片源地址是上面的格式，那你真幸运没有遇到什么麻烦。</p><h3 id="生成绝对路径不完整的问题">生成绝对路径不完整的问题<a href="2019/10/01/hexo下完美插入图片#生成绝对路径不完整的问题"></a></h3><p>我发现我做了上面的工作后，生成并本地测试查看，图片并不能正确显示，我查看了html文件，它生成的路径是这样的</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;img src=&quot;/22/imagetest/500.jpg&quot; alt=&quot;500&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></div></figure><p>看起来hexo-asset-image的确起了点作用，但似乎有点问题，它生成的绝对路径不完整，仿佛只获取了日，年月没获取到，因为这个md文件的时间是2017-01-22，所以”/2017/01” 似乎没有生成啊，对比上面正确正常的绝对路径，我不明白这是什么原因导致的，也许有可能是我使用的hexo懒人包导致的，Google了一晚上好像就我一个人有这种情况，最后我也在Github上向该插件的作者递交了我遇到的麻烦，但估计等到作者回复不知道是何时了。</p><p>今天早上，我受到<a href="http://error408.com/2016/08/02/Hexo七牛图床使用/" target="_blank" rel="noopener">自定义修改插件，更便捷的使用七牛空间</a> 这篇文章的启发，决定自己也尝试修改插件代码试试能否解决。虽然完全不懂js代码，但还是尝试阅读了那段极其简练的代码，这是其中一段：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var link = data.permalink;var beginPos = getPosition(link, &apos;/&apos;, 3) + 1;// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.var endPos = link.lastIndexOf(&apos;/&apos;) + 1;   link = link.substring(beginPos, endPos);</span><br></pre></td></tr></table></div></figure><p>可以猜测出来这段点大概是在获取博文生成的绝对路径，然后最后与md文件中的相对路径做一个拼接，但这个函数中</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var beginPos = getPosition(link, &apos;/&apos;, 3) + 1;</span><br></pre></td></tr></table></div></figure><p>为什么是寻找第3个’/‘？虽然我不知道，但这样做肯定有作者的意图，只是我不懂其中的原理不理解，不可能这个关键的数字是错的。但我假设如果完整的路径应该是/2017/01/22，那么第3个/似乎正好是日期里面的日，跟我的html生成的不完整的路径点似乎有点关联，因此如果这个数字修改为1，那么是不是就能将/2017/01补上了，试试看吧，然而，幸运的是，成功了！</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var beginPos = getPosition(link, &apos;/&apos;, 1) + 1;//just by launcher</span><br></pre></td></tr></table></div></figure><h3 id="小结">小结<a href="2019/10/01/hexo下完美插入图片#小结"></a></h3><p>需要插入本地图片，并让Hexo启用资源文件的功能，每个md文件对应一个资源文件夹，然而这只是方便了资源的管理，插入图片时不推荐使用hexo官方说的不伦不类的标签插入方法，因为编辑md文件时无法预览图片，而需要安装hexo-asset-image插件，这样正常使用markdown语法对图片的相对路径引用，即可实现编辑时可预览图片，且发布时插件自动将相对路径转为绝对路径。如果碰到与我同样的生成的绝对路径不完全的情况，尝试修改插件的js代码，但修改器建议先备份它，我认为我所解决我遇到问题的方法可能是一种巧合，但我暂时先这么使用了，最终的原因和处理方法可能还需要等待Github上该插件作者的官方回应。</p>]]></content>
      
      
      <categories>
          
          <category> 兴趣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于酷q平台的管理机器人</title>
      <link href="/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="酷Q机器人">酷Q机器人<a href="2019/10/01/基于酷q平台的管理机器人#酷Q机器人"></a></h2><hr><p><strong>自从samrtQQ下线之后，很多QQ机器人都失效了。</strong></p><p><strong>但是最近又比较想用这样一个机器人来管理减轻自己的一些工作，于是千方百计的我发现了酷Q。</strong></p><p><strong>这里附上<a href="https://cqp.cc/" target="_blank" rel="noopener">官网链接</a></strong></p><h3 id="开发以及注意事项">开发以及注意事项<a href="2019/10/01/基于酷q平台的管理机器人#开发以及注意事项"></a></h3><ol><li><h5 id="SDK的选择"><a href="2019/10/01/基于酷q平台的管理机器人#SDK的选择" class="headerlink" title="SDK的选择"></a>SDK的选择</h5><p>酷q提供了多种<a href="https://cqp.cc/t/15124" target="_blank" rel="noopener">SDK</a>但是都是我不常用的，官方的支持的SDK是E语言，这语言emmmm好，都好，写，都可以写。虽然提供了java的sdk但是java版本始终不是正统，咬牙学了一天E语言，最后还是吐了。没办法，不习惯，没说E语言不好。害，最后还是选择的java版本。不过但是还没开始使用的时候我看到了更加好用的一个找到一个更加好用方便的SDK-<a href="https://github.com/HyDevelop/PicqBotX" target="_blank" rel="noopener">PicqBotX</a>，这是通过http的插件来与酷q的程序交互。虽然不能像官方网站上提供的那个那样可以直接打包成jar运行但是个人认为开发更加简单。</p></li><li><p><strong>环境以及配置细节</strong></p><p><a href="https://github.com/HyDevelop/PicqBotX" target="_blank" rel="noopener">这里讲得很清楚，以下说明几个坑</a>：</p><ul><li><p>如果使用kotlin代替java进行开发，请最好使用Gradle对项目进行管理，它对kotlin有更加完美的支持。</p></li><li><p><img src="/2019/10/01/基于酷q平台的管理机器人/%E9%85%B7q%E9%85%8D%E7%BD%AE%E5%9D%8F%E5%A2%83%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.jpg" alt class="article-img"></p><p>在介绍readme中的这个位置一定要看准，下载对应版本的工具，否则可能出问题，比较麻烦，而且没有提示难以排查。</p></li><li><p>两个端口号一定要对应于你程序中的机器人的端口号否则会链接失败（建议直接用默认的31091 31092，也可自己选择）</p></li></ul></li></ol><h3 id="本人开发流程">本人开发流程<a href="2019/10/01/基于酷q平台的管理机器人#本人开发流程"></a></h3><ol><li><p>使用idea新建项目选择gradle管理项目<img src="/2019/10/01/基于酷q平台的管理机器人/idea%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.png" alt>java版本任意，需要kotlin开发勾选kotlin</p></li><li><p>导包</p><p><img src="/2019/10/01/基于酷q平台的管理机器人/%E5%AF%BC%E5%8C%85.png" alt class="article-img"></p><p>导入最新的sdk。</p></li><li><p>根据需要复制示例代码更改</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBot</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建机器人对象 ( 传入配置 )</span></span><br><span class="line">        PicqBotX bot = <span class="keyword">new</span> PicqBotX(<span class="keyword">new</span> PicqConfig(<span class="number">31092</span>).setDebug(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加一个机器人账户 ( 名字, 发送URL, 发送端口 )</span></span><br><span class="line">        bot.addAccount(<span class="string">"Bot01"</span>, <span class="string">"127.0.0.1"</span>, <span class="number">31091</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册事件监听器, 可以注册多个监听器</span></span><br><span class="line">        bot.getEventManager().registerListeners(</span><br><span class="line">                <span class="keyword">new</span> TestListener(), </span><br><span class="line">                <span class="keyword">new</span> RequestListener(),</span><br><span class="line">                <span class="keyword">new</span> ExceptionListener()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启用指令管理器</span></span><br><span class="line">        <span class="comment">// 这些字符串是指令前缀, 比如指令"!help"的前缀就是"!"</span></span><br><span class="line">        bot.enableCommandManager(<span class="string">"bot -"</span>, <span class="string">"!"</span>, <span class="string">"/"</span>, <span class="string">"~"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册指令, 可以注册多个指令</span></span><br><span class="line">        bot.getCommandManager().registerCommands(</span><br><span class="line">                <span class="keyword">new</span> CommandSay(),</span><br><span class="line">                <span class="keyword">new</span> CommandTest(),</span><br><span class="line">                <span class="keyword">new</span> CommandVersion()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动机器人, 不会占用主线程</span></span><br><span class="line">        bot.startBot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ol><h3 id="个人实现效果和功能">个人实现效果和功能<a href="2019/10/01/基于酷q平台的管理机器人#个人实现效果和功能"></a></h3><ul><li><p>通知功能</p><img src="/2019/10/01/基于酷q平台的管理机器人/通知.jpg" style="zoom:50%;"></li><li><p>请假功能</p><p>有学生请假则会以json格式文本保存在服务器（或者本地）</p><img src="/2019/10/01/基于酷q平台的管理机器人/请假.jpg" style="zoom: 33%;"></li><li><p>导出请假表格文档，会直接给下载链接</p><img src="/2019/10/01/基于酷q平台的管理机器人/请假文档.jpg" style="zoom: 50%;"></li><li><p>补登请假</p><img src="/2019/10/01/基于酷q平台的管理机器人/补登请假.jpg" style="zoom: 50%;"></li><li><p>还有安卓端的管理app和网页版实时查看数据。</p></li></ul><h3 id="部署机器人">部署机器人<a href="2019/10/01/基于酷q平台的管理机器人#部署机器人"></a></h3><h3 id="用到的库">用到的库<a href="2019/10/01/基于酷q平台的管理机器人#用到的库"></a></h3><hr><ul><li>阿帕奇的表格框架</li><li>gson</li></ul><p>通知管理机器人源代码地址：<a href>冷漠无情的机器人</a></p><p>因为源代码中有不少私人数据，所以取消。</p>]]></content>
      
      
      <categories>
          
          <category> 兴趣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 世界这么大，当然要多去看看 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
