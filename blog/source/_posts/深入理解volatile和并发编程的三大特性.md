---
title: 深入理解volatile和并发编程的三大特性
date: 2020-03-11 17:42:24
tags:
- java并发
categories:
- Java
thumbnail: ../深入理解volatile和并发编程的三大特性/images.webp
---

#  一切之前

**早期**计算机中**CPU**和**内存**的速度是差不多的，但在**现代计算机**中，**CPU的指令速度远超内存的存取速度**,由于**计算机的存储设备**与**处理器的运算速度**有**几个数量级的差距**，所以现代计算机系统都**不得不加入一层**读写速度尽可能接近处理器运算速度的**高速缓存（Cache**）来作为**内存与处理器**之间的**缓冲**：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再**从缓存同步回内存之中**，这样处理器就无须等待缓慢的内存读写了。

## JMM抽象结构模型

**JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式**。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。

从抽象的角度来看，**JMM定义了线程和主内存之间的抽象关系**：线程之间的**共享变量存储在主内存**（Main Memory）中，**每个线程都有一个私有的本地内存**（Local Memory），**本地内存中存储了该线程以读/写共享变量的副本。**

本地内存是JMM的一个**抽象概念**，**并不真实存在**。它涵盖了**缓存、写缓冲区、寄存器以及其他的硬件和编译器优化**。

下面这个图很好的说明了**JMM**的工作方式

![img](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/2615789-8c0b960a27af28db.webp)

那么高速缓存弥补了CPU和内存之间的发展差异，带来了好处，自然就会带来一些问题。

# 可见性

多个线程同时对共享变量进行操作，但是实际的运算是与本地内存和CPU交互，运算结果是线程之间不可见的，只有操作之后将本地内存副本刷新到主存，其他线程再去读取才是最新的值，如果操作完成，还没来得及刷新到主内存，其他线程就会拿到旧值，这样就会对结果造成影响。

在Java中我们就可以使用**volatile关键字**或者是**加锁**来保证可见性

被volatile修饰的变量一旦被更改就会立即把结果刷新到主内存，保证了变量的可见性。

# 原子性

原子性是指**一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉**。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。

# 有序性

## 重排序

根据Java内存模型中的规定，可以总结出以下几条happens-before规则8。Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。

- 程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。
- 监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。
- volatile变量法则：**对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。**
- 线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。
- 线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。
- 中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。
- 终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。
- 传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C



# volatile

* volatile可以保证可见性，数据一旦修改可以及时更新到主存，可以杜绝更改之后没来得及刷新到主存而其他线程读取旧值而造成的异步问题
* volatile可以一定程度上保证有序性
  1. 所有在 volatile 修饰的变量写操作之前的写操作，将会对随后该 volatile 修饰的变量读操作之后的语句可见。
  2. 禁止 JVM 重排序：volatile 修饰的变量的读写指令不能和其前后的任何指令重排序，其前后的指令可能会被重排序。

