---
title: 类加载和类加载器
date: 2020-04-01 13:06:43
tags:
- 干货
categories:
- Java
---

## 类加载流程

**链接和加载时并行的，没有谁先再后的先后顺序，涉及到源码中对链接的方法的调用**

### 加载

”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：

- 通过一个类的全限定名来获取其定义的二进制字节流
- 将这个字节流所代表的的**静态存储结构**转化为**方法区**中的**运行时数据结构**（初始化）
- 在**堆**中生成一个代表这个类的Class对象，作为**方法区**中这些数据的访问入口。

至于JVM的内存管理和分区结构大致是以下



相对于类加载的其他阶段而言，加载阶段是**可控性最强**的阶段，因为程序员可以使用系统的类加载器加载，还可以使用自己的类加载器加载（从网络，本地，或者任意地方加载字节码文件）。

**类加载器的作用就是上面虚拟机需要完成的三件事，我们定义的类加载器也是一样**

### 链接

* 验证

  保证格式正确，符合java语法规范，不会对`jvm`造成危害

  * 文件格式验证，是否符合class文件的格式的规范
  * **元数据**验证，对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求
  * 字节码验证，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
  * 符号引用验证，发生在**虚拟机将符号引用转化为直接引用**的时候。主要是对类自身以外的信息进行校验。目的是**确保解析动作能够完成**。

* 准备

  准备类变量（静态变量），赋默认值

* 解析

  解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。什么是符号应用和直接引用呢？
  
  - 符号引用：
  
    以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）
  
  - 直接引用：
  
    是可以指向目标的**指针**、**相对偏移量**或者是**一个能直接或间接定位到目标的句柄**。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。解析动作主要针对**类或接口**、**字段**、**类方法**、**接口方法**、**方法类型**、**方法句柄**和**调用点限定符**7类符号引用进行。

### 初始化

执行类构造器<cinit>

* 有父类，但是父类还没有被初始化先执行父类的初始化

  ```java
  public class Animal {
      static {
          System.out.println("Animal");
      }
  }
  ```

  ```java
  public class People extends Animal {
      static {
          System.out.println("People");
      }
  }
  ```

  ```java
  public class Main {
      public static void main(String[] args) {
          People people = new People();
      }
  }
  ```

  > ```
  > 输出：
  > Animal
  > People
  > ```

* 同一个命名空间只会初始化一次

  > 类加载器的**命名空间**是由类加载器**本身以及所有父加载器**所加载出来的`binary name`(`full class name`)组成.
  >
  > * 在同一个命名空间里，不允许出现二个完全-样的`binary name`。
  > * 在不同的命名空间种，可以出现二个相同的`binary name`。当时二者对应的Class对象是相互不能感知到的，也就是说Class对象的类型是不一样的。
  > * 子加载器的命名空间中的binary name对应的类中可以访问父加载器命名空间中`binary name`对应的类，反之不行

### 两个重要的init方法

#### init

是instance实例构造器，对非静态变量解析初始化

#### **clinit**

是class类构造器对静态变量，静态代码块进行初始化

方法是由编译器**自动收集类中的所有类变量的赋值动作和静态语句块**（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，

静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不可以使用，会报非法前置引用的错误。

例如：

```java
static {
    a = 0;//可以，因为在链接中的准备阶段就已经准备好了这个变量，这里相当于重新赋值
    System.out.println(a);//不可以，会被提示非法前置引用
}
static int a = 0;//真正对程序员所期望的初始值进行初始化
```

### 相关例子

#### 经典面试题

```java
class Person{
    static int a;
    static int b = 0;
    static Person instance = new Person();


    Person(){
        a++;
        b++;
    }
}

public class Main {

    public static void main(String[] args) {
        Person person = Person.instance;
        System.out.println(Person.a);
        System.out.println(Person.b);
    }
}
************************************
输出：
    1
	1
************************************
    
/**
*  将Person类中的
*  static Person instance = new Person();
*  提到最前面
*/
class Person{
    static Person instance = new Person();
    static int a;
    static int b = 0;


    Person(){
        a++;
        b++;
    }
}

public class Main {

    public static void main(String[] args) {
        Person person = Person.instance;
        System.out.println(Person.a);
        System.out.println(Person.b);
    }
}
************************************
输出：
    1
    0
************************************
```

**原因：**

原因在准备

## 类加载器

* `BootstrapClassLoader`

  由C实现

* `ExtensionClassLoader`

  由java实现，继承于`ClassLoader`

* `ApplicationClassLoader`

  由java实现，继承于`ClassLoader`

* 自定义加载器

  必须继承`ClassLoader`，默认父加载器为`ApplicationClassLoader`，可通过重写构造器自定义父加载器

  源码中给出的Demo

  ```java
  class NetworkClassLoader extends ClassLoader {
      String host;
      int port;
  
      public Class findClass(String name) {
          byte[] b = loadClassData(name);
  		//defineClass最终调用native方法，返回一个Class对象
          return defineClass(name, b, 0, b.length);
      }
  
      private byte[] loadClassData(String name) {
          // load the class data from the connection
          //加载字节码并返回一个but数组，来源不限，可以是网络、本地或者专有数据库中的class文件
      }
  }
  ```



**注意：有层级关系，相互没有继承关系**



### 双亲委派模型

简单来说，一个类似于“android中的事件分发的流程”

加载类时依次向上层层调用，请求上层查找并加载，若上层不能查找或者加载到，自己加载或者查找

`java.lang.ClassLoader.java`加载类关键代码

```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized(this.getClassLoadingLock(name)) {
        Class<?> c = this.findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();

            try {
                //判断父加载器是否为空
                if (this.parent != null) {
                    //有，则优先调用父加载器的loadClass加载方法，层层调用
                    //上面一层的也会这样要父加载器加载
                    c = this.parent.loadClass(name, false);
                } else {
                    //父加载器为空，则使用启动类加载器来加载
                    c = this.findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException var10) {
            }
            //判断c是否为空
            //为空？表示当前类加载器的所有上层加载器都不能找到或者加载此类
            //不为空？表示当前类加载器的某个上层加载器已经找到或者加载此类，并返回了Class对象
            if (c == null) {
                long t1 = System.nanoTime();
                c = this.findClass(name);
                PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                PerfCounter.getFindClasses().increment();
            }
        }

        if (resolve) {
            this.resolveClass(c);
        }

        return c;
    }
}
```

### 优点

- 避免类的重复加载

- 保护程序安全，防止核心API随意篡改

  > 如何保护？例如：自定义类:java.lang. String
  >
  > ```java
  > package java.lang;
  > 
  > public class String {
  >     public static void main(String[] args) {
  >         System.out.println("假的String里面");
  >     }
  > }
  > ```
  >
  > 自己建一个全类名跟String一样的类，如果这个类在java中的String类之前被加载，那么Java Api中的String会被我这个String替换，并且不再加载java自己的String。

## 加载时机

### 必须要有类去主动使用该 Class。

* 使用 new 关键字、反射、克隆、反序列化；
* 调用类的静态方法
* 调用一个类的子类的时候会初始化其父类
* 包含 main() 方法的类（相当于第二条）。

### 被动使用则不会去装载 Class。

* 调用了其父类的静态方法

  ```java
  public class Animal {
      static {
          System.out.println("Animal");//类被初始化会打印Animal
      }
  
      static String getValue() {
          return "getIntValue";
      }
  }
  ```

  ```java
  public class People extends Animal {
      static {
          System.out.println("People");//类被初始化会打印People
      }
  }
  ```

  ```java
  public class Main {
      public static void main(String[] args) {
          System.out.println(People.getValue());//调用People类的getValue
      }
  }
  ```

  ```
输出：
  Animal
  getIntValue
  ```
```
  
  表明`getValue()`这个静态成员是Animal的就一定是Animal的，其实`People.getValue()`就等价于`Animal.getValue()`

## 只加载不初始化

​```java
public class People extends Animal {
    static {
        System.out.println("PeopleLoad");
    }
}
```

```java
public class Main {
    public static void main(String[] args){
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        Class mClass = classLoader.loadClass("People");
    }
}
```

```
输出：
People
```

静态代码块没有执行，说明此时<cinit>方法还没有被调用，说明只加载没有初始化，原因在哪？

`java.lang.ClassLoader#loadClass(java.lang.String, boolean)`，这个方法的第二个参数，就是控制链接的默认调用`loadClass`传入的时false，如果传入true最后会调用native方法进行链接

```java
public Class<?> loadClass(String name) throws ClassNotFoundException {
    return loadClass(name, false);
}
```

## 既加载又初始化

上面举了很多例子，我们看一个关键的

还是下面这一些代码

```java
public class People {
    static {
        System.out.println("PeopleLoad");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        Class.forName("People", true, classLoader);
    }
}
```

```
输出：
PeopleLoad
```

