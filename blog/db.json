{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/inside/source/runtime.1720a40670866f12654e.js","path":"runtime.1720a40670866f12654e.js","modified":0,"renderable":1},{"_id":"themes/inside/source/styles.e4c22be5bb2c26eab146.css","path":"styles.e4c22be5bb2c26eab146.css","modified":0,"renderable":1},{"_id":"themes/inside/source/polyfills.69a7b8a907a7ac9da988.js","path":"polyfills.69a7b8a907a7ac9da988.js","modified":0,"renderable":1},{"_id":"themes/inside/source/main.12c3a04fa47641f902c2.js","path":"main.12c3a04fa47641f902c2.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/inside/.gitignore","hash":"f964b070d203c5e8555d4cc0ecafe1ecaac88079","modified":1584249177000},{"_id":"themes/inside/.npmignore","hash":"d915719edb8ad31014b418cda42e6a8c76db1bfa","modified":1584249177000},{"_id":"themes/inside/.travis.yml","hash":"701789731bdf1e796a85e4b392ec28702a882c80","modified":1584249177000},{"_id":"themes/inside/LICENSE","hash":"80e42bdfa4902549136f3a2445f16bff8ec46be8","modified":1584249177000},{"_id":"themes/inside/README.md","hash":"5943089a4be23d5cf17e6f1ebec59fe6182ffbd6","modified":1584249177000},{"_id":"themes/inside/README_zh-Hans.md","hash":"0f2e7a71be635794f8bd3e70a488f20e1dce7366","modified":1584249177000},{"_id":"themes/inside/_config.yml","hash":"238d33452a001a6efc9caf92f6818a4ae0b8a6c0","modified":1585934652536},{"_id":"themes/inside/package.json","hash":"3e9d77b2c3360071c81d466427cb333490477848","modified":1584249177000},{"_id":"themes/inside/renovate.json","hash":"767b077c7b615e20af3cf865813cd64674a9bea6","modified":1577674257706},{"_id":"themes/inside/avatar.jpg","hash":"134799fe7cfdb7da7ad5160aaa4360d5cc68865a","modified":1585637809419},{"_id":"source/_discarded/erride浅认识.md","hash":"e713df473d74dc422c4fef67f8e92f225496b84a","modified":1577674250738},{"_id":"source/_discarded/idea.md","hash":"1bc3c31c8caa5e936399bb5a99ec61a62372dd55","modified":1577674250739},{"_id":"source/_discarded/java程序编译运行过程.md","hash":"1a2da64708da6fa5a9ae3d42f52e54413b88fcbf","modified":1577674250740},{"_id":"source/_discarded/linux服务器测试.md","hash":"511332294fcbfb0e9a3ae2d832c755a8fc3580a4","modified":1577674250740},{"_id":"source/_discarded/测试.md","hash":"3aeb867360970fa535a0355f017b11126bd3379d","modified":1577674250741},{"_id":"source/_posts/Android消息机制深入了解.md","hash":"79e699d4d2511b98d4f7cac1691f96c5dd84e64d","modified":1583832892701},{"_id":"source/_discarded/试.md","hash":"7d794d0699ddc11f754b7cffdd1ac45cfd3c5175","modified":1577674250743},{"_id":"source/_discarded/试第二篇.md","hash":"5d5ad89109989ca2088d318a74bd0c0e23d972dc","modified":1577674250743},{"_id":"source/_posts/JVM-内存管理和垃圾回收.md","hash":"7245b905e134280507abb91a202f180f1ce6b36e","modified":1585877597399},{"_id":"source/_posts/JVM-操作指令记录一览.md","hash":"fa1eb842b58467e55cc66259b3eb3688514434e7","modified":1585846941166},{"_id":"source/_posts/eclipse的常用15个快捷键.md","hash":"980871dc771c928943b96173e6965f74e05e4ac6","modified":1577674250746},{"_id":"source/_posts/fitsSystemWindows相关总结.md","hash":"3f070629bf7f1124d0f564fcc1c99c63ee952b0d","modified":1585793413208},{"_id":"source/_posts/git-push-解决-弹出用户名和密码输入框.md","hash":"3b3bd7c6d624d580ef75ac58e3a3e27a23ae7a44","modified":1577674250749},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git.md","hash":"29173f5e66259303d78da2a7970d93ecf0662fc8","modified":1585856069721},{"_id":"source/_posts/gitignore忽略文件总结.md","hash":"232d90fbf0cf2cd722a490676d62cfc69fefae1b","modified":1577674250751},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台.md","hash":"c6c6f6d2c6e938fbee87e61a96fd1376b5b42ce4","modified":1577674379424},{"_id":"source/_posts/hexo下完美插入图片.md","hash":"643b21882769439f527ce18b0febc58494ba8eb5","modified":1577677134488},{"_id":"source/_posts/idea条件断点.md","hash":"edcf4a20e3b67dda6e8d090647775949d78a666d","modified":1577674250780},{"_id":"source/_posts/java编译运行过程详解.md","hash":"5688aff0d35b3fc6cac95c40d84a7aa1857cd5cc","modified":1585857025592},{"_id":"source/_posts/java面向对象-接口和其他的类.md","hash":"4f8e6755cb3278145c8f0b5d53c3e0c5e52cc1fc","modified":1577676252068},{"_id":"source/_posts/ssh用法及命令.md","hash":"dd617ffb08b7a26ad417d13f0b24d8c3f8aa37cd","modified":1577674250957},{"_id":"source/_posts/linux后台运行程序.md","hash":"300515ad336a7009883e23cd2614e9c3e887f9c2","modified":1577674250956},{"_id":"source/_posts/windows脚本转移Linux上git命令出现错误.md","hash":"c86667ddef600194112d5586fc4143581914cec5","modified":1577674250958},{"_id":"source/_posts/基于酷q平台的管理机器人.md","hash":"a27fa35ffbc02f0dd637fd4aff8d9e9593a18578","modified":1577675807531},{"_id":"source/_posts/kotlin的let、with、run、apply、also系列方法记录.md","hash":"ce392bea0dfcc8504ba2dae533cc606cb4dfebec","modified":1585247173034},{"_id":"source/_posts/深入理解volatile和并发编程的三大特性.md","hash":"6355a4ee04af79e87db1535eb6498b4e37ffeefa","modified":1585855866984},{"_id":"source/_posts/当Activity异常销毁FragmentManager做了什么.md","hash":"7461266c76988ca8b279bef3e16142850bfd5aa1","modified":1585855572683},{"_id":"source/_posts/类加载和类加载器.md","hash":"8e25ddf86238b4c29b40a8d66f632d551e94aecd","modified":1585844077851},{"_id":"themes/inside/.idea/.gitignore","hash":"ad447d79434407a59685457ae45f6182504b5ce3","modified":1585881253884},{"_id":"themes/inside/.idea/inside.iml","hash":"32fca3a41af0e658297ab10969630d1f8f1548b4","modified":1585881252210},{"_id":"themes/inside/.idea/misc.xml","hash":"0d81a7654b3ab7b1fa88a882ac9120820be781d1","modified":1585881252259},{"_id":"themes/inside/.idea/modules.xml","hash":"78a9cd02055cd47dbf8cf0efdcf3a6861dae6353","modified":1585881252335},{"_id":"themes/inside/.github/stale.yml","hash":"cd81583c047c8835799a242566338b48271a67dd","modified":1584249177000},{"_id":"themes/inside/.idea/vcs.xml","hash":"96e29b872a2466250649fbf2d0162ee284f6e7d2","modified":1585881252291},{"_id":"themes/inside/languages/en.yml","hash":"bc83e56a99531ff82dcd7b6f752a4db0980d3dee","modified":1584249177000},{"_id":"themes/inside/languages/ja.yml","hash":"6c2c935a56347de087806b1ae7644f484994fe3c","modified":1584249177000},{"_id":"themes/inside/languages/zh-Hans.yml","hash":"15b218fbd2b6ef91040308387a310f03a12615d6","modified":1585935049600},{"_id":"themes/inside/languages/zh-Hant.yml","hash":"46ca125b558357420e827b9d276a09777edcd914","modified":1584249177000},{"_id":"themes/inside/languages/default.yml","hash":"98ef0c5ca2cba4c2c4d73f272d1d7169dee12812","modified":1577674251151},{"_id":"themes/inside/layout/index.swig","hash":"d988e7dab80fed20e2a858c0a0940fc85bc54f42","modified":1584249177000},{"_id":"themes/inside/layout/index.ejs","hash":"64a3921152fecfecd4b97c5959f6e4103661061c","modified":1577674251157},{"_id":"themes/inside/lib/config.js","hash":"c120bf232d1b8048e6adb8de3905e455ddd98fdf","modified":1584249177000},{"_id":"themes/inside/lib/configSchema.json","hash":"7639e5bf7af76c2f6d0b2c4653d89ff14225b8c3","modified":1584249177000},{"_id":"themes/inside/lib/utils.js","hash":"0c7093069fb3c5476663d1ebafe045cf35813c37","modified":1584249177000},{"_id":"themes/inside/package-lock.json","hash":"15a2294ce8eaff690301c3f37a4f604c6fd615fa","modified":1577674257706},{"_id":"themes/inside/scripts/index.js","hash":"2163e057444c2e5e3b786d28500e9cc5467e3c6b","modified":1584249177000},{"_id":"themes/inside/source/_resources.json","hash":"27f84fd6cddb69ca017081d23abf34274559fefd","modified":1584249177000},{"_id":"themes/inside/source/_theme.js","hash":"f5958405981e0e7eb7e651e4879200127e947b0f","modified":1584249177000},{"_id":"themes/inside/source/runtime.1720a40670866f12654e.js","hash":"a9aafcf49f49145093fc831efd9b8e2f6c71bb9c","modified":1584249177000},{"_id":"themes/inside/source/styles.e4c22be5bb2c26eab146.css","hash":"6a7d08ce8a92182056610a6d1690c73ae227b615","modified":1584249177000},{"_id":"themes/inside/test/README.md","hash":"96cdb8d68278f099ebfc9c7f6a4745da622e34dd","modified":1584249177000},{"_id":"themes/inside/test/index.js","hash":"7e176517c76fd7f876a1882e52a5ce2bc36c0a8a","modified":1584249177000},{"_id":"themes/inside/test/jasmine.json","hash":"8a6ad42f0a1d94c252d041f18ee63669b660b15d","modified":1584249177000},{"_id":"themes/inside/source/runtime.caef73fae70e33459c5a.js","hash":"a9aafcf49f49145093fc831efd9b8e2f6c71bb9c","modified":1577674257725},{"_id":"themes/inside/source/styles.d1f4718a192abf1f2afd.css","hash":"91da83c8a34febffbdf5abc63462246e37daaa87","modified":1577674257726},{"_id":"themes/inside/source/polyfills.69a7b8a907a7ac9da988.js","hash":"178c0a6a1222a596772e5b833cec9b7d9055bb0a","modified":1584249177000},{"_id":"themes/inside/source/polyfills.28555e618578fe61f50a.js","hash":"3f2bda6f4ad460988984e0da6cd479ef66ea7a79","modified":1577674257725},{"_id":"source/_posts/Android消息机制深入了解/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg","hash":"a81087ccf7956add7c09cbd40e73745094e862f1","modified":1583832892708},{"_id":"source/_posts/Android消息机制深入了解/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg","hash":"232312a78e85208225f35f9df8a37050d87a4446","modified":1583832892707},{"_id":"source/_posts/Android消息机制深入了解/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg","hash":"3c4216a67248746066d6bd5033c3a36ccffce9c1","modified":1583832892710},{"_id":"source/_posts/Android消息机制深入了解/v2-639605533bdb1ecf1c6562677a430554_hd.jpg","hash":"087ac8d46d0946457e98a82e0bfadee4f3559545","modified":1583832892711},{"_id":"source/_posts/Android消息机制深入了解/v2-8312b637ba6407992515ffa42b56391d_hd-3736965.jpg","hash":"81e1e710afd40c412b79288432dfee2c02a8f0d3","modified":1583832892714},{"_id":"source/_posts/Android消息机制深入了解/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg","hash":"75a0ba451bfd30f7ff265c83ab2eeab065ba0b9a","modified":1583832892712},{"_id":"source/_posts/Android消息机制深入了解/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg","hash":"85bb654aff07024e19f4027663ef94cefe613ab4","modified":1583832892713},{"_id":"source/_posts/Android消息机制深入了解/v2-8312b637ba6407992515ffa42b56391d_hd.jpg","hash":"81e1e710afd40c412b79288432dfee2c02a8f0d3","modified":1583832892715},{"_id":"source/_posts/Android消息机制深入了解/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg","hash":"2ee5d3e40edd1e657d7aacfbe27c17c7cf5f47c7","modified":1583832892717},{"_id":"source/_posts/Android消息机制深入了解/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg","hash":"209daf16a5da47347113e44e4fe7dbe1c1857d35","modified":1583832892716},{"_id":"source/_posts/Android消息机制深入了解/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg","hash":"063820033f712cc8cc7ba6fa6518fb543906e495","modified":1583832892718},{"_id":"source/_posts/Android消息机制深入了解/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg","hash":"db5eda171f81699821e486d8a18738fa8333f3fa","modified":1583832892719},{"_id":"source/_posts/JVM-内存管理和垃圾回收/JVM 内存管理总图 (1)-1585846004384.png","hash":"2cb99c80fde2553359fa8260449cc00394c26cc8","modified":1585846004394},{"_id":"source/_posts/JVM-内存管理和垃圾回收/JVM 内存管理总图 (1)-1585848349385.png","hash":"2cb99c80fde2553359fa8260449cc00394c26cc8","modified":1585848349390},{"_id":"source/_posts/JVM-内存管理和垃圾回收/局部变量表 (1).png","hash":"7c8b8bfe20211ee16aa3208447074f7802585538","modified":1585847729869},{"_id":"source/_posts/JVM-内存管理和垃圾回收/局部变量表.png","hash":"adc9bec27975f0b6f4217a8325c0ce51b72ff7b5","modified":1585847594357},{"_id":"source/_posts/JVM-内存管理和垃圾回收/JVM 内存管理总图 (1).png","hash":"2cb99c80fde2553359fa8260449cc00394c26cc8","modified":1585845988866},{"_id":"source/_posts/git-pull-is-not-a-git-command-See-git-help-Did-you-mean-one-of-these-pull/hexo-theme-inside-1570125970162.svg","hash":"7456ec645b70009f78ed51015e5f9938adde8e83","modified":1577674250747},{"_id":"source/_posts/git-pull-is-not-a-git-command-See-git-help-Did-you-mean-one-of-these-pull/hexo-theme-inside.svg","hash":"8f73bf07e9a1228debed3fb81dbd2361721e041c","modified":1577674250749},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/006szvLFgy1fwll8fpyzdj30b407dq5d.jpg","hash":"7cb43a2ddb99d0ae000c2fdb2b0da2b5b078096d","modified":1577676254963},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023170946.png","hash":"8c2c84045b5abc40f75438a74abcecae21e488de","modified":1577676254952},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/138-1570101275882.png","hash":"2d7c25788eea7b28e9e33ae8b49b21467ba4f367","modified":1577674250752},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/138.png","hash":"2d7c25788eea7b28e9e33ae8b49b21467ba4f367","modified":1577674250752},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/3.png","hash":"07a13b31ca05d5c95fff178e97d9e0184c248001","modified":1577674250755},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003175326.png","hash":"bce32cdb104c7fb34261684d89e8dc4223fa8974","modified":1577674250762},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003180656.png","hash":"73a0ae80e21047a0258502a4795a309f23261147","modified":1577674250762},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003180755.png","hash":"a3699facf1ab1cbeb8a12467ec5ca6c67e31ea21","modified":1577674250764},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003184214.png","hash":"65e75a91158eca5479d0c1c66ee9bf76f9410db9","modified":1577674250766},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003183937.png","hash":"af498cf21cee2c966a863220d3e3568a8bb876fc","modified":1577674250765},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/nh-pluto-moonlight-1570101277085.jpg","hash":"69ebb2aabf2de721b020f86ffd435d159566cb24","modified":1577674250774},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/nh-pluto-moonlight.jpg","hash":"69ebb2aabf2de721b020f86ffd435d159566cb24","modified":1577674250775},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/v2-7461124ec772f6fe453d07554cb11363_hd.jpg","hash":"f923dfebda822c8d8a6fcdfc7a22818284dc66a1","modified":1577674250776},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/v2-d2681a4830e54238450b6dc2a57d0c55_hd.jpg","hash":"d3f1dbb55fbabc7d2bb97b1f928bf5e98407f10f","modified":1577674250779},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/v2-8125794bbf0055917b820178489c7b0f_hd.jpg","hash":"cf2f66586be1363405083e11e9e237da1007521b","modified":1577674250777},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/v2-e11377329d5cef129c0aefd10eaa1607_hd.jpg","hash":"2ac07850c208c6235fe9ba4bbf3036992e35c19c","modified":1577674250779},{"_id":"source/_posts/hexo下完美插入图片/TIM截图20191230113452.png","hash":"49a3488e81d2e23b0422a223a914a0fea0496155","modified":1577676922350},{"_id":"source/_posts/java面向对象-接口和其他的类/006APoFYjw1fbw78x1kr4g308c08caa2-1571887367591.gif","hash":"ad02d81a7e07584e89d93419352d9bec83d2553e","modified":1577674250789},{"_id":"source/_posts/java面向对象-接口和其他的类/006APoFYjw1fbaq3q6p2xj304j050weh.jpg","hash":"ede4ab51ef1c850e710e03eff10218110649253f","modified":1577674250789},{"_id":"source/_posts/java面向对象-接口和其他的类/006APoFYjw1fbw78x1kr4g308c08caa2.gif","hash":"ad02d81a7e07584e89d93419352d9bec83d2553e","modified":1577674250791},{"_id":"source/_posts/java面向对象-接口和其他的类/006szvLFgy1fwll8fpyzdj30b407dq5d.jpg","hash":"7cb43a2ddb99d0ae000c2fdb2b0da2b5b078096d","modified":1577674250792},{"_id":"source/_posts/java面向对象-接口和其他的类/1571820564925.jpeg","hash":"949bef68598d8ed7af70e4e89f83da768ee2c101","modified":1577674250797},{"_id":"source/_posts/java面向对象-接口和其他的类/1571820567750.jpeg","hash":"4688e4b037b970bb42ba89e0ace2ee2a9f04bccd","modified":1577674250797},{"_id":"source/_posts/java面向对象-接口和其他的类/164336559DA3C001F7D365CBC0A67998.jpg","hash":"911cdd0cc72ef647cc0cc8f2465d9ce96192f7ed","modified":1577674250798},{"_id":"source/_posts/java面向对象-接口和其他的类/415f82b9ly1fpg6be2pudj20c8096759.jpg","hash":"e6cfeb90424a35cc8fb355830077ed64cdf525b6","modified":1577674250801},{"_id":"source/_posts/java面向对象-接口和其他的类/6af89bc8gw1f8tzvsvn8gj20a00a00tp.jpg","hash":"f813e9cb3d59e59466febede785adb964c634363","modified":1577674250830},{"_id":"source/_posts/java面向对象-接口和其他的类/9150e4e5gy1g6o895cawsj20sg0sg76j.jpg","hash":"93895730d74bba022a17077d5c7e8376fc97e944","modified":1577674250832},{"_id":"source/_posts/java面向对象-接口和其他的类/9150e4e5ly1fd7l5931vij202201u3ya.jpg","hash":"116af0b15be15d8a1b80cdd6cb4f949ff2336d2c","modified":1577674250833},{"_id":"source/_posts/java面向对象-接口和其他的类/9150e4e5gy1g19qh568dmj206o06ogll.jpg","hash":"4ac5110d644f079f0659981169ecbd7233377c34","modified":1577674250831},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191022120614.png","hash":"73fd15356d518b98ce5033879cf3269ad94f8581","modified":1577674250834},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023152930.png","hash":"5aac824b3c07a145871852bcb1b1cc59bd461b46","modified":1577674250838},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023152825.png","hash":"694dbb1ad00c88431c66dbb1579b5245d2d8ef41","modified":1577674250837},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023170946.png","hash":"8c2c84045b5abc40f75438a74abcecae21e488de","modified":1577674250852},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191024013553.png","hash":"4dbc84c2f5326c9770d3b9674886f29a332a306f","modified":1577674250868},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191024014025.png","hash":"be0d12b65f11ac1da1df8b2a19fa9de3bddf9408","modified":1577674250869},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191024021220.png","hash":"001cf57588a20ed8b4ed876500e9a8a8ca25dbfe","modified":1577674250870},{"_id":"source/_posts/java面向对象-接口和其他的类/ceeb653ejw1fai8r9ct23j205c05q3yn.jpg","hash":"39c587dbf84ab3976ca2f0c3c14d7daf48f4ff7d","modified":1577674250871},{"_id":"source/_posts/java面向对象-接口和其他的类/ceeb653ejw1faoq48816nj208z0buaan.jpg","hash":"a79604942f1bf7ed828b73b0a6e0f438394f2d7d","modified":1577674250873},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-05aa749d19004c9fea98e84fcea3307f_hd.jpg","hash":"035dfd67908e31110719a130d9e27c601ee2d273","modified":1577674250878},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-02ffe126c98c17d03a83adad5f65938b_hd.jpg","hash":"61a21d6c4cc14719495be5f6db88d1ce43d843e7","modified":1577674250877},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-13d572e979351e77f984cd5b38a019b3_hd.jpg","hash":"12e776423f5ff3ad8d3d3ff7024d653f79202434","modified":1577674250881},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-0bc6bbbfcf6d855c832b055aae892f1a_hd.jpg","hash":"226415bcd81affffdc8a671da43798b0a901eb49","modified":1577674250879},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-114ee3caaad0d612d39818c9f3f81201_hd.jpg","hash":"b7b501975c7bc98720fd4fa38ea4f46272d833e7","modified":1577674250880},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-1a566b02828b4759584f5a5e6fee2903_hd.jpg","hash":"7646830f2c25366055b90607aaef539f85dc7209","modified":1577674250882},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-23b4f1f3873f02b9e9abd2d1ab30a73f_hd.jpg","hash":"4b1989fb78d29d450bfe468e9a2ad369dcec2d91","modified":1577674250883},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-24c27adb48dfeffc6de36260df10bad5_hd.jpg","hash":"12fb386c662434befdf82c9649a53ea59392aacc","modified":1577674250885},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-2b4d1f67bd8f8aaecb32920c58cd687c_hd.jpg","hash":"fb9895edafe6f9215e2ec07ada5664fbe63ce25d","modified":1577674250887},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd.jpg","hash":"232312a78e85208225f35f9df8a37050d87a4446","modified":1577674250888},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg","hash":"232312a78e85208225f35f9df8a37050d87a4446","modified":1577674250887},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-308d4b287931127b020ac4cc861a1757_hd-1571838917313.jpg","hash":"f537c6f238a5bf66f8fdb02b1ff05208e7ef3b9a","modified":1577674250889},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg","hash":"f537c6f238a5bf66f8fdb02b1ff05208e7ef3b9a","modified":1577674250890},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-308d4b287931127b020ac4cc861a1757_hd.jpg","hash":"f537c6f238a5bf66f8fdb02b1ff05208e7ef3b9a","modified":1577674250891},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-325a1104a87fafd601284c628fa6aea9_hd.jpg","hash":"53ca1466b69cc9172dabd04cdac33a1fa9b46aad","modified":1577674250892},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-32be84269f9e3bc3722df3635792a959_hd.jpg","hash":"7106ae6cc64423d29925b3fb5f8fdbd2c2f8dae1","modified":1577674250894},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-32db3eeb7c9cb282553504e2c1108130_hd.jpg","hash":"035c50c77a4e981f46a6803169086378f73b60e0","modified":1577674250895},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-45a9abdf48e6be17cb8d9e31b53578f9_hd.jpg","hash":"ec3c924a9bf2439929f2065279893e59a810784c","modified":1577674250896},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-4d0519e265a57a53b7f92599fce86a9c_hd.jpg","hash":"34ec0a858ff31f27344689ba5df350bbd5c2499e","modified":1577674250898},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-45b057e23dd633692fb0154f4a09ca49_hd.jpg","hash":"a1ea99da0e3380c0d3203f8716c5e5923f2c5408","modified":1577674250897},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg","hash":"a81087ccf7956add7c09cbd40e73745094e862f1","modified":1577674250899},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd.jpg","hash":"a81087ccf7956add7c09cbd40e73745094e862f1","modified":1577674250900},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-52943cfec07e50eccbe2b6f6e4c7afcb_hd.jpg","hash":"adff84c52928c8ef77de60e07c0d39765ce89d66","modified":1577674250901},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg","hash":"ed3f98de747153d1b73f1a3593955b67acfd90d7","modified":1577674250904},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-53ac2d7b9f62a8ff17b795cc73570734_hd.jpg","hash":"17062479f2360a5c6c9ef8aeb4163ff7348af180","modified":1577674250903},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg","hash":"3c4216a67248746066d6bd5033c3a36ccffce9c1","modified":1577674250906},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd.jpg","hash":"ed3f98de747153d1b73f1a3593955b67acfd90d7","modified":1577674250905},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-61c75070123da9b76126716abb4c0dc0_hd-1571843419436.jpg","hash":"97cc48ee1dde132cd597952cc72e5f500a023fd7","modified":1577674250907},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-61c75070123da9b76126716abb4c0dc0_hd.jpg","hash":"97cc48ee1dde132cd597952cc72e5f500a023fd7","modified":1577674250909},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-639605533bdb1ecf1c6562677a430554_hd.jpg","hash":"087ac8d46d0946457e98a82e0bfadee4f3559545","modified":1577674250911},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg","hash":"75a0ba451bfd30f7ff265c83ab2eeab065ba0b9a","modified":1577674250911},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-621e04e365e7d4a385575811df365d92_hd.jpg","hash":"bfa2a662224f9edd3579f29b0d03a38e0923a640","modified":1577674250909},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-71abcc971fa6b70a60fed90756317c19_hd.jpg","hash":"c5a6a3223183058bc44f5e542c40fc8789d80add","modified":1577674250913},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-746b68b4c2149a0faef9f4ec9a4e8e92_hd.jpg","hash":"e3537aab6ccdedd82f8285a46a46b080fdeae49c","modified":1577674250915},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-72c27a074e1feb699849c4d9d8c2614c_hd.jpg","hash":"4d747c55c8f40009a03c1ae3ed68b591eaa088fe","modified":1577674250913},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg","hash":"85bb654aff07024e19f4027663ef94cefe613ab4","modified":1577674250917},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-7a637419db11fb84c062b0361a4045db_hd.jpg","hash":"d8205f66008d27d523285f33f46d95fd9b47e37f","modified":1577674250918},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-75af770ceb10d0dcfbf702142f5c625b_hd.jpg","hash":"642643c142544e26eb51bb90eca597cef2f0eb55","modified":1577674250916},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-7e64adbe12f97ac1fb00fc17d7d72f28_hd.jpg","hash":"2255e8aab77ba112f3ce0853b1f49c819c7a2ebe","modified":1577674250919},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-81940f37a0165b0459cb03241922e3ee_hd.jpg","hash":"43609167dc2770416d948b7d2536973faf396fc2","modified":1577674250920},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-8312b637ba6407992515ffa42b56391d_hd.jpg","hash":"81e1e710afd40c412b79288432dfee2c02a8f0d3","modified":1577674250921},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-87072b9873cd5e8703a473b191e17042_hd.jpg","hash":"3ba503104d1b08cb76d2aa4fc8f161b78b27f4fc","modified":1577674250922},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-8c6c3bde98e8cf206839bf57085af02e_hd.jpg","hash":"4df2b0569b0e01b53f8918d00cf34d232f012607","modified":1577674250924},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-8a2e689837fdbbbf4b1ab294f9b8dd1e_hd.jpg","hash":"d6bea41bfc1329e674d28339c74aa7af27d5ef50","modified":1577674250923},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-99e68ddacf27251a57bfffc82a43a2a0_hd.jpg","hash":"c833dd8452ac664ca07291b3e78016d877f59436","modified":1577674250927},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-8da4b48b8262d2786486cb942571be4c_hd.jpg","hash":"1ab6fed473490688dfe5a68259ead0897a26185c","modified":1577674250926},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg","hash":"209daf16a5da47347113e44e4fe7dbe1c1857d35","modified":1577674250928},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-8d05da004dc65b91ffa63dcc213b7714_hd.jpg","hash":"3e1eb6cd6ca0c5b77b36aea26489cc789cfd57d9","modified":1577674250925},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg","hash":"2ee5d3e40edd1e657d7aacfbe27c17c7cf5f47c7","modified":1577674250930},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-a11eadf17f85c2caef8ac2e391d0cf69_hd.jpg","hash":"989fec73b1bf04ae477020cc2b96091ce94544b6","modified":1577674250929},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-a67b056f65147bc9971073f6b23d2aa3_hd.jpg","hash":"db7f525828044b38e311143d28b9b1dcb3564e8e","modified":1577674250931},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-aafe63145f01d7c98b9ca567484a2dea_hd.jpg","hash":"0b71afb5cebebd79fe702172b65e558878fc3b1e","modified":1577674250933},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-a959fa53966fc0b6400f88c50b8b95e3_hd.jpg","hash":"ba629521c9c423cf47f7db9a61232de17a6c16fb","modified":1577674250932},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-acb2c980db4a235ed0538f34d9c2918d_hd-1571748707404.jpg","hash":"338929d1e24b96c333ccbc28af2d2c8f98c76410","modified":1577674250934},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-acb2c980db4a235ed0538f34d9c2918d_hd.jpg","hash":"338929d1e24b96c333ccbc28af2d2c8f98c76410","modified":1577674250935},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-bc2e4a10498c1b64a01628d0df373856_hd.jpg","hash":"6aeded7efa9be70a4ea2ddfcb0f751fb11d77a3f","modified":1577674250937},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-afd6a92d4313b460829bf99b7ef3759e_hd.jpg","hash":"660aff8cd806b6784c27520020950bb6d0dacb03","modified":1577674250936},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-bffbbe33c937ceb498d0882bf21a651c_hd.jpg","hash":"02ae4fb3ba32e2e38e2368c6603545cbd4ba6c8e","modified":1577674250939},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-c4f54c756177054f05115c55be8058d7_hd.jpg","hash":"7672551f9f9962db143cc05bc28cfda84579b06f","modified":1577674250939},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-bdb493d4a6d79ffa93fe78c71a2fd1a8_hd.jpg","hash":"eb015a5590cfb64493ddf34313f16a589b5e1691","modified":1577674250937},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg","hash":"063820033f712cc8cc7ba6fa6518fb543906e495","modified":1577674250942},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-c73dbda0a22ac613aa85548743e89311_hd.jpg","hash":"6362fa291b45c5bb02f7672c2dd246b693c56210","modified":1577674250941},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-cb5372ddead7e3c2bfcbc8e50e5e941f_hd.jpg","hash":"c63933453d5100563d446589c768eeaa86d8dd78","modified":1577674250943},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-d238eb952899a0a26dd5b66a36f76c56_hd.jpg","hash":"886d12e4fd554f357ca71e87cf1694549de1d284","modified":1577674250944},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-daba4efa3f71587ad62c168eeb711a01_hd.jpg","hash":"5bb7d64bd91b0b8a7df48bb1fa8ae5688c846c44","modified":1577674250946},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-cf3a3ed1086e56442c381a3ee8a1fee9_hd.jpg","hash":"b8d9f25779ac433fb575aaad7a20662227facc39","modified":1577674250943},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-db4581e2b067caef5a9586f7eebdf201_hd-1571838820692.jpg","hash":"46de6bad3900aecc7092d11d75828ebf730bb427","modified":1577674250947},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-db4581e2b067caef5a9586f7eebdf201_hd.jpg","hash":"46de6bad3900aecc7092d11d75828ebf730bb427","modified":1577674250947},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-daba4efa3f71587ad62c168eeb711a01_hd-1571838207875.jpg","hash":"5bb7d64bd91b0b8a7df48bb1fa8ae5688c846c44","modified":1577674250945},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-e36c4694236b67a6e655c77d0e5336cf_hd.jpg","hash":"27f03d70edc62a18eeffa30151a12f5cddb14f81","modified":1577674250949},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-e608e1d4f94a6d0c06f9e9b78d5458b5_hd.jpg","hash":"11c05c624bb653fb36d669f48325b131247da773","modified":1577674250950},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-e015f2d920aa5e00fa4b25d3b6a79bac_hd.jpg","hash":"f1756c4b62008a5e0bdb8a8b4d29b719deec9032","modified":1577674250948},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-ec6f0e0dfb5dc6805387101614784dcf_hd.jpg","hash":"9c17ad9e140778fd4c2e057c714b76e05bf8bff5","modified":1577674250951},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg","hash":"db5eda171f81699821e486d8a18738fa8333f3fa","modified":1577674250953},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-ea2fa82794080c01e783ce025c450116_hd.jpg","hash":"4c9f3ab4aac77bff9a4afad4d77f9d30e67f5633","modified":1577674250950},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-fdddf30851f4370410c068f923e0c405_hd-1571843588629.jpg","hash":"de61b6277043d2cafeeec52fb287eb584e002854","modified":1577674250954},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-fdddf30851f4370410c068f923e0c405_hd.jpg","hash":"de61b6277043d2cafeeec52fb287eb584e002854","modified":1577674250955},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-f50699afeec4929bdc58d56db811bc47_hd.jpg","hash":"c0a1801c758f8ec8da60f3b050ed7a24c341a6a3","modified":1577674250953},{"_id":"source/_posts/基于酷q平台的管理机器人/酷q配置坏境的注意事项.jpg","hash":"063638a3f3fc078ad055c8bba8ab6f53b6126944","modified":1577674250980},{"_id":"source/_posts/当Activity异常销毁FragmentManager做了什么/v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg","hash":"f537c6f238a5bf66f8fdb02b1ff05208e7ef3b9a","modified":1585292676000},{"_id":"source/_posts/当Activity异常销毁FragmentManager做了什么/image-20200327042035621.png","hash":"c39f607f1716f8cf70d14d7ff1a91127880ed66c","modified":1585254035631},{"_id":"source/_posts/当Activity异常销毁FragmentManager做了什么/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg","hash":"ed3f98de747153d1b73f1a3593955b67acfd90d7","modified":1585292655319},{"_id":"source/_posts/安卓Drawable/20160815225834972.png","hash":"0509a388fb6b22b40cb0e8dacd851e2aac7f2b8a","modified":1577674250994},{"_id":"source/_posts/安卓Drawable/20160815231047102.gif","hash":"7f6bd0bc3b998105ef11054a351f31ff5761a1a3","modified":1577674250995},{"_id":"source/_posts/安卓Drawable/20160816083046426.gif","hash":"d945fdd8669cab3b1883ddbc22f7d880b10e93c3","modified":1577674250997},{"_id":"source/_posts/安卓Drawable/20160816085811829.gif","hash":"43aeeec0679781a989e733a95ab1f8a5af48d0c6","modified":1577674250998},{"_id":"source/_posts/安卓Drawable/20160817215859953.png","hash":"b9fa004109a68c107844524e78959f1b757e69a5","modified":1577674251001},{"_id":"source/_posts/安卓Drawable/20160817220944354.gif","hash":"eb3d48facc287828b5f5bc9df7f03569f2cf8347","modified":1577674251003},{"_id":"source/_posts/安卓Drawable/20160817233846388.png","hash":"2941c52dd8c011cf8ec2ab996e2fcea680712276","modified":1577674251011},{"_id":"source/_posts/安卓Drawable/20160818081248786.gif","hash":"93be8e7c14231206cd4d0adb35400ef00f15aaa4","modified":1577674251012},{"_id":"source/_posts/安卓Drawable/20160817231024859.png","hash":"faea4fb89660a68369ea5426a92352262f613263","modified":1577674251011},{"_id":"themes/inside/.github/ISSUE_TEMPLATE/question.md","hash":"9f8004c63012d6b16b6d93f3f10293b84cbdf3f2","modified":1584249177000},{"_id":"themes/inside/.github/ISSUE_TEMPLATE/feature_request.md","hash":"4a5ec7b77092bf55fab55b3a8221197e21d34f35","modified":1584249177000},{"_id":"themes/inside/.github/ISSUE_TEMPLATE/bug_report.md","hash":"551a4ed855c1e3ae3f1ad6176a529caacab70f52","modified":1584249177000},{"_id":"themes/inside/lib/filter/index.js","hash":"aeb29f86ee812ce4d35ac113c6f4b4377a03cf83","modified":1584249177000},{"_id":"themes/inside/lib/filter/templates.js","hash":"86b31cec8512f37824dc4b18c89d0cf7b5987de5","modified":1584249177000},{"_id":"themes/inside/lib/filter/post.js","hash":"322c13feb770f1b972358557e2902ca5feb4f80d","modified":1584249177000},{"_id":"themes/inside/lib/helper/ga.js","hash":"adc62bd06443a781d6046d3e78aa57b5e4291611","modified":1584249177000},{"_id":"themes/inside/lib/helper/index.js","hash":"93fbe9d8fe364cf4e2e55cc3d4d3156dde028f56","modified":1584249177000},{"_id":"themes/inside/lib/helper/structured_data.js","hash":"682cfb827880ccfe5a972bb326ab4691cd8c470d","modified":1584249177000},{"_id":"source/_posts/深入理解volatile和并发编程的三大特性/2615789-8c0b960a27af28db.webp","hash":"f64be5d2c4fc648db88f485f5316ef8d9e595185","modified":1584009484780},{"_id":"themes/inside/lib/helper/url_trim.js","hash":"a88302c028d2667d9336b72b50e0590e0b2edcd1","modified":1584249177000},{"_id":"themes/inside/lib/generator/config.js","hash":"58f26e1f911e71152e38a14eb8e964d611c05639","modified":1584249177000},{"_id":"source/_posts/提取关键词后端api文档/TIM截图20191006182248.png","hash":"509360b3c22a036fefb928e0a12f6d3143206cdc","modified":1577674251015},{"_id":"themes/inside/lib/generator/index.js","hash":"db2de76bb98300e21f6b88d60915a14f799150e1","modified":1584249177000},{"_id":"themes/inside/lib/generator/manifest.js","hash":"e6eb7d3353fb1e13218535a3987cd31d569fc5bd","modified":1584249177000},{"_id":"themes/inside/.github/ISSUE_TEMPLATE/bug-report-----.md","hash":"8cb384a909f538c6d22d3362424375d4332d6390","modified":1584249177000},{"_id":"themes/inside/lib/generator/sitemap.js","hash":"5ab54fccd7a89a4c0e34562b3535120daf37ddc3","modified":1584249177000},{"_id":"themes/inside/lib/generator/sw.js","hash":"216cc78d48e0dd3d0cff374c49bdc8e83b2ecd62","modified":1584249177000},{"_id":"themes/inside/lib/generator/theme.js","hash":"416fa83328d9e99ef073813689bbf361eda28344","modified":1584249177000},{"_id":"themes/inside/lib/tag/canvas.js","hash":"24c02f85506c1f412a3386d14f1ceb074e4864e2","modified":1584249177000},{"_id":"themes/inside/lib/tag/index.js","hash":"bf75dd670a1d6ffffbacb183b406235780d680c6","modified":1584249177000},{"_id":"themes/inside/lib/tag/gist.js","hash":"4bedda6e6c07e2eeac3a3fc97617181287d77d34","modified":1584249177000},{"_id":"themes/inside/lib/renderer/index.js","hash":"41652d45059435540d7e227c92ff36ebc9d7d29a","modified":1584249177000},{"_id":"themes/inside/lib/theme-processor/localized-script.js","hash":"20c24f57f3bd1c01b61078052a8b5397245d731e","modified":1577674251189},{"_id":"themes/inside/lib/theme-processor/index.js","hash":"cf26af9d1a70a6569e26ad8910720bbc13f5bfe0","modified":1577674251189},{"_id":"themes/inside/lib/renderer/md.js","hash":"7eeec5f6e4be599e2e34ac442d54b17b068a7ebf","modified":1584249177000},{"_id":"source/_posts/JVM-内存管理和垃圾回收/JVM 内存管理总图w.png","hash":"2cb99c80fde2553359fa8260449cc00394c26cc8","modified":1585848545868},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/2429e4d2661e60027537aea0077f6e40.png","hash":"1f0f075778c52dbac12e0f697ad11c3a8a24664b","modified":1577676254962},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023163526.png","hash":"be1799fbe833bb5ea878d19fa0fa7274ccc7b9ad","modified":1577676254963},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023163817.png","hash":"ac082e733f5e9e33deb01c3e549c4b502f791e2c","modified":1577676254963},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023165925.png","hash":"ff4be57d20102aa194142e821f14cb7365762980","modified":1577676254963},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023170652.png","hash":"a4bcb0741c737a21ad646597fb72dd53b299c953","modified":1577676254963},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023171200.png","hash":"41d15bdf6267ef39e48bd010a09ad04c41b200ef","modified":1577676254964},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023171820.png","hash":"f29759ec93c2acd08be0839e2e9937b0cfec699e","modified":1577676254964},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023172756.png","hash":"c62dbd1ccd776008797db59e748d3c7a4684b6b6","modified":1577676254964},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023173110.png","hash":"6d73bc3f7fdd4db217c5a99566e138898eda7316","modified":1577676254964},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023175603.png","hash":"ae33020e5ecc6d3b171828aba2029616c507eb99","modified":1577676254964},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023175637.png","hash":"08b11f8ec8cb19732f6ad2909cdbcd4b93f8ea9e","modified":1577676254970},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/2.png","hash":"427d108395c17de5c89de14b6995881499d88c63","modified":1577674250754},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/new p.png","hash":"19e8adee912a36ed4c22ff8f9ab3362c105e6c61","modified":1577674250773},{"_id":"source/_posts/java面向对象-接口和其他的类/2429e4d2661e60027537aea0077f6e40.png","hash":"1f0f075778c52dbac12e0f697ad11c3a8a24664b","modified":1577674250800},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023163526.png","hash":"be1799fbe833bb5ea878d19fa0fa7274ccc7b9ad","modified":1577674250840},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023163817.png","hash":"ac082e733f5e9e33deb01c3e549c4b502f791e2c","modified":1577674250843},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023165925.png","hash":"ff4be57d20102aa194142e821f14cb7365762980","modified":1577674250844},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023170542.png","hash":"a1ab394ff12b8fc556187d5f172462fb5182f46e","modified":1577674250847},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023170652.png","hash":"a4bcb0741c737a21ad646597fb72dd53b299c953","modified":1577674250850},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023171200.png","hash":"41d15bdf6267ef39e48bd010a09ad04c41b200ef","modified":1577674250855},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023171820.png","hash":"f29759ec93c2acd08be0839e2e9937b0cfec699e","modified":1577674250857},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023172756.png","hash":"c62dbd1ccd776008797db59e748d3c7a4684b6b6","modified":1577674250859},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023173110.png","hash":"6d73bc3f7fdd4db217c5a99566e138898eda7316","modified":1577674250862},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023175603.png","hash":"ae33020e5ecc6d3b171828aba2029616c507eb99","modified":1577674250864},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023175637.png","hash":"08b11f8ec8cb19732f6ad2909cdbcd4b93f8ea9e","modified":1577674250866},{"_id":"source/_posts/java面向对象-接口和其他的类/d.png","hash":"b171cc943c2b5885e8e48c049b4ec44a80477606","modified":1577674250876},{"_id":"source/_posts/基于酷q平台的管理机器人/idea新建项目.png","hash":"0026d0df8f7ae8344dd4253f49cbdb60234d8bb1","modified":1577674250962},{"_id":"source/_posts/基于酷q平台的管理机器人/请假文档.jpg","hash":"3cb4327ce4afdd8ab91c5e7ea2a8e41964fa4f62","modified":1577674250978},{"_id":"source/_posts/基于酷q平台的管理机器人/通知.jpg","hash":"80221ec8da96e102e46d7ce817f55ee7ec7e6f3e","modified":1577674250980},{"_id":"source/_posts/安卓Drawable/20160817080954451.png","hash":"dfcb6cd3abd0bf04701882cb8694cdefa79c69b0","modified":1577674251000},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/m.png","hash":"f2ea5fb7758fdc0db1857962a49e59bbd9835fb7","modified":1577674250773},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003184704.png","hash":"c04aeda1c3d6010a0c5286a7c1a3b22cbf0e6551","modified":1577674250768},{"_id":"source/_posts/基于酷q平台的管理机器人/image-20191113001251371.png","hash":"3b8c135a4ed80449cbc3fb53f1651cf1cea0ad5c","modified":1577674250965},{"_id":"source/_posts/基于酷q平台的管理机器人/补登请假.jpg","hash":"e994bb24b249a20ebdf956a029212dc045dbb785","modified":1577674250970},{"_id":"themes/inside/lib/generator/entries/categories.js","hash":"7675804a6dcfc0fdb789644be2aa87557c826635","modified":1584249177000},{"_id":"themes/inside/lib/generator/entries/archives.js","hash":"e7fd892d1d6bd98853f4302293da1ab207df3ed0","modified":1584249177000},{"_id":"themes/inside/lib/generator/entries/index.js","hash":"dabc6ee5324b9864b2030eee79b7ceb22319e63f","modified":1584249177000},{"_id":"themes/inside/lib/generator/entries/pages.js","hash":"0894e9a02e7580400009f1619ea21ed362ba1811","modified":1584249177000},{"_id":"themes/inside/lib/generator/entries/posts.js","hash":"f0de8451a09a78c330d0f5602bf3e92bf4f690d7","modified":1584249177000},{"_id":"themes/inside/lib/generator/entries/properties.js","hash":"03f68139df2d0566e009ad3acdeaeab08ef52563","modified":1584249177000},{"_id":"themes/inside/lib/generator/entries/tags.js","hash":"e462331c70fa1202e2376bb6a441e2001599f9b4","modified":1584249177000},{"_id":"themes/inside/lib/generator/entries/search.js","hash":"0ecccc181b0140ead9d99ff11f4e5b43132aefc0","modified":1584249177000},{"_id":"themes/inside/test/scripts/filters/index.js","hash":"6d3d9f945edeac1041392db2c8a71d8e4ee8f2ad","modified":1584249177000},{"_id":"themes/inside/test/scripts/filters/post.js","hash":"dbaf2179b0ac15476b5d9c174cf65c6cbfa94de4","modified":1584249177000},{"_id":"themes/inside/test/scripts/filters/template.js","hash":"323fa14f169480769ec68df97d635d80cd5f1b7e","modified":1584249177000},{"_id":"themes/inside/test/scripts/helpers/ga.js","hash":"10922cd6920121846c10f00c27d40bdc1707e2c8","modified":1584249177000},{"_id":"themes/inside/test/scripts/helpers/index.js","hash":"bfefb20e24d48ca6a130e655d862f929d7ffb43c","modified":1584249177000},{"_id":"themes/inside/test/scripts/helpers/structured_data.js","hash":"8878e0177631c71515820bb10c1084c21e4de6f8","modified":1584249177000},{"_id":"themes/inside/test/scripts/helpers/url_trim.js","hash":"2cabd9aa7b6eb7058288fb50d4cd707874260df6","modified":1584249177000},{"_id":"themes/inside/test/scripts/tags/canvas.js","hash":"df3fd748c6c5d5414e4f84be127fbbcdb37250de","modified":1584249177000},{"_id":"themes/inside/test/scripts/tags/gist.js","hash":"fe48de62e60bebb4270ea777385ddb2aa711d51b","modified":1584249177000},{"_id":"themes/inside/test/scripts/tags/index.js","hash":"4ce8c76c53c05fba25bc49fa90a80b75afffa052","modified":1584249177000},{"_id":"themes/inside/test/scripts/utils/index.js","hash":"2bf714d761741f4a4d2e0fb611bcd5155fc69a3d","modified":1584249177000},{"_id":"themes/inside/test/scripts/utils/parseConfig.js","hash":"922aa8f4d7b2cdc29de07d14c1ade62f53759ec8","modified":1584249177000},{"_id":"themes/inside/test/scripts/utils/rest.js","hash":"84149b6ed402774c846d0780219f8c0ed403173c","modified":1584249177000},{"_id":"themes/inside/test/scripts/renderers/index.js","hash":"0d788ca2804bf7f22d30a0501eeef29160af8c47","modified":1584249177000},{"_id":"themes/inside/test/scripts/renderers/md.js","hash":"cf79a0253a388fe526fb97d64bb5d5bb244c6e11","modified":1584249177000},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/Screenshot.png","hash":"861b2ef28e3250ee56a91cdce266d5dc8f3292a2","modified":1577674250758},{"_id":"themes/inside/.idea/workspace.xml","hash":"03b040312ac5180cb35fb028c1489d6ade8cba18","modified":1585857604405},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/github.png","hash":"43751508d8f41718ab54df39c590fbdf3d124c32","modified":1577674250771},{"_id":"source/_posts/基于酷q平台的管理机器人/导包.png","hash":"7e71c94363d693cb15674346a2fd02f69cfc9a1d","modified":1577674250967},{"_id":"themes/inside/source/main.5ac6b548dbff945e028b.zh-Hant.js","hash":"0a4d416d9ccc774a05fd6e34db75cf5438cfe834","modified":1577674257711},{"_id":"themes/inside/source/main.7773219322474154c9eb.zh-Hans.js","hash":"0e51775ffab9d8854431f3fc17901556626bd5ad","modified":1577674257717},{"_id":"themes/inside/source/main.c145738ea9113b8ce68e.ja.js","hash":"1a8ab023e5956ceb75233da09506b47b8f03f693","modified":1577674257723},{"_id":"themes/inside/source/main.a6ef31dc523c76e5118c.js","hash":"47e1bd10a11387d26503b89907ca6b9a671c7dd6","modified":1577674257719},{"_id":"source/_posts/Android消息机制深入了解/QQ20200308-1.png","hash":"2d24ed9d2a3d6bfa3c4b77b8fe6ab3e2cc9864a3","modified":1583832892706},{"_id":"source/_posts/安卓Drawable/20160817223030536.png","hash":"23a00c3e5657a2d61b163dc74a3be9deeef60b52","modified":1577674251006},{"_id":"themes/inside/source/main.12c3a04fa47641f902c2.js","hash":"54f139e174daed0bb6e0a17702e3afd0288cf717","modified":1584249177000},{"_id":"source/_posts/java面向对象-接口和其他的类/1569997947464.png","hash":"18a07e29b984325118ec789ba1acce582971eb5f","modified":1577674250796},{"_id":"source/_posts/idea条件断点/image-20191107003330787.png","hash":"59ffbe8dc2c0d2ac020380998c634f2c4fc1aaf7","modified":1577674250785},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM图片20191003174050.png","hash":"c100e80778dc4f771e11544ebd739b7d909545cd","modified":1577674250760},{"_id":"source/_posts/基于酷q平台的管理机器人/请假.jpg","hash":"1d5ff10c29d7aab41ce2f546bf8ad5ed9782beb4","modified":1577674250976},{"_id":"source/_posts/安卓Drawable/20160817224001080.png","hash":"c54e589e77694e03392b59d4257e164dd78dd49e","modified":1577674251010},{"_id":"source/_posts/安卓Drawable/20160814223852655.png","hash":"831a38065fe932d976e1c1ed1621630cfe9cd77e","modified":1577674250993},{"_id":"source/_posts/java面向对象-接口和其他的类/6af89bc8gw1f8tzg6lig0g209m073x6p.gif","hash":"38868ef817598967b551d18d6852e6fa9746bddb","modified":1577674250828},{"_id":"themes/inside/.github/renovate.json","hash":"eace93ac1b147cbdacba7924ff5f31e138626dcd","modified":1584249177000},{"_id":"source/_posts/深入理解volatile和并发编程的三大特性/images.webp","hash":"01e96f10303c49eb64610a9f8e7f76e30ba5dfe0","modified":1585855687563},{"_id":"source/_posts/JVM-内存管理和垃圾回收/w.png","hash":"2cb99c80fde2553359fa8260449cc00394c26cc8","modified":1585848545868},{"_id":"source/_posts/JVM-内存管理和垃圾回收/复杂清除算法.png","hash":"dad3bd76b4ece887ad67cc9307cf37e6e5e263d4","modified":1585860919076},{"_id":"source/_posts/JVM-内存管理和垃圾回收/复杂清除算法-1585860952768.png","hash":"bede6ca2cb016c6609bf640c361f06195eb9c818","modified":1585860952784},{"_id":"source/_posts/JVM-内存管理和垃圾回收/复制-1585862631136.svg","hash":"f396cf4385d483be60ea797037c2d72e0fef6eb9","modified":1585862631151},{"_id":"source/_posts/JVM-内存管理和垃圾回收/复制.svg","hash":"79f485de928f6956d9039a2d2048164963812e57","modified":1585862545471},{"_id":"source/_posts/JVM-内存管理和垃圾回收/复杂清除算法.svg","hash":"3d22e1627fa67fd927d3e98685d72e82f8ac407f","modified":1585861284513},{"_id":"themes/inside/source/avatar.jpg","hash":"134799fe7cfdb7da7ad5160aaa4360d5cc68865a","modified":1585930215670},{"_id":"themes/inside/images/avatar.jpg","hash":"134799fe7cfdb7da7ad5160aaa4360d5cc68865a","modified":1585930215670},{"_id":"themes/inside/avatar.ico","hash":"559cdf9ef05e9b4b56b34d85446e3c432c98b8a1","modified":1585930215670},{"_id":"themes/inside/images/avatar.ico","hash":"559cdf9ef05e9b4b56b34d85446e3c432c98b8a1","modified":1585930215670},{"_id":"source/about/index.md","hash":"5833a8a7733946e56f5fdb5778f099b315e95eb0","modified":1585934395028},{"_id":"public/theme.fd07f88173d488a992d7.css","hash":"201a8be452e7586590a3d233ab185b56d895b118","modified":1585934680699},{"_id":"public/api/MjAyMC8wNC8wMS9KVk0t5YaF5a2Y566h55CG5ZKM5Z6D5Zy+5Zue5pS2.json","hash":"d19cd087d3b83fe0a85e393cd9b3d756cbb60955","modified":1585934680699},{"_id":"public/api/MjAyMC8wNC8wMy9KVk0t5pON5L2c5oyH5Luk6K6w5b2V5LiA6KeI.json","hash":"b1b920f40030b5160f5ea28000f322113f3910b5","modified":1585934680699},{"_id":"public/search.xml","hash":"e6a563d3ac523ae76ec6e223aa7fa1f1c3eb209c","modified":1585935105240},{"_id":"public/api/MjAyMC8wMy8yNy/lvZNBY3Rpdml0eeW8guW4uOmUgOavgUZyYWdtZW50TWFuYWdlcuWBmuS6huS7gOS5iA.json","hash":"2c564796a86cca21560d0da8ea3195dddf36f575","modified":1585934680699},{"_id":"public/api/MjAyMC8wNC8wMS/nsbvliqDovb3lkoznsbvliqDovb3lmag.json","hash":"6a5b445fbe49eb6849e2c25f4c057baea6863147","modified":1585934680699},{"_id":"public/api/MjAyMC8wMy8xMS/mt7HlhaXnkIbop6N2b2xhdGlsZeWSjOW5tuWPkee8lueoi+eahOS4ieWkp+eJueaApw.json","hash":"8e13ed31cdb84956f827cccbbe7c4d88b923a713","modified":1585934680699},{"_id":"public/api/MjAxOS8xMi8zMC9naXTluLjnlKjlkb3ku6Tku6Xlj4rlpoLkvZXlnKhpZGVh5LiK5Y+v6KeG5YyW5pON5L2cZ2l0.json","hash":"baa48b8f4e6ec39dc227aef0d182447f4ecfef94","modified":1585934680699},{"_id":"public/api/MjAyMC8wMy8xOC9maXRzU3lzdGVtV2luZG93c+ebuOWFs+aAu+e7kw.json","hash":"bb8b710198e98b5f51c21ee196c5475603233f69","modified":1585934680699},{"_id":"public/api/MjAyMC8wMy8yNy9rb3RsaW7nmoRsZXTjgIF3aXRo44CBcnVu44CBYXBwbHnjgIFhbHNv57O75YiX5pa55rOV6K6w5b2V.json","hash":"e8730d20288cfa17f2cdc245b0495f6d9a948896","modified":1585934680699},{"_id":"public/api/MjAxOS8xMi8zMC9qYXZh57yW6K+R6L+Q6KGM6L+H56iL6K+m6Kej.json","hash":"d23af59bfd46e941f380b26854895b0c212aeb45","modified":1585934680699},{"_id":"public/api/MjAxOS8xMS8wNy9pZGVh5p2h5Lu25pat54K5.json","hash":"3f6ce1273ddc439e958da8cd75350c4eb11e65d8","modified":1585934680699},{"_id":"public/api/MjAxOS8xMC8xMi9qYXZh6Z2i5ZCR5a+56LGhLeaOpeWPo+WSjOWFtuS7lueahOexuw.json","hash":"68d3d61d63f4d7aa5eadaa4861660e59756d30ab","modified":1585934680699},{"_id":"public/api/MjAxOS8xMC8wNC9naXQtcHVzaC3op6PlhrMt5by55Ye655So5oi35ZCN5ZKM5a+G56CB6L6T5YWl5qGG.json","hash":"fcee7aed849374f1d153388cc60e6d164f215cf8","modified":1585934680699},{"_id":"public/api/MjAyMC8wMy8wOC9BbmRyb2lk5raI5oGv5py65Yi25rex5YWl5LqG6Kej.json","hash":"a0c1c8525d0541769b4ca8b987114187ae71ad51","modified":1585934680699},{"_id":"public/api/MjAxOS8xMC8yOC9lY2xpcHNl55qE5bi455SoMTXkuKrlv6vmjbfplK4.json","hash":"34d341c7c7e5fdf2a4ad54f86c689e0702033ba4","modified":1585934680699},{"_id":"public/api/MjAxOS8xMC8wNy9zc2jnlKjms5Xlj4rlkb3ku6Q.json","hash":"25d9b5a37e56e972307c81d2f7a2176140f6999a","modified":1585934680699},{"_id":"public/api/MjAxOS8xMC8wMy9saW51eOWQjuWPsOi/kOihjOeoi+W6jw.json","hash":"4df5a8bed4090f6c167101c8e773a4476b957131","modified":1585934680699},{"_id":"public/api/MjAxOS8xMC8wMy93aW5kb3dz6ISa5pys6L2s56e7TGludXjkuIpnaXTlkb3ku6Tlh7rnjrDplJnor68.json","hash":"a85780c0373e3839371b69934a08f12162aee960","modified":1585934680699},{"_id":"public/api/MjAxOS8xMC8wMS9oZXhv5LiL5a6M576O5o+S5YWl5Zu+54mH.json","hash":"910cc5515bc47c7441e1c06caa574b8913470747","modified":1585934680699},{"_id":"public/api/MjAxOS8xMC8wMy9oZXhvLWFkbWluLXdpbmRvd3Mt5pyN5Yqh5Zmo55qE57u85ZCI5Y2a5a6i5bmz5Y+w.json","hash":"520e96501ac5614b0420a8ffbaa69581f3b489b1","modified":1585934680699},{"_id":"public/api/cGFnZQ.json","hash":"2d2baac83830f5dd66a64ca40406d05728896720","modified":1585934680699},{"_id":"public/api/cGFnZS8z.json","hash":"256f64637756584a5d5ea6408a40f49da4abe9bb","modified":1585934680699},{"_id":"public/api/MjAxOS8xMC8wMS/ln7rkuo7phbdx5bmz5Y+w55qE566h55CG5py65Zmo5Lq6.json","hash":"c723b5a21952e5c2fe6fea43fcfe556dc1a47e44","modified":1585934680699},{"_id":"public/api/cGFnZS8y.json","hash":"eaeabc5753cecbf98624720b1cbc37ccdea57cc3","modified":1585934680699},{"_id":"public/api/dGFncy9naXTluLjnlKjlkb3ku6TlpIfku70.json","hash":"da0f6e3dd1d9396ca62f04d2721325c1147575c0","modified":1585934680699},{"_id":"public/api/MjAxOS8xMC8wNC9naXRpZ25vcmXlv73nlaXmlofku7bmgLvnu5M.json","hash":"fadd3e541a90f408e10f4d401af33065ceaaae94","modified":1585934680699},{"_id":"public/api/dGFncy9qYXZh.json","hash":"c5d51893d5b8fae58880a8a136b8fec70bf5763a","modified":1585934680699},{"_id":"public/api/dGFncy9oZXhv6YWN572u.json","hash":"5d3d12da2711af1302fcc8531247afc9e0bd01ee","modified":1585934680699},{"_id":"public/api/dGFncw.json","hash":"14ecb3f83601b1a6f4bbcc857dbeb383d8a62208","modified":1585934680699},{"_id":"public/api/dGFncy/lpIfku70.json","hash":"e492d0c46b7f062623764d2b5c1b67f986b760be","modified":1585934680699},{"_id":"public/api/dGFncy/lubLotKc.json","hash":"6faa97acda04e680e805d7ed68aa10afc1e2b493","modified":1585934680699},{"_id":"public/api/dGFncy9qYXZh5bm25Y+R.json","hash":"36f5fd1c35a496132a7418b387ea7eddafa8c670","modified":1585934680699},{"_id":"public/api/dGFncy/kuJbnlYzov5nkuYjlpKfvvIzlvZPnhLbopoHlpJrljrvnnIvnnIs.json","hash":"d6e6fccda61dc93d0651bda8199088fb9a165807","modified":1585934680699},{"_id":"public/api/dGFncy/mn6XmvI/ooaXnvLo.json","hash":"028a5f0a2d02fa331d521e3ecb04b090d29466f5","modified":1585934680699},{"_id":"public/api/dGFncy/lt6jlnZE.json","hash":"d9362b4d1d913b3cf4aeb77b82373d7bdad59f18","modified":1585934680699},{"_id":"public/api/dGFncy/lvIDlj5Hlt6XlhbfmjqLntKI.json","hash":"c24e7653fbe5a5cda885a1cf47022192fa99e39a","modified":1585934680699},{"_id":"public/api/dGFncy/lvZLnurPmgLvnu5M.json","hash":"c06f5e40fec91be5c34023c25eeb213ed9701d43","modified":1585934680699},{"_id":"public/api/dGFncy/nn6Xor4blsLHmmK/lipvph48.json","hash":"ebdd4b892a2f0422b6558600c786b13de0205acc","modified":1585934680699},{"_id":"public/api/dGFncy/or77ku7Y.json","hash":"1b58a31075a3630f67d34ed5b3bdcf606d082fa7","modified":1585934680699},{"_id":"public/api/dGFncy/mtarotLnkuoblpKflpb3pnZLmmKU.json","hash":"5edb15e619d020ebbc2744e3d8a1ea9e0c25362e","modified":1585934680699},{"_id":"public/api/dGFncy/muKnmlYXnn6XmlrA.json","hash":"e814500866249a8eae06c7eaf88448fc7386c43f","modified":1585934680699},{"_id":"public/api/dGFncy/ouKnlnZE.json","hash":"e0a8be39af9dc9c3ce6cfcfcc0ceb9593c08656b","modified":1585934680699},{"_id":"public/api/dGFncy/orrDlvZU.json","hash":"8013eac342e0da82a01aedfb94a3825e6365cd10","modified":1585934680699},{"_id":"public/api/Y2F0ZWdvcmllcy9BbmRyb2lk.json","hash":"f0884254aecab1c115c068fc5328dc14e133b982","modified":1585934680699},{"_id":"public/api/Y2F0ZWdvcmllcy9HaXTlrabkuaDlpIflv5g.json","hash":"46d5a484d20820aa07243f6663925e64e0580f9c","modified":1585934680699},{"_id":"public/api/Y2F0ZWdvcmllcy9KYXZh.json","hash":"d4f887cdcdee8bc6597e0aaf42628c43c658181f","modified":1585934680699},{"_id":"public/api/Y2F0ZWdvcmllcy9MaW51eA.json","hash":"947b77ab1d3959daa563434c2e3a03970f1805b4","modified":1585934680699},{"_id":"public/api/Y2F0ZWdvcmllcy9naXQ.json","hash":"422d2114d39842420a95fd24ee06a14c315962e8","modified":1585934680699},{"_id":"public/api/Y2F0ZWdvcmllcw.json","hash":"1452e1ec35342fc3a8f8ecad373aeb18507b1d27","modified":1585934680699},{"_id":"public/api/Y2F0ZWdvcmllcy9qYXZh.json","hash":"c5d51893d5b8fae58880a8a136b8fec70bf5763a","modified":1585934680699},{"_id":"public/api/Y2F0ZWdvcmllcy/lhbTotqM.json","hash":"08af3b0f00e1e33d3c5e922188e78995ae3698b7","modified":1585934680699},{"_id":"public/api/YXJjaGl2ZXM.json","hash":"5d96a7c6adf86807fa8b8e3417dbc59fd4e58367","modified":1585934680699},{"_id":"public/api/Y2F0ZWdvcmllcy/plJnor6/orrDlvZU.json","hash":"2f9315ec1b8f98e7720d320fdc5e1a3eccf24a4c","modified":1585934680699},{"_id":"public/api/YXJjaGl2ZXMvMg.json","hash":"aa50ebf3cba49ac6f85e25a9820b031f9bab06a0","modified":1585934680699},{"_id":"public/api/Y2F0ZWdvcmllcy/lvIDlj5Hlt6Xlhbc.json","hash":"05102dd4651edc473f78d0d1fcd28adbc2b2a069","modified":1585934680699},{"_id":"public/api/Y2F0ZWdvcmllcy9Lb3RsaW4.json","hash":"94842e1cafb3be764a0301629ad1089739355a5f","modified":1585934680699},{"_id":"public/api/YXJjaGl2ZXMvMw.json","hash":"328711e873e35fdef3adce99d6403209c20179b0","modified":1585934680699},{"_id":"public/api/c2VhcmNo.json","hash":"67af9eb93a60b220d73d3600265a51b240ae1b7f","modified":1585934680699},{"_id":"public/sitemap.xml","hash":"bc0a5d5f44f7019d91385b92e9af86156c566884","modified":1585934680699},{"_id":"public/sw.js","hash":"127fafa7b821e8c73f5a6086c9f9593fec88672a","modified":1585934680699},{"_id":"public/manifest.json","hash":"b7c423598ba01d47a372d4906620cb1a1b3e60e6","modified":1585934680699},{"_id":"public/404/index.html","hash":"08f5dd38f31ce09b7253bd7f3a8f76cba7ec5c34","modified":1585935105240},{"_id":"public/2020/04/03/JVM-操作指令记录一览/index.html","hash":"94f2808bc960822dda9f16124079bba03dfa1919","modified":1585935105240},{"_id":"public/2020/04/01/JVM-内存管理和垃圾回收/index.html","hash":"01e411bb26fde8cad6ab34f8efac3a528fb17ee6","modified":1585935105240},{"_id":"public/2020/04/01/类加载和类加载器/index.html","hash":"8063dd6ff54168c7eeb18fff538b5ea47340c92a","modified":1585935105240},{"_id":"public/2020/03/27/当Activity异常销毁FragmentManager做了什么/index.html","hash":"6a71c15008304ca6d4cd8814964b20adf7d98aa8","modified":1585935105240},{"_id":"public/2020/03/27/kotlin的let、with、run、apply、also系列方法记录/index.html","hash":"f946a3a71d6a7f18e85755790fbf0fb418c05f79","modified":1585935105240},{"_id":"public/2020/03/18/fitsSystemWindows相关总结/index.html","hash":"519f54d809103e1efe96af68a990bf0ff01a8399","modified":1585935105240},{"_id":"public/2020/03/11/深入理解volatile和并发编程的三大特性/index.html","hash":"d802541e4894421534a288e5b5366644ab3bb61b","modified":1585935105240},{"_id":"public/2020/03/08/Android消息机制深入了解/index.html","hash":"ed3cfb5785d26e9cf717f67dbebdb02a4f15b2d9","modified":1585935105240},{"_id":"public/2019/12/30/git常用命令以及如何在idea上可视化操作git/index.html","hash":"172b98f480cae5eae7f26c621ac5b8535eb24f52","modified":1585935105240},{"_id":"public/2019/12/30/java编译运行过程详解/index.html","hash":"439c937195252313a66f89768c2944a6950bbc53","modified":1585935105240},{"_id":"public/2019/11/07/idea条件断点/index.html","hash":"7b189d7b89d5a8545fe51643afdb76533da94a20","modified":1585935105240},{"_id":"public/2019/10/28/eclipse的常用15个快捷键/index.html","hash":"c15d049c194b641182015072370751d1160dbd15","modified":1585935105240},{"_id":"public/2019/10/12/java面向对象-接口和其他的类/index.html","hash":"81a75238f84c7c2914b470ed2bcd9716371cc7ef","modified":1585935105240},{"_id":"public/2019/10/07/ssh用法及命令/index.html","hash":"2de7c6216af925d23011457cf5e090e88eea1e6f","modified":1585935105240},{"_id":"public/2019/10/04/git-push-解决-弹出用户名和密码输入框/index.html","hash":"636325dbc998b970ea64ad0f9b9575ec24ccabb8","modified":1585935105240},{"_id":"public/2019/10/03/linux后台运行程序/index.html","hash":"d8f81a1df843dc8e790aa40f5148025d09c9e2ab","modified":1585935105240},{"_id":"public/2019/10/03/windows脚本转移Linux上git命令出现错误/index.html","hash":"efc68770b8c2e691454ee8c9faf3d76bcd666a24","modified":1585935105240},{"_id":"public/2019/10/04/gitignore忽略文件总结/index.html","hash":"04682d62b0db130a48c4bc377b691b49f6bb7086","modified":1585935105240},{"_id":"public/2019/10/03/hexo-admin-windows-服务器的综合博客平台/index.html","hash":"4194a3a4eb6a4facf7f0a2628058a366e3650f89","modified":1585935105240},{"_id":"public/2019/10/01/hexo下完美插入图片/index.html","hash":"e8134b23213047abef683eb3ba607262b958a2d7","modified":1585935105240},{"_id":"public/2019/10/01/基于酷q平台的管理机器人/index.html","hash":"39ff37a6382efc02b069e60a62ad683324d74226","modified":1585935105240},{"_id":"public/index.html","hash":"acec70539b76f1d3459dae11802e66e394f18ed3","modified":1585935105240},{"_id":"public/page/2/index.html","hash":"6ad224762fc9cc7b1c45dab0b114f4956cd1ac51","modified":1585935105240},{"_id":"public/page/3/index.html","hash":"a7d1c17ee7009a4605643abd839a98114b31571c","modified":1585935105240},{"_id":"public/tags/index.html","hash":"05554fa0e4476ef50d05f22bc0f0b117eb0c2a53","modified":1585935105240},{"_id":"public/tags/git常用命令备份/index.html","hash":"663be9e43ae287461c21c2361b5094018bce9a8e","modified":1585935105240},{"_id":"public/tags/hexo配置/index.html","hash":"30524384935589a5aaebe76a7a9248af5c4f2820","modified":1585935105240},{"_id":"public/tags/java/index.html","hash":"773f9692b064c2cbf56d651497c9f369d94cb273","modified":1585935105240},{"_id":"public/tags/世界这么大，当然要多去看看/index.html","hash":"1062782ad33f78bc12808f6de1aea197d95889ac","modified":1585935105240},{"_id":"public/tags/备份/index.html","hash":"914a3d65209696afebe35b50d1392b02643e88a4","modified":1585935105240},{"_id":"public/tags/巨坑/index.html","hash":"009f9f9c685abcf897c8af7b185412215261fb09","modified":1585935105240},{"_id":"public/tags/java并发/index.html","hash":"0905ea80ad9711cd4610cac1dd7c67abcb2b8202","modified":1585935105240},{"_id":"public/tags/干货/index.html","hash":"a28cdf6a188cd439de30b44c6cb2ff658d571f6c","modified":1585935105240},{"_id":"public/tags/开发工具探索/index.html","hash":"d4203680ca159508e46eccb5ecf5ee88bff47bb3","modified":1585935105240},{"_id":"public/tags/归纳总结/index.html","hash":"d03605cf2729fc3631d00eea7ae6ae295334db65","modified":1585935105240},{"_id":"public/config.d39c4df96a63c83e1164.js","hash":"3990a235f1ee8a1850c173104fe4c65e1ebd73b1","modified":1585934680699},{"_id":"public/api/YWJvdXQ.json","hash":"e4acd86b193a84d71704411945097c36279c0ee8","modified":1585934680699},{"_id":"public/about/index.html","hash":"c7fd09d8c8a9a81888b59fe580958d7dfcf92d42","modified":1585935105240},{"_id":"public/tags/查漏补缺/index.html","hash":"6fbb1130aa910f35491ef018c5336ca5f951080f","modified":1585935105240},{"_id":"public/tags/浪费了大好青春/index.html","hash":"9d524ffbdf79dd562b2a08c51dc06e339b093418","modified":1585935105240},{"_id":"public/tags/温故知新/index.html","hash":"9edcbd65065dc68efe6f88b734a52e4f01c7dbb7","modified":1585935105240},{"_id":"public/tags/知识就是力量/index.html","hash":"55aa698dcd7fd19f2bb0189d30ae704a5c6d0ece","modified":1585935105240},{"_id":"public/tags/记录/index.html","hash":"c898b76d7f16ec879d1fbc40f7c6e35fbc08e25f","modified":1585935105240},{"_id":"public/tags/课件/index.html","hash":"036ed401b801855a7dd2bfc015aaf1d6dac55f97","modified":1585935105240},{"_id":"public/tags/踩坑/index.html","hash":"b666f70b078d0acc5b4e9f566d16d25816445145","modified":1585935105240},{"_id":"public/categories/index.html","hash":"d41eb764059a1d9de5ce6db2bee2d91eefc27ebb","modified":1585935105240},{"_id":"public/categories/Android/index.html","hash":"e6c296a71fe76f365895f8b930d8cc82b00b1798","modified":1585935105240},{"_id":"public/categories/Git学习备忘/index.html","hash":"1c98b1f43a3e00a77fea782ae6a869a0efc05989","modified":1585935105240},{"_id":"public/categories/Java/index.html","hash":"68177af92fe76f923afd8f901b96536ff2a063e0","modified":1585935105240},{"_id":"public/categories/Kotlin/index.html","hash":"c9c0c09e727daa59e30013ab951e9a36c3d47890","modified":1585935105240},{"_id":"public/categories/Linux/index.html","hash":"12fd763da16cd4383e6ebcafd78bc309f597cee3","modified":1585935105240},{"_id":"public/categories/git/index.html","hash":"e18c9db7a0110dc9e0274954030a5904d2d969ce","modified":1585935105240},{"_id":"public/categories/兴趣/index.html","hash":"eb9d109f5fe5c537cbfc552fe2acf37ac8b48fba","modified":1585935105240},{"_id":"public/categories/开发工具/index.html","hash":"93c944a04c7322960cbacaae2dc9fee6b44da3ee","modified":1585935105240},{"_id":"public/categories/java/index.html","hash":"a79cbdd5b1909c4095d4467674ce27df0f170b89","modified":1585935105240},{"_id":"public/categories/错误记录/index.html","hash":"4b1fb75737203a75fe698d6f1959263d90426d6a","modified":1585935105240},{"_id":"public/archives/index.html","hash":"d655907e8301c2df8b08b3319aabe0afb2c98220","modified":1585935105240},{"_id":"public/archives/2/index.html","hash":"5cf0239c653ef36781aa33058cae675dd470d1d5","modified":1585935105240},{"_id":"public/archives/3/index.html","hash":"622abfca54e50d7f907b4140d4279e437e179077","modified":1585935105240},{"_id":"public/search/index.html","hash":"f22079ad767a42a8eb4a8e4a3ebcf414e7f2de80","modified":1585935105240},{"_id":"public/config.b46a375cd280b311dd79.js","hash":"51b25a01031803f78d3857cbc5810f05cd94e135","modified":1585935105240}],"Category":[{"name":"Android","_id":"ck8jl8qhp0002w0w08vlfh6d3"},{"name":"Java","_id":"ck8jl8qhz0007w0w02nn3fdv1"},{"name":"开发工具","_id":"ck8jl8qih000jw0w00ut7a7j6"},{"name":"Git学习备忘","_id":"ck8jl8qim000qw0w0bw6791cx"},{"name":"git","_id":"ck8jl8qir000xw0w060003s0c"},{"name":"兴趣","_id":"ck8jl8qiz001bw0w067n5093k"},{"name":"java","_id":"ck8jl8qje001nw0w0f6enf28i"},{"name":"Linux","_id":"ck8jl8qjo001xw0w0bujyclbx"},{"name":"错误记录","_id":"ck8jl8qjq0022w0w0e5qx2pac"},{"name":"Kotlin","_id":"ck8jl8qju0028w0w0fu61cddy"},{"name":"课件附页","parent":"ck8jl8qje001nw0w0f6enf28i","_id":"ck8jl8qjw002dw0w046mra1gw"}],"Data":[],"Page":[{"title":"about","date":"2020-04-03T17:19:55.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-04-04 01:19:55\n---\n","updated":"2020-04-03T17:19:55.028Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck8kgk8rb00003sw0h4ka1g1z","content":"","site":{"data":{}},"excerpt":"","more":"","date_formatted":{"ll":"2020年4月4日","L":"2020/04/04","MM-DD":"04-04"},"link":"about","plink":"https://jonvines.github.io/about/","type":"page"}],"Post":[{"title":"Android消息机制深入了解","date":"2020-03-08T11:53:47.000Z","_content":"\n# 为什么消息机制这么重要呢\n\n其实一个安卓的app也是有自己的**main**方法的<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg\" alt=\"img\" style=\"zoom:50%;\" />，跟一个普通的java程序并没有太大的区别，只不过用户接触不到这个方法，这个方法在**ActivityThread**这个类里面，这个也就是android中所说的**UI线程**。你可能在想一个问题，那么既然是一个有main方法的java程序，那么一整个安卓的app究竟是怎么来运行的呢，如何做到和用户交互并执行这些代码的呢？？（这里涉及到很多东西，本文只讲与**消息机制相关**的，文章**末尾**我会一一解释）<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n# 消息机制重要的三大成员\n\n* **MessageQueue**\n\n* **Looper**\n\n* **Handler**\n\n  > 一个线程只能有一个Looper和MessageQueue，但是可以有多个handler，为什么呢？后面我们慢慢会讲到。\n\n\n\n那么这三者是如何配合的呢，简单来说，**MessageQueue**就是一根**运输消息管道**，handler负责不断往里面**放**，**Looper**负责不断从里面**取**出来，又交给发送的这个handler去处理，那么就出现两个问题？\n\n* 那么为什么要这样子设计？这样子设计怎么实现的**跨线程通信**\n* 为什么handler放进去最后looper又要交还给发送消息的这个handler去处理\n\n通过后面的源码解析，就能自己领会这两个问题\n\n# 消息机制主要流程详解\n\n如果你要在一个线程中使用消息机制\n\n首先需要`Looper.prepare();`和`Looper.loop();`，然后你就可以使用你的**handler发送消息**了。\n\n> 主线程是不需要自己`Looper.prepare();`和`Looper.loop();`在ActivityThread的main方法里面就已经执行了类似代码`Looper.prepareMainLooper();`和`Looper.loop();`\n\n下面我会逐一从**源码层面**来分析整个消息机制的主要流程<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />，会不会很难呢，要不要继续学下去，头发 - -。\n\n## Looper.prepare()；\n\n首先我们点进去看看代码是如何实现的\n\n```java\n//这个函数在ActivityThread的main方法里面执行,用户创建主线程的Looper对象\npublic static void prepareMainLooper() {\n        prepare(false);\n        synchronized (Looper.class) {\n            if (sMainLooper != null) {\n                throw new IllegalStateException(\"The main Looper has already been prepared.\");\n            }\n            sMainLooper = myLooper();\n        }\n}\n\n//通常我们在其他线程如果需要用到消息机制，会执行这个方法\npublic static void prepare() {\n    prepare(true);\n}\n\n//函数重载，这个参数用于构造一个可以关闭或者无法关闭的Looper\nprivate static void prepare(boolean quitAllowed) {\n    if (sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n\n最重要的方法就是第三个`prepare(boolean quitAllowed)`，我们可以看到代码很短，也很好理解。\n\n首先调用这个这个**Looper类**里面一个**静态变量`sThreadLocal`**\n\n```java\nstatic final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\n```\n\n这是一个**`ThreadLocal<Looper>`类型**的一个变量，而且是直接**`new`出来的**,点击进去看\n\n```java\npublic ThreadLocal() {\n}\n```\n\n查看**ThreadLocal源代码里面的构造方法**也没有做任何操作，说明本身这个变量是里是没有我们想要的东西的\n\n那么**关键肯定是在`sThreadLocal.get()`里面**，通过后面的抛出异常\n\n`throw new RuntimeException(\"Only one Looper may be created per thread\");`\n\n我们可以断定这个**判断**肯定**是**用来**判断当前线程是否已经存在了一个Lopper对象**\n\n接下来我们来看`get()`方法内部\n\n```java\n//代码不是很多，我们一步步分析\npublic T get() {\n    Thread t = Thread.currentThread();//获得当前的线程对象\n    ThreadLocalMap map = getMap(t);//从当前线程拿到一个ThreadLocalMap\n    if (map != null) {//如果这个ThreadLocalMap不为空\n      \t//从里面取得Looper（这里做了一个包装，稍后会讲到）\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {//如果Lopper不为空\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;//直接返回Looper\n        }\n    }\n    return setInitialValue();//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作\n}\n```\n\n可能虽然有注释还是有些疑惑，下面我们一一来讲解一下 Why<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-639605533bdb1ecf1c6562677a430554_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n首先我们来看看**`ThreadLocalMap map = getMap(t);`中`get(t)`的代码**\n\n```java\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n```\n\n可以看到，是直接返回了**当前线程对象**的一个**成员变量`threadLocals`**，那么这个`threadLocals`究竟是个什么东西呢？\n\n### ThreadLocal和ThreadLocalMap\n\nEntry是ThreadLocalMap的静态内部类，ThreadLocalMap是ThreadLocal的静态内部类\n\n首先我们来看`ThreadLocal`，顾名思义，直接翻译过来就是 “线程本地” ？？<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n我们来看看这个类的介绍注释\n\n```java\n/**\n * This class provides thread-local variables.  These variables differ from\n * their normal counterparts in that each thread that accesses one (via its\n * {@code get} or {@code set} method) has its own, independently initialized\n * copy of the variable.  {@code ThreadLocal} instances are typically private\n * static fields in classes that wish to associate state with a thread (e.g.,\n * a user ID or Transaction ID).\n */\n\n/**\n* 谷歌翻译版本:\n* 此类提供线程局部变量\n* 这些变量不同于它们的普通副本，\n* 因为每个访问一个变量的线程（通过其{@code get}或{@code set}方法）\n* 都有自己的、独立的变量副本。\n* {@code ThreadLocal}实例通常是类中的私有静态字段，希望将状态与线程关联（例如，*用户ID或事务ID）。\n*/\n  \n```\n\n通过注释我们可以很轻松的理解到，原来这个东西就是为每一个线程创建一个单独的变量副本的呀<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />。\n\n我们来看看到底怎么使用\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        ThreadLocal<Integer> integerThreadLocal = new ThreadLocal<>(){\n            //这个方法专门用来提供开发者复写，提供副本默认值\n            @Override\n            protected Integer initialValue() {\n                return 2333;//默认值我们这设置为\n            }\n        };\n        \n        for (int i = 0; i < 5; i++) {\n            new Thread(){\n                @Override\n                public void run() {\n                    //为这个ThreadLocal<Integer>在当前线程存一个副本，值为3222\n                    //如果不是基本数据类型，注意值传递和引用传递的区别，这里需要new一个新的放进去\n                    //例如：ThreadLocal的泛型是Runnable,\n                    //那么就需要新建一个独立的Runnable实现类的对象\n                    //runnableThreadLocal.set(new Runnable() {\n                    //            @Override\n                    //            public void run() {\n                    //\n                    //            }\n                    //        };)\n                    integerThreadLocal.set(3222);\n                    //获取当前线程的副本，如果之前没有set()，那么默认值为2333\n                  \t//如果之前set()了，就会取得set()的那个对象\n                    integerThreadLocal.get();\n\n                    /**\n                     * 通过以上代码，在这5个线程里都有了一个与integerThreadLocal对应\n                     * 变量副本，这个副本是Integer类型的，每个线程通过integerThreadLocal.get()\n                     * 取到的都是线程独有的，与其他线程完全隔离的一个副本\n                     */\n                }\n            }.start();\n        }\n\n    }\n}\n```\n\n通过上面的注释就足以理解这个东西的用法，这时候我们回到安卓来看看消息机制这里的设计，是不是就一下子恍然大悟了<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />，我这再梳理一下\n\n* 首先Lopper中是有一个`sThreadLocal`\n\n  ```java\n  static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\n  ```\n\n  理解了上面小Demo,就能知道因为这个`sThreadLocal`的存在，我们就可以在每一个线程存一个Looper副本\n\n  ```java\n  private static void prepare(boolean quitAllowed) {\n      if (sThreadLocal.get() != null) {\n          throw new RuntimeException(\"Only one Looper may be created per thread\");\n      }\n      sThreadLocal.set(new Looper(quitAllowed));\n  }\n  ```\n\n  看，这是不是就很清晰了<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-8312b637ba6407992515ffa42b56391d_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n然后我们来看看`ThreadLocalMap`，前面我们看到`ThreadLocal.get()`的`get()`方法,这里再把代码贴一下\n\n```java\npublic T get() {\n    Thread t = Thread.currentThread();//获得当前的线程对象\n    ThreadLocalMap map = getMap(t);//从当前线程拿到一个ThreadLocalMap\n    if (map != null) {//如果这个ThreadLocalMap不为空\n      \t//从里面取得Looper（这里做了一个包装，稍后会讲到）\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {//如果Lopper不为空\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;//直接返回Looper\n        }\n    }\n    return setInitialValue();//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作\n}\n\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n```\n\n从上面的代码可以知道，一个线程对象里面是有一个`threadLocals`属性的，它是一个`ThreadLocalMap`类型的变量。就是它用来储存各种存在当前线程的副本。他是一个键值对存储的形式,下面是`ThreadLocalMap`的set（）方法的声明\n\n```java\nset(ThreadLocal<?> key, Object value)\n```\n\n具体实现是比较复杂的，用到哈希表来储存，这里不展开讲了，有兴趣可以去了解一下，文章后面会有超链接。\n\n然后我们来看看`ThreadLocalMap.Entry e = map.getEntry(this);`这个行代码，肯定很多人都会有疑惑，首先我们需要看一下ThreadLocalMap.Entry这个静态内部类\n\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n```\n\n这里你可以看到这里是直接继承WeakReference弱引用这个类的，那为什么要这么设计呢？<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n这里我大致的说一下，ThreadLocal是为了每个线程中的对象副本服务的，一旦我不需要使用ThreadLocal这个对象了，那么我肯定会将ThreadLocal对象的强引用去掉，以防止内存泄漏，但是这个如果不这么设计，如果有一个线程的生命周期比ThreadLocal长，那么必定会持有ThreadLocal的引用，这样就会导致内存泄漏，ThreadLocal没有被使用但是却无法被GC回收。相比之下，这样设计就不会出现这个问题。\n\n### Looper的构造方法\n\n```java\nprivate Looper(boolean quitAllowed) {\n    mQueue = new MessageQueue(quitAllowed);//生成一个MessageQueue，并作为成员保存在Looper中\n    mThread = Thread.currentThread();//绑定当前线程\n}\n```\n\n从上面的代码也印证了Looper和MessageQueue一般都是同时出现的，而且都只能有一个的言论（因为prepare方法在一个线程调用一次，前面代码提到过）。\n\n## Looper.loop\n\n```java\n//因为方便，我只选择了关键代码\npublic static void loop() {\n        final Looper me = myLooper();//取得当前线程的Looper，当然实际上也是通过sThreadLocal.get()\n        if (me == null) {//如果没有说明没有调用prepare(),抛出异常\n            throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n        }\n        final MessageQueue queue = me.mQueue;//从当前的Looper对象里取得对应的MessageQueue\n\n        //do something............\n\n        for (; ; ) {\n            Message msg = queue.next(); // 取出消息，这里可能会堵塞，直到重新取到消息\n            if (msg == null) {\n              \t//如果返回为空，则表示MessageQueue正在退出，所以这里也直接退出无限循环\n              \t//这里是只有MessageQueue调用quit(boolean safe)方法才会退出\n              \t//下面会有详细解释\n                return;\n            }\n\n            //do something.............\n\n          \t//这个target是发送这个消息的handler，取得消息之后让发送的这个handler去处理\n          \t//后面我们会讲到，handler是如何把这个消息发送到当前这个MessageQueue中，并且target的赋值\n            msg.target.dispatchMessage(msg);\n\n            //do something.............\n            msg.recycleUnchecked();//回收这个消息\n        }\n}\n```\n\n通过代码应该很清晰就能展现出关键点，这里就不再赘述\n\n因为这里涉及到Looper.loop退出的情况，下面我们用代码类分析一下，关键就在`queue.next()`，为了便于理解还是只凸显出主要代码，还有很多MessageQueue的消息处理的一些代码就不赘述了，下面代码重点看那个返回值为空的判断语句\n\n```java\n    Message next() {\n\n        //do something..........\n\n        for (; ; ) {//next中也是一个无限循环着也就很好的说明为什么next()是一个可堵塞的方法啦\n\n            //do something..........\n\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n          \n            if (msg != null) {\n              \t//这里是后面handler的sendMessage方法会给message添加一个时间的处理\n                if (now < msg.when) {\n                    //do something..........\n                } else {\n                    //do something..........\n                    return msg;//如果所有条件都满足，就可以直接返回这个message了\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n\n            // Process the quit message now that all pending messages have been handled.\n          \t// 前面没有返回，这里如果为true只就直接返回null，前面Looper.loop就退出了\n            if (mQuitting) {\n                dispose();\n                return null;\n            }\n\n            //do something..........\n\n            if (pendingIdleHandlerCount <= 0) {\n                // No idle handlers to run.  Loop and wait some more.\n                mBlocked = true;\n                continue;\n            }\n\n            //do something..........\n\n        }\n    }\n\n```\n\n我们来看看`mQuitting`这个变量是在哪被赋值为true的\n\n```java\nvoid quit(boolean safe) {\n  \t//mQuitAllowed这个其实在前文多次提到了，Looper和MessageQueue的构造方法都需要\n  \t//用来设定是否可以被退出\n    if (!mQuitAllowed) {\n        throw new IllegalStateException(\"Main thread not allowed to quit.\");\n    }\n\n    synchronized (this) {\n        if (mQuitting) {\n            return;\n        }\n        mQuitting = true;//关键代码，这里赋值为true\n\n        if (safe) {\n            removeAllFutureMessagesLocked();\n        } else {\n            removeAllMessagesLocked();\n        }\n\n        // We can assume mPtr != 0 because mQuitting was previously false.\n        nativeWake(mPtr);\n    }\n}\n```\n\n从上面分析我们可以知道一旦调用了MessageQueue的quit的方法那么MessageQueue下一个利用next方法去取消息就会返回null，返回null就导致Looper的loop(也就是无限取消息的循环退出了),那么就有一个问题了，Looper也有一个quit方法，怎么实现的呢？\n\n```java\npublic void quit() {\n    mQueue.quit(false);\n}\n```\n\n恍然大悟！！！！！！！<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n## handler.sendMessage()\n\n看发送消息之前我们需要先看看**Handler的构造方法**\n\n```java\n//无参构造函数\npublic Handler() {\n    this(null, false);\n}\n\n//有参构造函数\npublic Handler(@Nullable Callback callback, boolean async) {\n  \n    //do something............\n  \n  \t//获取当前线程的Looper\n    mLooper = Looper.myLooper();\n    if (mLooper == null) {//同样如果没有Looper会报错（没有Looper.prepare()）\n        throw new RuntimeException(\n            \"Can't create handler inside thread \" + Thread.currentThread()\n                    + \" that has not called Looper.prepare()\");\n    }\n  \n    mQueue = mLooper.mQueue;//绑定当前线程的MessageQueue\n  \n    //do something............\n}\n```\n\n可以看出**Handler在那个线程创建**，它就会**直接绑定哪个线程的MessageQueue**，之后它`sendMessage()`就可以**直接放到这个MessageQueue里面**\n\n还是直接来看`sendMessage()`的代码\n\n```java\n//点进来第一个方法是这个\npublic final boolean sendMessage(@NonNull Message msg) {\n    return sendMessageDelayed(msg, 0);\n}\n\n//发送延迟处理的消息\npublic final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {\n   if (delayMillis < 0) {\n        delayMillis = 0;\n    }\n    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n}\n\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;//拿到创建Handler时绑定的那个MessageQueue\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n   \t}\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n\nprivate boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,\n        long uptimeMillis) {\n    msg.target = this;//【发送的消息】绑定【发送消息的这个handler】\n    msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n    if (mAsynchronous) {\n        msg.setAsynchronous(true);\n    }\n  \t//把消息交给MessageQueue去排序消息，这里是根据uptimeMillis转成具体时刻来排序的\n  \t//这里要注意，发送的延迟消息，只能保持设置的时间前这个消息不被处理\n  \t//但是无法保证这个消息具体在设置的时间之后的那个时候被处理\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n\n### handler.post()\n\n还是直接看代码，如果上面的理解了这个就非常简单了<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-8312b637ba6407992515ffa42b56391d_hd-3736965.jpg\" alt=\"img\" style=\"zoom:50%;\" />，只有一些区别\n\n```java\npublic final boolean post(@NonNull Runnable r) {\n   //这里仍然还是调用的发送延时消息的方法，区别是下面那个方法\n   return  sendMessageDelayed(getPostMessage(r), 0);\n}\n\n//将Runnable包装成Message，那么这个Runnable在哪会被调用呢\nprivate static Message getPostMessage(Runnable r) {\n    Message m = Message.obtain();\n    m.callback = r;\n    return m;\n}\n```\n\n还记得前面讲到的Looper.loop吗，它会把消息交给与他绑定的Handler去处理来看看这个方法\n\n```java\npublic void dispatchMessage(@NonNull Message msg) {\n    if (msg.callback != null) {//优先优先判断callback是不是空\n        handleCallback(msg);//不为空直接调用方法处理callback\n    } else {\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }\n}\n\nprivate static void handleCallback(Message message) {\n    message.callback.run();//这里直接执行了runnable的run方法\n}\n```\n\n\n\n# 结尾\n\n文章开头留下的悬念我想这下已经很清晰了，主线程中的main方法调用了Looper.loop,正是有这个无限循环的存在才会不会想一个简单的java程序一样，执行完了main里面的代码程序就结束了，而`prepareMainLooper\t`,正是为主线程（UI线程）准备了一个不可以退出的Looper。而这就可以说明Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞它。**也就说我们的代码其实就是在这个循环里面去执行的**，所以你在你的子线程要使用消息机制接受消息的话，最好将Looper.loop()放到你要直接执行的所有代码后面，不然没有执行qiut方法，后面的代码就不会执行。<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg\" alt=\"img\" style=\"zoom: 67%;\" />真逊，原来这么简单，是吧，看来还是要好好学习下去，知识++。","source":"_posts/Android消息机制深入了解.md","raw":"---\ntitle: Android消息机制深入了解\ndate: 2020-03-08 19:53:47\ntags:\n- 温故知新\ncategories:\n- Android\n---\n\n# 为什么消息机制这么重要呢\n\n其实一个安卓的app也是有自己的**main**方法的<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg\" alt=\"img\" style=\"zoom:50%;\" />，跟一个普通的java程序并没有太大的区别，只不过用户接触不到这个方法，这个方法在**ActivityThread**这个类里面，这个也就是android中所说的**UI线程**。你可能在想一个问题，那么既然是一个有main方法的java程序，那么一整个安卓的app究竟是怎么来运行的呢，如何做到和用户交互并执行这些代码的呢？？（这里涉及到很多东西，本文只讲与**消息机制相关**的，文章**末尾**我会一一解释）<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n# 消息机制重要的三大成员\n\n* **MessageQueue**\n\n* **Looper**\n\n* **Handler**\n\n  > 一个线程只能有一个Looper和MessageQueue，但是可以有多个handler，为什么呢？后面我们慢慢会讲到。\n\n\n\n那么这三者是如何配合的呢，简单来说，**MessageQueue**就是一根**运输消息管道**，handler负责不断往里面**放**，**Looper**负责不断从里面**取**出来，又交给发送的这个handler去处理，那么就出现两个问题？\n\n* 那么为什么要这样子设计？这样子设计怎么实现的**跨线程通信**\n* 为什么handler放进去最后looper又要交还给发送消息的这个handler去处理\n\n通过后面的源码解析，就能自己领会这两个问题\n\n# 消息机制主要流程详解\n\n如果你要在一个线程中使用消息机制\n\n首先需要`Looper.prepare();`和`Looper.loop();`，然后你就可以使用你的**handler发送消息**了。\n\n> 主线程是不需要自己`Looper.prepare();`和`Looper.loop();`在ActivityThread的main方法里面就已经执行了类似代码`Looper.prepareMainLooper();`和`Looper.loop();`\n\n下面我会逐一从**源码层面**来分析整个消息机制的主要流程<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />，会不会很难呢，要不要继续学下去，头发 - -。\n\n## Looper.prepare()；\n\n首先我们点进去看看代码是如何实现的\n\n```java\n//这个函数在ActivityThread的main方法里面执行,用户创建主线程的Looper对象\npublic static void prepareMainLooper() {\n        prepare(false);\n        synchronized (Looper.class) {\n            if (sMainLooper != null) {\n                throw new IllegalStateException(\"The main Looper has already been prepared.\");\n            }\n            sMainLooper = myLooper();\n        }\n}\n\n//通常我们在其他线程如果需要用到消息机制，会执行这个方法\npublic static void prepare() {\n    prepare(true);\n}\n\n//函数重载，这个参数用于构造一个可以关闭或者无法关闭的Looper\nprivate static void prepare(boolean quitAllowed) {\n    if (sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n\n最重要的方法就是第三个`prepare(boolean quitAllowed)`，我们可以看到代码很短，也很好理解。\n\n首先调用这个这个**Looper类**里面一个**静态变量`sThreadLocal`**\n\n```java\nstatic final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\n```\n\n这是一个**`ThreadLocal<Looper>`类型**的一个变量，而且是直接**`new`出来的**,点击进去看\n\n```java\npublic ThreadLocal() {\n}\n```\n\n查看**ThreadLocal源代码里面的构造方法**也没有做任何操作，说明本身这个变量是里是没有我们想要的东西的\n\n那么**关键肯定是在`sThreadLocal.get()`里面**，通过后面的抛出异常\n\n`throw new RuntimeException(\"Only one Looper may be created per thread\");`\n\n我们可以断定这个**判断**肯定**是**用来**判断当前线程是否已经存在了一个Lopper对象**\n\n接下来我们来看`get()`方法内部\n\n```java\n//代码不是很多，我们一步步分析\npublic T get() {\n    Thread t = Thread.currentThread();//获得当前的线程对象\n    ThreadLocalMap map = getMap(t);//从当前线程拿到一个ThreadLocalMap\n    if (map != null) {//如果这个ThreadLocalMap不为空\n      \t//从里面取得Looper（这里做了一个包装，稍后会讲到）\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {//如果Lopper不为空\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;//直接返回Looper\n        }\n    }\n    return setInitialValue();//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作\n}\n```\n\n可能虽然有注释还是有些疑惑，下面我们一一来讲解一下 Why<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-639605533bdb1ecf1c6562677a430554_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n首先我们来看看**`ThreadLocalMap map = getMap(t);`中`get(t)`的代码**\n\n```java\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n```\n\n可以看到，是直接返回了**当前线程对象**的一个**成员变量`threadLocals`**，那么这个`threadLocals`究竟是个什么东西呢？\n\n### ThreadLocal和ThreadLocalMap\n\nEntry是ThreadLocalMap的静态内部类，ThreadLocalMap是ThreadLocal的静态内部类\n\n首先我们来看`ThreadLocal`，顾名思义，直接翻译过来就是 “线程本地” ？？<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n我们来看看这个类的介绍注释\n\n```java\n/**\n * This class provides thread-local variables.  These variables differ from\n * their normal counterparts in that each thread that accesses one (via its\n * {@code get} or {@code set} method) has its own, independently initialized\n * copy of the variable.  {@code ThreadLocal} instances are typically private\n * static fields in classes that wish to associate state with a thread (e.g.,\n * a user ID or Transaction ID).\n */\n\n/**\n* 谷歌翻译版本:\n* 此类提供线程局部变量\n* 这些变量不同于它们的普通副本，\n* 因为每个访问一个变量的线程（通过其{@code get}或{@code set}方法）\n* 都有自己的、独立的变量副本。\n* {@code ThreadLocal}实例通常是类中的私有静态字段，希望将状态与线程关联（例如，*用户ID或事务ID）。\n*/\n  \n```\n\n通过注释我们可以很轻松的理解到，原来这个东西就是为每一个线程创建一个单独的变量副本的呀<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />。\n\n我们来看看到底怎么使用\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        ThreadLocal<Integer> integerThreadLocal = new ThreadLocal<>(){\n            //这个方法专门用来提供开发者复写，提供副本默认值\n            @Override\n            protected Integer initialValue() {\n                return 2333;//默认值我们这设置为\n            }\n        };\n        \n        for (int i = 0; i < 5; i++) {\n            new Thread(){\n                @Override\n                public void run() {\n                    //为这个ThreadLocal<Integer>在当前线程存一个副本，值为3222\n                    //如果不是基本数据类型，注意值传递和引用传递的区别，这里需要new一个新的放进去\n                    //例如：ThreadLocal的泛型是Runnable,\n                    //那么就需要新建一个独立的Runnable实现类的对象\n                    //runnableThreadLocal.set(new Runnable() {\n                    //            @Override\n                    //            public void run() {\n                    //\n                    //            }\n                    //        };)\n                    integerThreadLocal.set(3222);\n                    //获取当前线程的副本，如果之前没有set()，那么默认值为2333\n                  \t//如果之前set()了，就会取得set()的那个对象\n                    integerThreadLocal.get();\n\n                    /**\n                     * 通过以上代码，在这5个线程里都有了一个与integerThreadLocal对应\n                     * 变量副本，这个副本是Integer类型的，每个线程通过integerThreadLocal.get()\n                     * 取到的都是线程独有的，与其他线程完全隔离的一个副本\n                     */\n                }\n            }.start();\n        }\n\n    }\n}\n```\n\n通过上面的注释就足以理解这个东西的用法，这时候我们回到安卓来看看消息机制这里的设计，是不是就一下子恍然大悟了<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />，我这再梳理一下\n\n* 首先Lopper中是有一个`sThreadLocal`\n\n  ```java\n  static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\n  ```\n\n  理解了上面小Demo,就能知道因为这个`sThreadLocal`的存在，我们就可以在每一个线程存一个Looper副本\n\n  ```java\n  private static void prepare(boolean quitAllowed) {\n      if (sThreadLocal.get() != null) {\n          throw new RuntimeException(\"Only one Looper may be created per thread\");\n      }\n      sThreadLocal.set(new Looper(quitAllowed));\n  }\n  ```\n\n  看，这是不是就很清晰了<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-8312b637ba6407992515ffa42b56391d_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n然后我们来看看`ThreadLocalMap`，前面我们看到`ThreadLocal.get()`的`get()`方法,这里再把代码贴一下\n\n```java\npublic T get() {\n    Thread t = Thread.currentThread();//获得当前的线程对象\n    ThreadLocalMap map = getMap(t);//从当前线程拿到一个ThreadLocalMap\n    if (map != null) {//如果这个ThreadLocalMap不为空\n      \t//从里面取得Looper（这里做了一个包装，稍后会讲到）\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {//如果Lopper不为空\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;//直接返回Looper\n        }\n    }\n    return setInitialValue();//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作\n}\n\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n```\n\n从上面的代码可以知道，一个线程对象里面是有一个`threadLocals`属性的，它是一个`ThreadLocalMap`类型的变量。就是它用来储存各种存在当前线程的副本。他是一个键值对存储的形式,下面是`ThreadLocalMap`的set（）方法的声明\n\n```java\nset(ThreadLocal<?> key, Object value)\n```\n\n具体实现是比较复杂的，用到哈希表来储存，这里不展开讲了，有兴趣可以去了解一下，文章后面会有超链接。\n\n然后我们来看看`ThreadLocalMap.Entry e = map.getEntry(this);`这个行代码，肯定很多人都会有疑惑，首先我们需要看一下ThreadLocalMap.Entry这个静态内部类\n\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n```\n\n这里你可以看到这里是直接继承WeakReference弱引用这个类的，那为什么要这么设计呢？<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n这里我大致的说一下，ThreadLocal是为了每个线程中的对象副本服务的，一旦我不需要使用ThreadLocal这个对象了，那么我肯定会将ThreadLocal对象的强引用去掉，以防止内存泄漏，但是这个如果不这么设计，如果有一个线程的生命周期比ThreadLocal长，那么必定会持有ThreadLocal的引用，这样就会导致内存泄漏，ThreadLocal没有被使用但是却无法被GC回收。相比之下，这样设计就不会出现这个问题。\n\n### Looper的构造方法\n\n```java\nprivate Looper(boolean quitAllowed) {\n    mQueue = new MessageQueue(quitAllowed);//生成一个MessageQueue，并作为成员保存在Looper中\n    mThread = Thread.currentThread();//绑定当前线程\n}\n```\n\n从上面的代码也印证了Looper和MessageQueue一般都是同时出现的，而且都只能有一个的言论（因为prepare方法在一个线程调用一次，前面代码提到过）。\n\n## Looper.loop\n\n```java\n//因为方便，我只选择了关键代码\npublic static void loop() {\n        final Looper me = myLooper();//取得当前线程的Looper，当然实际上也是通过sThreadLocal.get()\n        if (me == null) {//如果没有说明没有调用prepare(),抛出异常\n            throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n        }\n        final MessageQueue queue = me.mQueue;//从当前的Looper对象里取得对应的MessageQueue\n\n        //do something............\n\n        for (; ; ) {\n            Message msg = queue.next(); // 取出消息，这里可能会堵塞，直到重新取到消息\n            if (msg == null) {\n              \t//如果返回为空，则表示MessageQueue正在退出，所以这里也直接退出无限循环\n              \t//这里是只有MessageQueue调用quit(boolean safe)方法才会退出\n              \t//下面会有详细解释\n                return;\n            }\n\n            //do something.............\n\n          \t//这个target是发送这个消息的handler，取得消息之后让发送的这个handler去处理\n          \t//后面我们会讲到，handler是如何把这个消息发送到当前这个MessageQueue中，并且target的赋值\n            msg.target.dispatchMessage(msg);\n\n            //do something.............\n            msg.recycleUnchecked();//回收这个消息\n        }\n}\n```\n\n通过代码应该很清晰就能展现出关键点，这里就不再赘述\n\n因为这里涉及到Looper.loop退出的情况，下面我们用代码类分析一下，关键就在`queue.next()`，为了便于理解还是只凸显出主要代码，还有很多MessageQueue的消息处理的一些代码就不赘述了，下面代码重点看那个返回值为空的判断语句\n\n```java\n    Message next() {\n\n        //do something..........\n\n        for (; ; ) {//next中也是一个无限循环着也就很好的说明为什么next()是一个可堵塞的方法啦\n\n            //do something..........\n\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n          \n            if (msg != null) {\n              \t//这里是后面handler的sendMessage方法会给message添加一个时间的处理\n                if (now < msg.when) {\n                    //do something..........\n                } else {\n                    //do something..........\n                    return msg;//如果所有条件都满足，就可以直接返回这个message了\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n\n            // Process the quit message now that all pending messages have been handled.\n          \t// 前面没有返回，这里如果为true只就直接返回null，前面Looper.loop就退出了\n            if (mQuitting) {\n                dispose();\n                return null;\n            }\n\n            //do something..........\n\n            if (pendingIdleHandlerCount <= 0) {\n                // No idle handlers to run.  Loop and wait some more.\n                mBlocked = true;\n                continue;\n            }\n\n            //do something..........\n\n        }\n    }\n\n```\n\n我们来看看`mQuitting`这个变量是在哪被赋值为true的\n\n```java\nvoid quit(boolean safe) {\n  \t//mQuitAllowed这个其实在前文多次提到了，Looper和MessageQueue的构造方法都需要\n  \t//用来设定是否可以被退出\n    if (!mQuitAllowed) {\n        throw new IllegalStateException(\"Main thread not allowed to quit.\");\n    }\n\n    synchronized (this) {\n        if (mQuitting) {\n            return;\n        }\n        mQuitting = true;//关键代码，这里赋值为true\n\n        if (safe) {\n            removeAllFutureMessagesLocked();\n        } else {\n            removeAllMessagesLocked();\n        }\n\n        // We can assume mPtr != 0 because mQuitting was previously false.\n        nativeWake(mPtr);\n    }\n}\n```\n\n从上面分析我们可以知道一旦调用了MessageQueue的quit的方法那么MessageQueue下一个利用next方法去取消息就会返回null，返回null就导致Looper的loop(也就是无限取消息的循环退出了),那么就有一个问题了，Looper也有一个quit方法，怎么实现的呢？\n\n```java\npublic void quit() {\n    mQueue.quit(false);\n}\n```\n\n恍然大悟！！！！！！！<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n## handler.sendMessage()\n\n看发送消息之前我们需要先看看**Handler的构造方法**\n\n```java\n//无参构造函数\npublic Handler() {\n    this(null, false);\n}\n\n//有参构造函数\npublic Handler(@Nullable Callback callback, boolean async) {\n  \n    //do something............\n  \n  \t//获取当前线程的Looper\n    mLooper = Looper.myLooper();\n    if (mLooper == null) {//同样如果没有Looper会报错（没有Looper.prepare()）\n        throw new RuntimeException(\n            \"Can't create handler inside thread \" + Thread.currentThread()\n                    + \" that has not called Looper.prepare()\");\n    }\n  \n    mQueue = mLooper.mQueue;//绑定当前线程的MessageQueue\n  \n    //do something............\n}\n```\n\n可以看出**Handler在那个线程创建**，它就会**直接绑定哪个线程的MessageQueue**，之后它`sendMessage()`就可以**直接放到这个MessageQueue里面**\n\n还是直接来看`sendMessage()`的代码\n\n```java\n//点进来第一个方法是这个\npublic final boolean sendMessage(@NonNull Message msg) {\n    return sendMessageDelayed(msg, 0);\n}\n\n//发送延迟处理的消息\npublic final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {\n   if (delayMillis < 0) {\n        delayMillis = 0;\n    }\n    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n}\n\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;//拿到创建Handler时绑定的那个MessageQueue\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n   \t}\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n\nprivate boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,\n        long uptimeMillis) {\n    msg.target = this;//【发送的消息】绑定【发送消息的这个handler】\n    msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n    if (mAsynchronous) {\n        msg.setAsynchronous(true);\n    }\n  \t//把消息交给MessageQueue去排序消息，这里是根据uptimeMillis转成具体时刻来排序的\n  \t//这里要注意，发送的延迟消息，只能保持设置的时间前这个消息不被处理\n  \t//但是无法保证这个消息具体在设置的时间之后的那个时候被处理\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n\n### handler.post()\n\n还是直接看代码，如果上面的理解了这个就非常简单了<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-8312b637ba6407992515ffa42b56391d_hd-3736965.jpg\" alt=\"img\" style=\"zoom:50%;\" />，只有一些区别\n\n```java\npublic final boolean post(@NonNull Runnable r) {\n   //这里仍然还是调用的发送延时消息的方法，区别是下面那个方法\n   return  sendMessageDelayed(getPostMessage(r), 0);\n}\n\n//将Runnable包装成Message，那么这个Runnable在哪会被调用呢\nprivate static Message getPostMessage(Runnable r) {\n    Message m = Message.obtain();\n    m.callback = r;\n    return m;\n}\n```\n\n还记得前面讲到的Looper.loop吗，它会把消息交给与他绑定的Handler去处理来看看这个方法\n\n```java\npublic void dispatchMessage(@NonNull Message msg) {\n    if (msg.callback != null) {//优先优先判断callback是不是空\n        handleCallback(msg);//不为空直接调用方法处理callback\n    } else {\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }\n}\n\nprivate static void handleCallback(Message message) {\n    message.callback.run();//这里直接执行了runnable的run方法\n}\n```\n\n\n\n# 结尾\n\n文章开头留下的悬念我想这下已经很清晰了，主线程中的main方法调用了Looper.loop,正是有这个无限循环的存在才会不会想一个简单的java程序一样，执行完了main里面的代码程序就结束了，而`prepareMainLooper\t`,正是为主线程（UI线程）准备了一个不可以退出的Looper。而这就可以说明Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞它。**也就说我们的代码其实就是在这个循环里面去执行的**，所以你在你的子线程要使用消息机制接受消息的话，最好将Looper.loop()放到你要直接执行的所有代码后面，不然没有执行qiut方法，后面的代码就不会执行。<img src=\"Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg\" alt=\"img\" style=\"zoom: 67%;\" />真逊，原来这么简单，是吧，看来还是要好好学习下去，知识++。","slug":"Android消息机制深入了解","published":1,"updated":"2020-03-10T09:34:52.701Z","comments":1,"layout":"post","photos":[],"link":"2020/03/08/Android消息机制深入了解","_id":"ck8jl8qhb0000w0w05tpl8g88","content":"<h1 id=\"为什么消息机制这么重要呢\">为什么消息机制这么重要呢<a href=\"#为什么消息机制这么重要呢\" title=\"为什么消息机制这么重要呢\"></a></h1><p>其实一个安卓的app也是有自己的<strong>main</strong>方法的<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg\" alt=\"img\" style=\"zoom:50%;\">，跟一个普通的java程序并没有太大的区别，只不过用户接触不到这个方法，这个方法在<strong>ActivityThread</strong>这个类里面，这个也就是android中所说的<strong>UI线程</strong>。你可能在想一个问题，那么既然是一个有main方法的java程序，那么一整个安卓的app究竟是怎么来运行的呢，如何做到和用户交互并执行这些代码的呢？？（这里涉及到很多东西，本文只讲与<strong>消息机制相关</strong>的，文章<strong>末尾</strong>我会一一解释）<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<h1 id=\"消息机制重要的三大成员\">消息机制重要的三大成员<a href=\"#消息机制重要的三大成员\" title=\"消息机制重要的三大成员\"></a></h1><ul><li><p><strong>MessageQueue</strong></p></li><li><p><strong>Looper</strong></p></li><li><p><strong>Handler</strong></p><blockquote><p>一个线程只能有一个Looper和MessageQueue，但是可以有多个handler，为什么呢？后面我们慢慢会讲到。</p></blockquote></li></ul><p>那么这三者是如何配合的呢，简单来说，<strong>MessageQueue</strong>就是一根<strong>运输消息管道</strong>，handler负责不断往里面<strong>放</strong>，<strong>Looper</strong>负责不断从里面<strong>取</strong>出来，又交给发送的这个handler去处理，那么就出现两个问题？</p>\n<ul><li>那么为什么要这样子设计？这样子设计怎么实现的<strong>跨线程通信</strong></li><li>为什么handler放进去最后looper又要交还给发送消息的这个handler去处理</li></ul><p>通过后面的源码解析，就能自己领会这两个问题</p>\n<h1 id=\"消息机制主要流程详解\">消息机制主要流程详解<a href=\"#消息机制主要流程详解\" title=\"消息机制主要流程详解\"></a></h1><p>如果你要在一个线程中使用消息机制</p>\n<p>首先需要<code>Looper.prepare();</code>和<code>Looper.loop();</code>，然后你就可以使用你的<strong>handler发送消息</strong>了。</p>\n<blockquote>\n<p>主线程是不需要自己<code>Looper.prepare();</code>和<code>Looper.loop();</code>在ActivityThread的main方法里面就已经执行了类似代码<code>Looper.prepareMainLooper();</code>和<code>Looper.loop();</code></p>\n</blockquote>\n<p>下面我会逐一从<strong>源码层面</strong>来分析整个消息机制的主要流程<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">，会不会很难呢，要不要继续学下去，头发 - -。</p>\n<h2 id=\"looperprepare；\">Looper.prepare()；<a href=\"#looperprepare；\" title=\"Looper.prepare()；\"></a></h2><p>首先我们点进去看看代码是如何实现的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个函数在ActivityThread的main方法里面执行,用户创建主线程的Looper对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        prepare(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The main Looper has already been prepared.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sMainLooper = myLooper();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通常我们在其他线程如果需要用到消息机制，会执行这个方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数重载，这个参数用于构造一个可以关闭或者无法关闭的Looper</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>最重要的方法就是第三个<code>prepare(boolean quitAllowed)</code>，我们可以看到代码很短，也很好理解。</p>\n<p>首先调用这个这个<strong>Looper类</strong>里面一个<strong>静态变量<code>sThreadLocal</code></strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure><p>这是一个<strong><code>ThreadLocal&lt;Looper&gt;</code>类型</strong>的一个变量，而且是直接<strong><code>new</code>出来的</strong>,点击进去看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadLocal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>查看<strong>ThreadLocal源代码里面的构造方法</strong>也没有做任何操作，说明本身这个变量是里是没有我们想要的东西的</p>\n<p>那么<strong>关键肯定是在<code>sThreadLocal.get()</code>里面</strong>，通过后面的抛出异常</p>\n<p><code>throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</code></p>\n<p>我们可以断定这个<strong>判断</strong>肯定<strong>是</strong>用来<strong>判断当前线程是否已经存在了一个Lopper对象</strong></p>\n<p>接下来我们来看<code>get()</code>方法内部</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码不是很多，我们一步步分析</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();<span class=\"comment\">//获得当前的线程对象</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);<span class=\"comment\">//从当前线程拿到一个ThreadLocalMap</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果这个ThreadLocalMap不为空</span></span><br><span class=\"line\">      \t<span class=\"comment\">//从里面取得Looper（这里做了一个包装，稍后会讲到）</span></span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果Lopper不为空</span></span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;<span class=\"comment\">//直接返回Looper</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();<span class=\"comment\">//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>可能虽然有注释还是有些疑惑，下面我们一一来讲解一下 Why<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-639605533bdb1ecf1c6562677a430554_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<p>首先我们来看看<strong><code>ThreadLocalMap map = getMap(t);</code>中<code>get(t)</code>的代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，是直接返回了<strong>当前线程对象</strong>的一个<strong>成员变量<code>threadLocals</code></strong>，那么这个<code>threadLocals</code>究竟是个什么东西呢？</p>\n<h3 id=\"threadlocal和threadlocalmap\">ThreadLocal和ThreadLocalMap<a href=\"#threadlocal和threadlocalmap\" title=\"ThreadLocal和ThreadLocalMap\"></a></h3><p>Entry是ThreadLocalMap的静态内部类，ThreadLocalMap是ThreadLocal的静态内部类</p>\n<p>首先我们来看<code>ThreadLocal</code>，顾名思义，直接翻译过来就是 “线程本地” ？？<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<p>我们来看看这个类的介绍注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * This class provides thread-local variables.  These variables differ from</span></span><br><span class=\"line\"><span class=\"comment\"> * their normal counterparts in that each thread that accesses one (via its</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> get&#125; or &#123;<span class=\"doctag\">@code</span> set&#125; method) has its own, independently initialized</span></span><br><span class=\"line\"><span class=\"comment\"> * copy of the variable.  &#123;<span class=\"doctag\">@code</span> ThreadLocal&#125; instances are typically private</span></span><br><span class=\"line\"><span class=\"comment\"> * static fields in classes that wish to associate state with a thread (e.g.,</span></span><br><span class=\"line\"><span class=\"comment\"> * a user ID or Transaction ID).</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 谷歌翻译版本:</span></span><br><span class=\"line\"><span class=\"comment\">* 此类提供线程局部变量</span></span><br><span class=\"line\"><span class=\"comment\">* 这些变量不同于它们的普通副本，</span></span><br><span class=\"line\"><span class=\"comment\">* 因为每个访问一个变量的线程（通过其&#123;<span class=\"doctag\">@code</span> get&#125;或&#123;<span class=\"doctag\">@code</span> set&#125;方法）</span></span><br><span class=\"line\"><span class=\"comment\">* 都有自己的、独立的变量副本。</span></span><br><span class=\"line\"><span class=\"comment\">* &#123;<span class=\"doctag\">@code</span> ThreadLocal&#125;实例通常是类中的私有静态字段，希望将状态与线程关联（例如，*用户ID或事务ID）。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure><p>通过注释我们可以很轻松的理解到，原来这个东西就是为每一个线程创建一个单独的变量副本的呀<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">。</p>\n<p>我们来看看到底怎么使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ThreadLocal&lt;Integer&gt; integerThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;()&#123;</span><br><span class=\"line\">            <span class=\"comment\">//这个方法专门用来提供开发者复写，提供副本默认值</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">2333</span>;<span class=\"comment\">//默认值我们这设置为</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//为这个ThreadLocal&lt;Integer&gt;在当前线程存一个副本，值为3222</span></span><br><span class=\"line\">                    <span class=\"comment\">//如果不是基本数据类型，注意值传递和引用传递的区别，这里需要new一个新的放进去</span></span><br><span class=\"line\">                    <span class=\"comment\">//例如：ThreadLocal的泛型是Runnable,</span></span><br><span class=\"line\">                    <span class=\"comment\">//那么就需要新建一个独立的Runnable实现类的对象</span></span><br><span class=\"line\">                    <span class=\"comment\">//runnableThreadLocal.set(new Runnable() &#123;</span></span><br><span class=\"line\">                    <span class=\"comment\">//            @Override</span></span><br><span class=\"line\">                    <span class=\"comment\">//            public void run() &#123;</span></span><br><span class=\"line\">                    <span class=\"comment\">//</span></span><br><span class=\"line\">                    <span class=\"comment\">//            &#125;</span></span><br><span class=\"line\">                    <span class=\"comment\">//        &#125;;)</span></span><br><span class=\"line\">                    integerThreadLocal.set(<span class=\"number\">3222</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//获取当前线程的副本，如果之前没有set()，那么默认值为2333</span></span><br><span class=\"line\">                  \t<span class=\"comment\">//如果之前set()了，就会取得set()的那个对象</span></span><br><span class=\"line\">                    integerThreadLocal.get();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                     * 通过以上代码，在这5个线程里都有了一个与integerThreadLocal对应</span></span><br><span class=\"line\"><span class=\"comment\">                     * 变量副本，这个副本是Integer类型的，每个线程通过integerThreadLocal.get()</span></span><br><span class=\"line\"><span class=\"comment\">                     * 取到的都是线程独有的，与其他线程完全隔离的一个副本</span></span><br><span class=\"line\"><span class=\"comment\">                     */</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的注释就足以理解这个东西的用法，这时候我们回到安卓来看看消息机制这里的设计，是不是就一下子恍然大悟了<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">，我这再梳理一下</p>\n<ul><li><p>首先Lopper中是有一个<code>sThreadLocal</code></p><p>理解了上面小Demo,就能知道因为这个<code>sThreadLocal</code>的存在，我们就可以在每一个线程存一个Looper副本</p><p>看，这是不是就很清晰了<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-8312b637ba6407992515ffa42b56391d_hd.jpg\" alt=\"img\" style=\"zoom:50%\"></p></li></ul><p>然后我们来看看<code>ThreadLocalMap</code>，前面我们看到<code>ThreadLocal.get()</code>的<code>get()</code>方法,这里再把代码贴一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();<span class=\"comment\">//获得当前的线程对象</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);<span class=\"comment\">//从当前线程拿到一个ThreadLocalMap</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果这个ThreadLocalMap不为空</span></span><br><span class=\"line\">      \t<span class=\"comment\">//从里面取得Looper（这里做了一个包装，稍后会讲到）</span></span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果Lopper不为空</span></span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;<span class=\"comment\">//直接返回Looper</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();<span class=\"comment\">//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以知道，一个线程对象里面是有一个<code>threadLocals</code>属性的，它是一个<code>ThreadLocalMap</code>类型的变量。就是它用来储存各种存在当前线程的副本。他是一个键值对存储的形式,下面是<code>ThreadLocalMap</code>的set（）方法的声明</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set(ThreadLocal&lt;?&gt; key, Object value)</span><br></pre></td></tr></table></figure><p>具体实现是比较复杂的，用到哈希表来储存，这里不展开讲了，有兴趣可以去了解一下，文章后面会有超链接。</p>\n<p>然后我们来看看<code>ThreadLocalMap.Entry e = map.getEntry(this);</code>这个行代码，肯定很多人都会有疑惑，首先我们需要看一下ThreadLocalMap.Entry这个静态内部类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">    Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里你可以看到这里是直接继承WeakReference弱引用这个类的，那为什么要这么设计呢？<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<p>这里我大致的说一下，ThreadLocal是为了每个线程中的对象副本服务的，一旦我不需要使用ThreadLocal这个对象了，那么我肯定会将ThreadLocal对象的强引用去掉，以防止内存泄漏，但是这个如果不这么设计，如果有一个线程的生命周期比ThreadLocal长，那么必定会持有ThreadLocal的引用，这样就会导致内存泄漏，ThreadLocal没有被使用但是却无法被GC回收。相比之下，这样设计就不会出现这个问题。</p>\n<h3 id=\"looper的构造方法\">Looper的构造方法<a href=\"#looper的构造方法\" title=\"Looper的构造方法\"></a></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);<span class=\"comment\">//生成一个MessageQueue，并作为成员保存在Looper中</span></span><br><span class=\"line\">    mThread = Thread.currentThread();<span class=\"comment\">//绑定当前线程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码也印证了Looper和MessageQueue一般都是同时出现的，而且都只能有一个的言论（因为prepare方法在一个线程调用一次，前面代码提到过）。</p>\n<h2 id=\"looperloop\">Looper.loop<a href=\"#looperloop\" title=\"Looper.loop\"></a></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//因为方便，我只选择了关键代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Looper me = myLooper();<span class=\"comment\">//取得当前线程的Looper，当然实际上也是通过sThreadLocal.get()</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果没有说明没有调用prepare(),抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;<span class=\"comment\">//从当前的Looper对象里取得对应的MessageQueue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//do something............</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; ; ) &#123;</span><br><span class=\"line\">            Message msg = queue.next(); <span class=\"comment\">// 取出消息，这里可能会堵塞，直到重新取到消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              \t<span class=\"comment\">//如果返回为空，则表示MessageQueue正在退出，所以这里也直接退出无限循环</span></span><br><span class=\"line\">              \t<span class=\"comment\">//这里是只有MessageQueue调用quit(boolean safe)方法才会退出</span></span><br><span class=\"line\">              \t<span class=\"comment\">//下面会有详细解释</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//do something.............</span></span><br><span class=\"line\"></span><br><span class=\"line\">          \t<span class=\"comment\">//这个target是发送这个消息的handler，取得消息之后让发送的这个handler去处理</span></span><br><span class=\"line\">          \t<span class=\"comment\">//后面我们会讲到，handler是如何把这个消息发送到当前这个MessageQueue中，并且target的赋值</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//do something.............</span></span><br><span class=\"line\">            msg.recycleUnchecked();<span class=\"comment\">//回收这个消息</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>通过代码应该很清晰就能展现出关键点，这里就不再赘述</p>\n<p>因为这里涉及到Looper.loop退出的情况，下面我们用代码类分析一下，关键就在<code>queue.next()</code>，为了便于理解还是只凸显出主要代码，还有很多MessageQueue的消息处理的一些代码就不赘述了，下面代码重点看那个返回值为空的判断语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//do something..........</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; ; ) &#123;<span class=\"comment\">//next中也是一个无限循环着也就很好的说明为什么next()是一个可堵塞的方法啦</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//do something..........</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                prevMsg = msg;</span><br><span class=\"line\">                msg = msg.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">//这里是后面handler的sendMessage方法会给message添加一个时间的处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//do something..........</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//do something..........</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> msg;<span class=\"comment\">//如果所有条件都满足，就可以直接返回这个message了</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">            nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Process the quit message now that all pending messages have been handled.</span></span><br><span class=\"line\">      \t<span class=\"comment\">// 前面没有返回，这里如果为true只就直接返回null，前面Looper.loop就退出了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            dispose();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//do something..........</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class=\"line\">            mBlocked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//do something..........</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看<code>mQuitting</code>这个变量是在哪被赋值为true的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">(<span class=\"keyword\">boolean</span> safe)</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">//mQuitAllowed这个其实在前文多次提到了，Looper和MessageQueue的构造方法都需要</span></span><br><span class=\"line\">  \t<span class=\"comment\">//用来设定是否可以被退出</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mQuitAllowed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Main thread not allowed to quit.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mQuitting = <span class=\"keyword\">true</span>;<span class=\"comment\">//关键代码，这里赋值为true</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (safe) &#123;</span><br><span class=\"line\">            removeAllFutureMessagesLocked();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            removeAllMessagesLocked();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class=\"line\">        nativeWake(mPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>从上面分析我们可以知道一旦调用了MessageQueue的quit的方法那么MessageQueue下一个利用next方法去取消息就会返回null，返回null就导致Looper的loop(也就是无限取消息的循环退出了),那么就有一个问题了，Looper也有一个quit方法，怎么实现的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>恍然大悟！！！！！！！<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<h2 id=\"handlersendmessage\">handler.sendMessage()<a href=\"#handlersendmessage\" title=\"handler.sendMessage()\"></a></h2><p>看发送消息之前我们需要先看看<strong>Handler的构造方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//无参构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(@Nullable Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//do something............</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  \t<span class=\"comment\">//获取当前线程的Looper</span></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//同样如果没有Looper会报错（没有Looper.prepare()）</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread \"</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">\" that has not called Looper.prepare()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    mQueue = mLooper.mQueue;<span class=\"comment\">//绑定当前线程的MessageQueue</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//do something............</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>可以看出<strong>Handler在那个线程创建</strong>，它就会<strong>直接绑定哪个线程的MessageQueue</strong>，之后它<code>sendMessage()</code>就可以<strong>直接放到这个MessageQueue里面</strong></p>\n<p>还是直接来看<code>sendMessage()</code>的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//点进来第一个方法是这个</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessage</span><span class=\"params\">(@NonNull Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送延迟处理的消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageDelayed</span><span class=\"params\">(@NonNull Message msg, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        delayMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(@NonNull Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;<span class=\"comment\">//拿到创建Handler时绑定的那个MessageQueue</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(@NonNull MessageQueue queue, @NonNull Message msg,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    msg.target = <span class=\"keyword\">this</span>;<span class=\"comment\">//【发送的消息】绑定【发送消息的这个handler】</span></span><br><span class=\"line\">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"comment\">//把消息交给MessageQueue去排序消息，这里是根据uptimeMillis转成具体时刻来排序的</span></span><br><span class=\"line\">  \t<span class=\"comment\">//这里要注意，发送的延迟消息，只能保持设置的时间前这个消息不被处理</span></span><br><span class=\"line\">  \t<span class=\"comment\">//但是无法保证这个消息具体在设置的时间之后的那个时候被处理</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"handlerpost\">handler.post()<a href=\"#handlerpost\" title=\"handler.post()\"></a></h3><p>还是直接看代码，如果上面的理解了这个就非常简单了<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-8312b637ba6407992515ffa42b56391d_hd-3736965.jpg\" alt=\"img\" style=\"zoom:50%;\">，只有一些区别</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">post</span><span class=\"params\">(@NonNull Runnable r)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//这里仍然还是调用的发送延时消息的方法，区别是下面那个方法</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span>  sendMessageDelayed(getPostMessage(r), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将Runnable包装成Message，那么这个Runnable在哪会被调用呢</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Message <span class=\"title\">getPostMessage</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">    Message m = Message.obtain();</span><br><span class=\"line\">    m.callback = r;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>还记得前面讲到的Looper.loop吗，它会把消息交给与他绑定的Handler去处理来看看这个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(@NonNull Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//优先优先判断callback是不是空</span></span><br><span class=\"line\">        handleCallback(msg);<span class=\"comment\">//不为空直接调用方法处理callback</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handleCallback</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">    message.callback.run();<span class=\"comment\">//这里直接执行了runnable的run方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h1 id=\"结尾\">结尾<a href=\"#结尾\" title=\"结尾\"></a></h1><p>文章开头留下的悬念我想这下已经很清晰了，主线程中的main方法调用了Looper.loop,正是有这个无限循环的存在才会不会想一个简单的java程序一样，执行完了main里面的代码程序就结束了，而<code>prepareMainLooper</code>,正是为主线程（UI线程）准备了一个不可以退出的Looper。而这就可以说明Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞它。<strong>也就说我们的代码其实就是在这个循环里面去执行的</strong>，所以你在你的子线程要使用消息机制接受消息的话，最好将Looper.loop()放到你要直接执行的所有代码后面，不然没有执行qiut方法，后面的代码就不会执行。<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg\" alt=\"img\" style=\"zoom: 67%;\">真逊，原来这么简单，是吧，看来还是要好好学习下去，知识++。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么消息机制这么重要呢\">为什么消息机制这么重要呢<a href=\"#为什么消息机制这么重要呢\" title=\"为什么消息机制这么重要呢\"></a></h1><p>其实一个安卓的app也是有自己的<strong>main</strong>方法的<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg\" alt=\"img\" style=\"zoom:50%;\">，跟一个普通的java程序并没有太大的区别，只不过用户接触不到这个方法，这个方法在<strong>ActivityThread</strong>这个类里面，这个也就是android中所说的<strong>UI线程</strong>。你可能在想一个问题，那么既然是一个有main方法的java程序，那么一整个安卓的app究竟是怎么来运行的呢，如何做到和用户交互并执行这些代码的呢？？（这里涉及到很多东西，本文只讲与<strong>消息机制相关</strong>的，文章<strong>末尾</strong>我会一一解释）<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<h1 id=\"消息机制重要的三大成员\">消息机制重要的三大成员<a href=\"#消息机制重要的三大成员\" title=\"消息机制重要的三大成员\"></a></h1><ul><li><p><strong>MessageQueue</strong></p></li><li><p><strong>Looper</strong></p></li><li><p><strong>Handler</strong></p><blockquote><p>一个线程只能有一个Looper和MessageQueue，但是可以有多个handler，为什么呢？后面我们慢慢会讲到。</p></blockquote></li></ul><p>那么这三者是如何配合的呢，简单来说，<strong>MessageQueue</strong>就是一根<strong>运输消息管道</strong>，handler负责不断往里面<strong>放</strong>，<strong>Looper</strong>负责不断从里面<strong>取</strong>出来，又交给发送的这个handler去处理，那么就出现两个问题？</p>\n<ul><li>那么为什么要这样子设计？这样子设计怎么实现的<strong>跨线程通信</strong></li><li>为什么handler放进去最后looper又要交还给发送消息的这个handler去处理</li></ul><p>通过后面的源码解析，就能自己领会这两个问题</p>\n<h1 id=\"消息机制主要流程详解\">消息机制主要流程详解<a href=\"#消息机制主要流程详解\" title=\"消息机制主要流程详解\"></a></h1><p>如果你要在一个线程中使用消息机制</p>\n<p>首先需要<code>Looper.prepare();</code>和<code>Looper.loop();</code>，然后你就可以使用你的<strong>handler发送消息</strong>了。</p>\n<blockquote>\n<p>主线程是不需要自己<code>Looper.prepare();</code>和<code>Looper.loop();</code>在ActivityThread的main方法里面就已经执行了类似代码<code>Looper.prepareMainLooper();</code>和<code>Looper.loop();</code></p>\n</blockquote>\n<p>下面我会逐一从<strong>源码层面</strong>来分析整个消息机制的主要流程<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">，会不会很难呢，要不要继续学下去，头发 - -。</p>\n<h2 id=\"looperprepare；\">Looper.prepare()；<a href=\"#looperprepare；\" title=\"Looper.prepare()；\"></a></h2><p>首先我们点进去看看代码是如何实现的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个函数在ActivityThread的main方法里面执行,用户创建主线程的Looper对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        prepare(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The main Looper has already been prepared.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sMainLooper = myLooper();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通常我们在其他线程如果需要用到消息机制，会执行这个方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数重载，这个参数用于构造一个可以关闭或者无法关闭的Looper</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>最重要的方法就是第三个<code>prepare(boolean quitAllowed)</code>，我们可以看到代码很短，也很好理解。</p>\n<p>首先调用这个这个<strong>Looper类</strong>里面一个<strong>静态变量<code>sThreadLocal</code></strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure><p>这是一个<strong><code>ThreadLocal&lt;Looper&gt;</code>类型</strong>的一个变量，而且是直接<strong><code>new</code>出来的</strong>,点击进去看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadLocal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>查看<strong>ThreadLocal源代码里面的构造方法</strong>也没有做任何操作，说明本身这个变量是里是没有我们想要的东西的</p>\n<p>那么<strong>关键肯定是在<code>sThreadLocal.get()</code>里面</strong>，通过后面的抛出异常</p>\n<p><code>throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</code></p>\n<p>我们可以断定这个<strong>判断</strong>肯定<strong>是</strong>用来<strong>判断当前线程是否已经存在了一个Lopper对象</strong></p>\n<p>接下来我们来看<code>get()</code>方法内部</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代码不是很多，我们一步步分析</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();<span class=\"comment\">//获得当前的线程对象</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);<span class=\"comment\">//从当前线程拿到一个ThreadLocalMap</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果这个ThreadLocalMap不为空</span></span><br><span class=\"line\">      \t<span class=\"comment\">//从里面取得Looper（这里做了一个包装，稍后会讲到）</span></span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果Lopper不为空</span></span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;<span class=\"comment\">//直接返回Looper</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();<span class=\"comment\">//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>可能虽然有注释还是有些疑惑，下面我们一一来讲解一下 Why<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-639605533bdb1ecf1c6562677a430554_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<p>首先我们来看看<strong><code>ThreadLocalMap map = getMap(t);</code>中<code>get(t)</code>的代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，是直接返回了<strong>当前线程对象</strong>的一个<strong>成员变量<code>threadLocals</code></strong>，那么这个<code>threadLocals</code>究竟是个什么东西呢？</p>\n<h3 id=\"threadlocal和threadlocalmap\">ThreadLocal和ThreadLocalMap<a href=\"#threadlocal和threadlocalmap\" title=\"ThreadLocal和ThreadLocalMap\"></a></h3><p>Entry是ThreadLocalMap的静态内部类，ThreadLocalMap是ThreadLocal的静态内部类</p>\n<p>首先我们来看<code>ThreadLocal</code>，顾名思义，直接翻译过来就是 “线程本地” ？？<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<p>我们来看看这个类的介绍注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * This class provides thread-local variables.  These variables differ from</span></span><br><span class=\"line\"><span class=\"comment\"> * their normal counterparts in that each thread that accesses one (via its</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> get&#125; or &#123;<span class=\"doctag\">@code</span> set&#125; method) has its own, independently initialized</span></span><br><span class=\"line\"><span class=\"comment\"> * copy of the variable.  &#123;<span class=\"doctag\">@code</span> ThreadLocal&#125; instances are typically private</span></span><br><span class=\"line\"><span class=\"comment\"> * static fields in classes that wish to associate state with a thread (e.g.,</span></span><br><span class=\"line\"><span class=\"comment\"> * a user ID or Transaction ID).</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 谷歌翻译版本:</span></span><br><span class=\"line\"><span class=\"comment\">* 此类提供线程局部变量</span></span><br><span class=\"line\"><span class=\"comment\">* 这些变量不同于它们的普通副本，</span></span><br><span class=\"line\"><span class=\"comment\">* 因为每个访问一个变量的线程（通过其&#123;<span class=\"doctag\">@code</span> get&#125;或&#123;<span class=\"doctag\">@code</span> set&#125;方法）</span></span><br><span class=\"line\"><span class=\"comment\">* 都有自己的、独立的变量副本。</span></span><br><span class=\"line\"><span class=\"comment\">* &#123;<span class=\"doctag\">@code</span> ThreadLocal&#125;实例通常是类中的私有静态字段，希望将状态与线程关联（例如，*用户ID或事务ID）。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure><p>通过注释我们可以很轻松的理解到，原来这个东西就是为每一个线程创建一个单独的变量副本的呀<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">。</p>\n<p>我们来看看到底怎么使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ThreadLocal&lt;Integer&gt; integerThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;()&#123;</span><br><span class=\"line\">            <span class=\"comment\">//这个方法专门用来提供开发者复写，提供副本默认值</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">2333</span>;<span class=\"comment\">//默认值我们这设置为</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//为这个ThreadLocal&lt;Integer&gt;在当前线程存一个副本，值为3222</span></span><br><span class=\"line\">                    <span class=\"comment\">//如果不是基本数据类型，注意值传递和引用传递的区别，这里需要new一个新的放进去</span></span><br><span class=\"line\">                    <span class=\"comment\">//例如：ThreadLocal的泛型是Runnable,</span></span><br><span class=\"line\">                    <span class=\"comment\">//那么就需要新建一个独立的Runnable实现类的对象</span></span><br><span class=\"line\">                    <span class=\"comment\">//runnableThreadLocal.set(new Runnable() &#123;</span></span><br><span class=\"line\">                    <span class=\"comment\">//            @Override</span></span><br><span class=\"line\">                    <span class=\"comment\">//            public void run() &#123;</span></span><br><span class=\"line\">                    <span class=\"comment\">//</span></span><br><span class=\"line\">                    <span class=\"comment\">//            &#125;</span></span><br><span class=\"line\">                    <span class=\"comment\">//        &#125;;)</span></span><br><span class=\"line\">                    integerThreadLocal.set(<span class=\"number\">3222</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//获取当前线程的副本，如果之前没有set()，那么默认值为2333</span></span><br><span class=\"line\">                  \t<span class=\"comment\">//如果之前set()了，就会取得set()的那个对象</span></span><br><span class=\"line\">                    integerThreadLocal.get();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                     * 通过以上代码，在这5个线程里都有了一个与integerThreadLocal对应</span></span><br><span class=\"line\"><span class=\"comment\">                     * 变量副本，这个副本是Integer类型的，每个线程通过integerThreadLocal.get()</span></span><br><span class=\"line\"><span class=\"comment\">                     * 取到的都是线程独有的，与其他线程完全隔离的一个副本</span></span><br><span class=\"line\"><span class=\"comment\">                     */</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的注释就足以理解这个东西的用法，这时候我们回到安卓来看看消息机制这里的设计，是不是就一下子恍然大悟了<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">，我这再梳理一下</p>\n<ul><li><p>首先Lopper中是有一个<code>sThreadLocal</code></p><p>理解了上面小Demo,就能知道因为这个<code>sThreadLocal</code>的存在，我们就可以在每一个线程存一个Looper副本</p><p>看，这是不是就很清晰了<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-8312b637ba6407992515ffa42b56391d_hd.jpg\" alt=\"img\" style=\"zoom:50%\"></p></li></ul><p>然后我们来看看<code>ThreadLocalMap</code>，前面我们看到<code>ThreadLocal.get()</code>的<code>get()</code>方法,这里再把代码贴一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();<span class=\"comment\">//获得当前的线程对象</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);<span class=\"comment\">//从当前线程拿到一个ThreadLocalMap</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果这个ThreadLocalMap不为空</span></span><br><span class=\"line\">      \t<span class=\"comment\">//从里面取得Looper（这里做了一个包装，稍后会讲到）</span></span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果Lopper不为空</span></span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;<span class=\"comment\">//直接返回Looper</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();<span class=\"comment\">//如果从当前线程中取得的ThreadLocalMap为空，则进行初始化操作</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以知道，一个线程对象里面是有一个<code>threadLocals</code>属性的，它是一个<code>ThreadLocalMap</code>类型的变量。就是它用来储存各种存在当前线程的副本。他是一个键值对存储的形式,下面是<code>ThreadLocalMap</code>的set（）方法的声明</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set(ThreadLocal&lt;?&gt; key, Object value)</span><br></pre></td></tr></table></figure><p>具体实现是比较复杂的，用到哈希表来储存，这里不展开讲了，有兴趣可以去了解一下，文章后面会有超链接。</p>\n<p>然后我们来看看<code>ThreadLocalMap.Entry e = map.getEntry(this);</code>这个行代码，肯定很多人都会有疑惑，首先我们需要看一下ThreadLocalMap.Entry这个静态内部类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">    Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里你可以看到这里是直接继承WeakReference弱引用这个类的，那为什么要这么设计呢？<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<p>这里我大致的说一下，ThreadLocal是为了每个线程中的对象副本服务的，一旦我不需要使用ThreadLocal这个对象了，那么我肯定会将ThreadLocal对象的强引用去掉，以防止内存泄漏，但是这个如果不这么设计，如果有一个线程的生命周期比ThreadLocal长，那么必定会持有ThreadLocal的引用，这样就会导致内存泄漏，ThreadLocal没有被使用但是却无法被GC回收。相比之下，这样设计就不会出现这个问题。</p>\n<h3 id=\"looper的构造方法\">Looper的构造方法<a href=\"#looper的构造方法\" title=\"Looper的构造方法\"></a></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);<span class=\"comment\">//生成一个MessageQueue，并作为成员保存在Looper中</span></span><br><span class=\"line\">    mThread = Thread.currentThread();<span class=\"comment\">//绑定当前线程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码也印证了Looper和MessageQueue一般都是同时出现的，而且都只能有一个的言论（因为prepare方法在一个线程调用一次，前面代码提到过）。</p>\n<h2 id=\"looperloop\">Looper.loop<a href=\"#looperloop\" title=\"Looper.loop\"></a></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//因为方便，我只选择了关键代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Looper me = myLooper();<span class=\"comment\">//取得当前线程的Looper，当然实际上也是通过sThreadLocal.get()</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//如果没有说明没有调用prepare(),抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;<span class=\"comment\">//从当前的Looper对象里取得对应的MessageQueue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//do something............</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; ; ) &#123;</span><br><span class=\"line\">            Message msg = queue.next(); <span class=\"comment\">// 取出消息，这里可能会堵塞，直到重新取到消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              \t<span class=\"comment\">//如果返回为空，则表示MessageQueue正在退出，所以这里也直接退出无限循环</span></span><br><span class=\"line\">              \t<span class=\"comment\">//这里是只有MessageQueue调用quit(boolean safe)方法才会退出</span></span><br><span class=\"line\">              \t<span class=\"comment\">//下面会有详细解释</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//do something.............</span></span><br><span class=\"line\"></span><br><span class=\"line\">          \t<span class=\"comment\">//这个target是发送这个消息的handler，取得消息之后让发送的这个handler去处理</span></span><br><span class=\"line\">          \t<span class=\"comment\">//后面我们会讲到，handler是如何把这个消息发送到当前这个MessageQueue中，并且target的赋值</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//do something.............</span></span><br><span class=\"line\">            msg.recycleUnchecked();<span class=\"comment\">//回收这个消息</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>通过代码应该很清晰就能展现出关键点，这里就不再赘述</p>\n<p>因为这里涉及到Looper.loop退出的情况，下面我们用代码类分析一下，关键就在<code>queue.next()</code>，为了便于理解还是只凸显出主要代码，还有很多MessageQueue的消息处理的一些代码就不赘述了，下面代码重点看那个返回值为空的判断语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//do something..........</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; ; ) &#123;<span class=\"comment\">//next中也是一个无限循环着也就很好的说明为什么next()是一个可堵塞的方法啦</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//do something..........</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                prevMsg = msg;</span><br><span class=\"line\">                msg = msg.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">//这里是后面handler的sendMessage方法会给message添加一个时间的处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//do something..........</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//do something..........</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> msg;<span class=\"comment\">//如果所有条件都满足，就可以直接返回这个message了</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">            nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Process the quit message now that all pending messages have been handled.</span></span><br><span class=\"line\">      \t<span class=\"comment\">// 前面没有返回，这里如果为true只就直接返回null，前面Looper.loop就退出了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            dispose();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//do something..........</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class=\"line\">            mBlocked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//do something..........</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看<code>mQuitting</code>这个变量是在哪被赋值为true的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">(<span class=\"keyword\">boolean</span> safe)</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">//mQuitAllowed这个其实在前文多次提到了，Looper和MessageQueue的构造方法都需要</span></span><br><span class=\"line\">  \t<span class=\"comment\">//用来设定是否可以被退出</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mQuitAllowed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Main thread not allowed to quit.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mQuitting = <span class=\"keyword\">true</span>;<span class=\"comment\">//关键代码，这里赋值为true</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (safe) &#123;</span><br><span class=\"line\">            removeAllFutureMessagesLocked();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            removeAllMessagesLocked();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class=\"line\">        nativeWake(mPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>从上面分析我们可以知道一旦调用了MessageQueue的quit的方法那么MessageQueue下一个利用next方法去取消息就会返回null，返回null就导致Looper的loop(也就是无限取消息的循环退出了),那么就有一个问题了，Looper也有一个quit方法，怎么实现的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue.quit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>恍然大悟！！！！！！！<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<h2 id=\"handlersendmessage\">handler.sendMessage()<a href=\"#handlersendmessage\" title=\"handler.sendMessage()\"></a></h2><p>看发送消息之前我们需要先看看<strong>Handler的构造方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//无参构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(@Nullable Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//do something............</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  \t<span class=\"comment\">//获取当前线程的Looper</span></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//同样如果没有Looper会报错（没有Looper.prepare()）</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Can't create handler inside thread \"</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">\" that has not called Looper.prepare()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    mQueue = mLooper.mQueue;<span class=\"comment\">//绑定当前线程的MessageQueue</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//do something............</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>可以看出<strong>Handler在那个线程创建</strong>，它就会<strong>直接绑定哪个线程的MessageQueue</strong>，之后它<code>sendMessage()</code>就可以<strong>直接放到这个MessageQueue里面</strong></p>\n<p>还是直接来看<code>sendMessage()</code>的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//点进来第一个方法是这个</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessage</span><span class=\"params\">(@NonNull Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送延迟处理的消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageDelayed</span><span class=\"params\">(@NonNull Message msg, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        delayMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(@NonNull Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;<span class=\"comment\">//拿到创建Handler时绑定的那个MessageQueue</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(@NonNull MessageQueue queue, @NonNull Message msg,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    msg.target = <span class=\"keyword\">this</span>;<span class=\"comment\">//【发送的消息】绑定【发送消息的这个handler】</span></span><br><span class=\"line\">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"comment\">//把消息交给MessageQueue去排序消息，这里是根据uptimeMillis转成具体时刻来排序的</span></span><br><span class=\"line\">  \t<span class=\"comment\">//这里要注意，发送的延迟消息，只能保持设置的时间前这个消息不被处理</span></span><br><span class=\"line\">  \t<span class=\"comment\">//但是无法保证这个消息具体在设置的时间之后的那个时候被处理</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"handlerpost\">handler.post()<a href=\"#handlerpost\" title=\"handler.post()\"></a></h3><p>还是直接看代码，如果上面的理解了这个就非常简单了<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-8312b637ba6407992515ffa42b56391d_hd-3736965.jpg\" alt=\"img\" style=\"zoom:50%;\">，只有一些区别</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">post</span><span class=\"params\">(@NonNull Runnable r)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//这里仍然还是调用的发送延时消息的方法，区别是下面那个方法</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span>  sendMessageDelayed(getPostMessage(r), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将Runnable包装成Message，那么这个Runnable在哪会被调用呢</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Message <span class=\"title\">getPostMessage</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">    Message m = Message.obtain();</span><br><span class=\"line\">    m.callback = r;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>还记得前面讲到的Looper.loop吗，它会把消息交给与他绑定的Handler去处理来看看这个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(@NonNull Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//优先优先判断callback是不是空</span></span><br><span class=\"line\">        handleCallback(msg);<span class=\"comment\">//不为空直接调用方法处理callback</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handleCallback</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">    message.callback.run();<span class=\"comment\">//这里直接执行了runnable的run方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h1 id=\"结尾\">结尾<a href=\"#结尾\" title=\"结尾\"></a></h1><p>文章开头留下的悬念我想这下已经很清晰了，主线程中的main方法调用了Looper.loop,正是有这个无限循环的存在才会不会想一个简单的java程序一样，执行完了main里面的代码程序就结束了，而<code>prepareMainLooper</code>,正是为主线程（UI线程）准备了一个不可以退出的Looper。而这就可以说明Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞它。<strong>也就说我们的代码其实就是在这个循环里面去执行的</strong>，所以你在你的子线程要使用消息机制接受消息的话，最好将Looper.loop()放到你要直接执行的所有代码后面，不然没有执行qiut方法，后面的代码就不会执行。<img src=\"/2020/03/08/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg\" alt=\"img\" style=\"zoom: 67%;\">真逊，原来这么简单，是吧，看来还是要好好学习下去，知识++。</p>\n","date_formatted":{"ll":"Mar 8, 2020","L":"03/08/2020","MM-DD":"03-08"},"plink":"https://treeeeeeee.github.io/2020/03/08/Android消息机制深入了解/","type":"post","toc":[{"id":"为什么消息机制这么重要呢","title":"为什么消息机制这么重要呢","index":"1"},{"id":"消息机制重要的三大成员","title":"消息机制重要的三大成员","index":"2"},{"id":"消息机制主要流程详解","title":"消息机制主要流程详解","index":"3","children":[{"id":"looperprepare；","title":"Looper.prepare()；","index":"3.1","children":[{"id":"threadlocal和threadlocalmap","title":"ThreadLocal和ThreadLocalMap","index":"3.1.1"},{"id":"looper的构造方法","title":"Looper的构造方法","index":"3.1.2"}]},{"id":"looperloop","title":"Looper.loop","index":"3.2"},{"id":"handlersendmessage","title":"handler.sendMessage()","index":"3.3","children":[{"id":"handlerpost","title":"handler.post()","index":"3.3.1"}]}]},{"id":"结尾","title":"结尾","index":"4"}]},{"title":"JVM-内存管理和垃圾回收","date":"2020-04-01T13:38:41.000Z","thumbnail":"2020/04/01/JVM-内存管理和垃圾回收/../JVM-内存管理和垃圾回收/w.png","_content":"\n## 内存管理\n\n![JVM内存管理总图w](JVM-内存管理和垃圾回收/w.png)\n\n### 方法区 （元空间/持久代）\n\n**线程共享**，存放类加载之后存放类的数据结构，静态常量，JIT(即时编译器)编译后代码也在方法区存放\n\n### 堆区\n\n**线程共享**，对象所在的区域，也是垃圾回收的主要场所\n\n### 虚拟机栈\n\n按照方法执行的顺序，先进后出\n\n#### 栈帧\n\n* 局部变量表\n* 操作数栈\n* 动态链接\n* 方法出口\n\n来看看一段简单的代码，主要分析demo()方法\n\n```java\npublic class Main {\n\n    public static void main(String[] args){\n        demo();\n    }\n\n    public static int  demo(){\n        int a = 20;\n        int b = 30;\n        int c = (a + b) * 100;\n        return c;\n    }\n}\n```\n\n这里的demo（）方法会有一个局部变量表\n\n![局部变量表 ](JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%20(1).png)\n\n赋默认值，真正使用的时候才会对其进行初始化。\n\n我们把编译好了的java文件利用javap命令对class文件进行反汇编 `javap -c Main.class`\n\n```java\nCompiled from \"Main.java\"\npublic class Main {\n  public Main();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       //后面的#加数字代表动态链接，不然程序无法准确的找到\n       // (执行静态方法#2【#2就代表一个静态方法，通过#2就可以准确找到所要执行的方法】)\n       0: invokestatic  #2                  \n       3: pop\t\t//将栈顶一个字长的数据弹出来\n       4: return\n\n  public static int demo();\n    Code:\n       0: bipush        20  //将一个8位带符号整数（20）压入栈\n       2: istore_0\t\t\t//将操作数栈中栈顶int类型的值存入局部变量0\n       3: bipush        30\t//将一个8位带符号整数（30）压入栈\n       5: istore_1\t\t\t//将操作数栈中栈顶int类型的值存入局部变量1\n       6: iload_0\t\t\t//将局部变量0中的int类型值装载到操作数栈\n       7: iload_1\t\t\t//将局部变量1中的int类型值装载到操作数栈\n       8: iadd\t\t\t\t//操作数栈中的前两个int弹出并相加，并将结果压入操作数栈顶\n       9: bipush        100\t//将一个8位带符号整数（100）压入栈\n      11: imul\t\t\t\t//操作数栈中的前两个int弹出并相乘，并将结果压入操作数栈顶\n      12: istore_2\t\t\t//将操作数栈中栈顶int类型的值存入局部变量2\n      13: iload_2\t\t\t//将局部变量2中的int类型值装载到操作数栈\n      14: ireturn\t\t\t//将操作数栈中的int值返回\n          \n      //那么前面的序号什么意思呢，这里就是程序计数器为了保证指令的正确执行所需要的序号\n}\n```\n\n从注释可以很清晰的看出来没一步都在做什么，至于JVM指令都代表什么可以看一下这个记录文档[JVM指令一览收藏](https://jontree.github.io/2020/04/03/JVM-%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95%E4%B8%80%E8%A7%88)\n\n至于动态上面的动态链接，这里重新给一个例子。\n\n```java\nclass Demo{\n\n}\n\npublic class Main {\n    public static void main(String[] args){\n        Demo demo = new Demo();\n    }\n}\n```\n\n这次我们使用输出信息更加精确的`javap -v Main.class`\n\n```java\nCompiled from \"Main.java\"\npublic class Main\n  minor version: 0\n  major version: 56\n  flags: (0x0021) ACC_PUBLIC, ACC_SUPER\n  this_class: #4                          // Main\n  super_class: #5                         // java/lang/Object\n  interfaces: 0, fields: 0, methods: 2, attributes: 1\nConstant pool://这里声明一些映射，方便下面链接\n   #1 = Methodref          #5.#21         // java/lang/Object.\"<init>\":()V\n   #2 = Class              #22            // Demo\n   #3 = Methodref          #2.#21         // Demo.\"<init>\":()V\n   #4 = Class              #23            // Main\n   #5 = Class              #24            // java/lang/Object\n   #6 = Utf8               <init>\n   #7 = Utf8               ()V\n   #8 = Utf8               Code\n   #9 = Utf8               LineNumberTable\n  #10 = Utf8               LocalVariableTable\n  #11 = Utf8               this\n  #12 = Utf8               LMain;\n  #13 = Utf8               main\n  #14 = Utf8               ([Ljava/lang/String;)V\n  #15 = Utf8               args\n  #16 = Utf8               [Ljava/lang/String;\n  #17 = Utf8               demo\n  #18 = Utf8               LDemo;\n  #19 = Utf8               SourceFile\n  #20 = Utf8               Main.java\n  #21 = NameAndType        #6:#7          // \"<init>\":()V\n  #22 = Utf8               Demo\n  #23 = Utf8               Main\n  #24 = Utf8               java/lang/Object\n{\n  public Main();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 5: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   LMain;\n\n  public static void main(java.lang.String[]);//main方法\n    descriptor: ([Ljava/lang/String;)V\n    flags: (0x0009) ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=2, args_size=1\n         //new 指令在堆中创建一个Java对象，并将该对象的地址压入操作数栈\n         0: new           #2                  // class Demo\n         //复制栈顶一个字长的数据（这里是上面创建的java对象的地址，此时操作数栈中有两个地址）\n         3: dup\n         //使用栈顶的地址调用方法并弹出栈顶\n         4: invokespecial #3                  // Method Demo.\"<init>\":()V\n         //将引用类型或returnAddress类型值存入局部变量1(这里将剩下的一份地址存到局部变量里面去了)\n         7: astore_1\n         8: return\n      LineNumberTable:\n        line 7: 0\n        line 8: 8\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       9     0  args   [Ljava/lang/String;\n            8       1     1  demo   LDemo;\n}\n```\n\n### 程序计数器\n\n当前线程执行的字节码的位置指示器\n\n### 本地方法栈 \n\n为JVM提供使用native方法的服务大致结构和虚拟机栈差不多 \n\n## 垃圾回收\n\nSTW（stop the world）：停止其他所有工作\n\nMinor GC：轻量级，耗时短，会出现STW\n\nFull GC：重量级，耗时长，会出现STW\n\n### 判断是否可回收\n\n#### 引用计数\n\n#### 根搜索算法\n\n所谓的GC根对象包括：\n\n- 虚拟机栈中引用的对象（**栈帧**中的**本地变量表**）；\n- 方法区中的**常量引用的对象**；\n- 方法区中的**类静态属性引用的对象**；\n- 本地方法栈中**JNI（Native方法）的引用对象**。\n- **活跃线程**。\n\n从根对象开始向下寻找，能够在引用链上找到这个对象就说明这个对象是可以存活的。\n\n在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：\n\n-  如果对象在进行根搜索后发现没有与`GC Roots`相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 `finalize（）`方法（可看作析构函数）。当对象没有覆盖`finalize（）`方法，或`finalize（）`方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。\n- 如果该对象被判定为有必要执行`finalize（）`方法，那么这个对象将会被放置在一个名为`F-Queue`队列中，并在稍后由一条由虚拟机自动建立的、低优先级的`Finalizer`线程去执行`finalize（）`方法。`finalize（）`方法是对象逃脱死亡命运的最后一次机会（因为一个对象的`finalize（）`方法最多只会被系统自动调用一次），稍后GC将对`F-Queue`中的对象进行第二次小规模的标记，如果要在`finalize（）`方法中成功拯救自己，只要在`finalize（）`方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。\n\n### 分代垃圾回收\n\n#### 新生代\n\n对象会被优先被分配到这个地方\n\n#### 老年代\n\n当对象满足一定条件之后会被放到老年代\n\n**注意**：java8之后老年代在Full GC之前是会执行一次Minor GC的，如果内存依然不足，才会执行Full GC\n\n#### 算法\n\n* 标记清除\n\n  优点：快\n\n  缺点：会出现内存碎片，导致大对象进来会直接进入老年代\n\n  ![复杂清除算法](JVM-内存管理和垃圾回收/复杂清除算法.svg)\n\n* 标记整理（老年代回收算法）\n\n  解决上面的的内存碎片问题，合并内存碎片，也就是将仍存在的对象移动到一起，比较耗时\n\n* 复制\n\n  From区和To区来实现这个算法，这两个区域分别是Survivor 0和Survivor 1\n\n  > 这也是为什么需要交换的原因，To区永远保持空白\n  \n  ![复制](JVM-内存管理和垃圾回收/复制-1585862631136.svg)","source":"_posts/JVM-内存管理和垃圾回收.md","raw":"---\ntitle: JVM-内存管理和垃圾回收\ndate: 2020-04-01 21:38:41\ntags:\n- 干货\ncategories:\n- Java\nthumbnail: ../JVM-内存管理和垃圾回收/w.png\n---\n\n## 内存管理\n\n![JVM内存管理总图w](JVM-内存管理和垃圾回收/w.png)\n\n### 方法区 （元空间/持久代）\n\n**线程共享**，存放类加载之后存放类的数据结构，静态常量，JIT(即时编译器)编译后代码也在方法区存放\n\n### 堆区\n\n**线程共享**，对象所在的区域，也是垃圾回收的主要场所\n\n### 虚拟机栈\n\n按照方法执行的顺序，先进后出\n\n#### 栈帧\n\n* 局部变量表\n* 操作数栈\n* 动态链接\n* 方法出口\n\n来看看一段简单的代码，主要分析demo()方法\n\n```java\npublic class Main {\n\n    public static void main(String[] args){\n        demo();\n    }\n\n    public static int  demo(){\n        int a = 20;\n        int b = 30;\n        int c = (a + b) * 100;\n        return c;\n    }\n}\n```\n\n这里的demo（）方法会有一个局部变量表\n\n![局部变量表 ](JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%20(1).png)\n\n赋默认值，真正使用的时候才会对其进行初始化。\n\n我们把编译好了的java文件利用javap命令对class文件进行反汇编 `javap -c Main.class`\n\n```java\nCompiled from \"Main.java\"\npublic class Main {\n  public Main();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       //后面的#加数字代表动态链接，不然程序无法准确的找到\n       // (执行静态方法#2【#2就代表一个静态方法，通过#2就可以准确找到所要执行的方法】)\n       0: invokestatic  #2                  \n       3: pop\t\t//将栈顶一个字长的数据弹出来\n       4: return\n\n  public static int demo();\n    Code:\n       0: bipush        20  //将一个8位带符号整数（20）压入栈\n       2: istore_0\t\t\t//将操作数栈中栈顶int类型的值存入局部变量0\n       3: bipush        30\t//将一个8位带符号整数（30）压入栈\n       5: istore_1\t\t\t//将操作数栈中栈顶int类型的值存入局部变量1\n       6: iload_0\t\t\t//将局部变量0中的int类型值装载到操作数栈\n       7: iload_1\t\t\t//将局部变量1中的int类型值装载到操作数栈\n       8: iadd\t\t\t\t//操作数栈中的前两个int弹出并相加，并将结果压入操作数栈顶\n       9: bipush        100\t//将一个8位带符号整数（100）压入栈\n      11: imul\t\t\t\t//操作数栈中的前两个int弹出并相乘，并将结果压入操作数栈顶\n      12: istore_2\t\t\t//将操作数栈中栈顶int类型的值存入局部变量2\n      13: iload_2\t\t\t//将局部变量2中的int类型值装载到操作数栈\n      14: ireturn\t\t\t//将操作数栈中的int值返回\n          \n      //那么前面的序号什么意思呢，这里就是程序计数器为了保证指令的正确执行所需要的序号\n}\n```\n\n从注释可以很清晰的看出来没一步都在做什么，至于JVM指令都代表什么可以看一下这个记录文档[JVM指令一览收藏](https://jontree.github.io/2020/04/03/JVM-%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95%E4%B8%80%E8%A7%88)\n\n至于动态上面的动态链接，这里重新给一个例子。\n\n```java\nclass Demo{\n\n}\n\npublic class Main {\n    public static void main(String[] args){\n        Demo demo = new Demo();\n    }\n}\n```\n\n这次我们使用输出信息更加精确的`javap -v Main.class`\n\n```java\nCompiled from \"Main.java\"\npublic class Main\n  minor version: 0\n  major version: 56\n  flags: (0x0021) ACC_PUBLIC, ACC_SUPER\n  this_class: #4                          // Main\n  super_class: #5                         // java/lang/Object\n  interfaces: 0, fields: 0, methods: 2, attributes: 1\nConstant pool://这里声明一些映射，方便下面链接\n   #1 = Methodref          #5.#21         // java/lang/Object.\"<init>\":()V\n   #2 = Class              #22            // Demo\n   #3 = Methodref          #2.#21         // Demo.\"<init>\":()V\n   #4 = Class              #23            // Main\n   #5 = Class              #24            // java/lang/Object\n   #6 = Utf8               <init>\n   #7 = Utf8               ()V\n   #8 = Utf8               Code\n   #9 = Utf8               LineNumberTable\n  #10 = Utf8               LocalVariableTable\n  #11 = Utf8               this\n  #12 = Utf8               LMain;\n  #13 = Utf8               main\n  #14 = Utf8               ([Ljava/lang/String;)V\n  #15 = Utf8               args\n  #16 = Utf8               [Ljava/lang/String;\n  #17 = Utf8               demo\n  #18 = Utf8               LDemo;\n  #19 = Utf8               SourceFile\n  #20 = Utf8               Main.java\n  #21 = NameAndType        #6:#7          // \"<init>\":()V\n  #22 = Utf8               Demo\n  #23 = Utf8               Main\n  #24 = Utf8               java/lang/Object\n{\n  public Main();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 5: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   LMain;\n\n  public static void main(java.lang.String[]);//main方法\n    descriptor: ([Ljava/lang/String;)V\n    flags: (0x0009) ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=2, args_size=1\n         //new 指令在堆中创建一个Java对象，并将该对象的地址压入操作数栈\n         0: new           #2                  // class Demo\n         //复制栈顶一个字长的数据（这里是上面创建的java对象的地址，此时操作数栈中有两个地址）\n         3: dup\n         //使用栈顶的地址调用方法并弹出栈顶\n         4: invokespecial #3                  // Method Demo.\"<init>\":()V\n         //将引用类型或returnAddress类型值存入局部变量1(这里将剩下的一份地址存到局部变量里面去了)\n         7: astore_1\n         8: return\n      LineNumberTable:\n        line 7: 0\n        line 8: 8\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       9     0  args   [Ljava/lang/String;\n            8       1     1  demo   LDemo;\n}\n```\n\n### 程序计数器\n\n当前线程执行的字节码的位置指示器\n\n### 本地方法栈 \n\n为JVM提供使用native方法的服务大致结构和虚拟机栈差不多 \n\n## 垃圾回收\n\nSTW（stop the world）：停止其他所有工作\n\nMinor GC：轻量级，耗时短，会出现STW\n\nFull GC：重量级，耗时长，会出现STW\n\n### 判断是否可回收\n\n#### 引用计数\n\n#### 根搜索算法\n\n所谓的GC根对象包括：\n\n- 虚拟机栈中引用的对象（**栈帧**中的**本地变量表**）；\n- 方法区中的**常量引用的对象**；\n- 方法区中的**类静态属性引用的对象**；\n- 本地方法栈中**JNI（Native方法）的引用对象**。\n- **活跃线程**。\n\n从根对象开始向下寻找，能够在引用链上找到这个对象就说明这个对象是可以存活的。\n\n在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：\n\n-  如果对象在进行根搜索后发现没有与`GC Roots`相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 `finalize（）`方法（可看作析构函数）。当对象没有覆盖`finalize（）`方法，或`finalize（）`方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。\n- 如果该对象被判定为有必要执行`finalize（）`方法，那么这个对象将会被放置在一个名为`F-Queue`队列中，并在稍后由一条由虚拟机自动建立的、低优先级的`Finalizer`线程去执行`finalize（）`方法。`finalize（）`方法是对象逃脱死亡命运的最后一次机会（因为一个对象的`finalize（）`方法最多只会被系统自动调用一次），稍后GC将对`F-Queue`中的对象进行第二次小规模的标记，如果要在`finalize（）`方法中成功拯救自己，只要在`finalize（）`方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。\n\n### 分代垃圾回收\n\n#### 新生代\n\n对象会被优先被分配到这个地方\n\n#### 老年代\n\n当对象满足一定条件之后会被放到老年代\n\n**注意**：java8之后老年代在Full GC之前是会执行一次Minor GC的，如果内存依然不足，才会执行Full GC\n\n#### 算法\n\n* 标记清除\n\n  优点：快\n\n  缺点：会出现内存碎片，导致大对象进来会直接进入老年代\n\n  ![复杂清除算法](JVM-内存管理和垃圾回收/复杂清除算法.svg)\n\n* 标记整理（老年代回收算法）\n\n  解决上面的的内存碎片问题，合并内存碎片，也就是将仍存在的对象移动到一起，比较耗时\n\n* 复制\n\n  From区和To区来实现这个算法，这两个区域分别是Survivor 0和Survivor 1\n\n  > 这也是为什么需要交换的原因，To区永远保持空白\n  \n  ![复制](JVM-内存管理和垃圾回收/复制-1585862631136.svg)","slug":"JVM-内存管理和垃圾回收","published":1,"updated":"2020-04-03T01:33:17.399Z","_id":"ck8jl8qhm0001w0w0d5om8qno","comments":1,"layout":"post","photos":[],"link":"2020/04/01/JVM-内存管理和垃圾回收","content":"<h2 id=\"内存管理\">内存管理<a href=\"#内存管理\" title=\"内存管理\"></a></h2><p><img src=\"/2020/04/01/JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/w.png\" class=\"φcy\" alt=\"JVM内存管理总图w\"></p>\n<h3 id=\"方法区-（元空间持久代）\">方法区 （元空间/持久代）<a href=\"#方法区-（元空间持久代）\" title=\"方法区 （元空间/持久代）\"></a></h3><p><strong>线程共享</strong>，存放类加载之后存放类的数据结构，静态常量，JIT(即时编译器)编译后代码也在方法区存放</p>\n<h3 id=\"堆区\">堆区<a href=\"#堆区\" title=\"堆区\"></a></h3><p><strong>线程共享</strong>，对象所在的区域，也是垃圾回收的主要场所</p>\n<h3 id=\"虚拟机栈\">虚拟机栈<a href=\"#虚拟机栈\" title=\"虚拟机栈\"></a></h3><p>按照方法执行的顺序，先进后出</p>\n<h4 id=\"栈帧\">栈帧<a href=\"#栈帧\" title=\"栈帧\"></a></h4><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口</li></ul><p>来看看一段简单的代码，主要分析demo()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        demo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>  <span class=\"title\">demo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">30</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = (a + b) * <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里的demo（）方法会有一个局部变量表</p>\n<p><img src=\"/2020/04/01/JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%20(1).png\" class=\"φcy\" alt=\"局部变量表 \"></p>\n<p>赋默认值，真正使用的时候才会对其进行初始化。</p>\n<p>我们把编译好了的java文件利用javap命令对class文件进行反汇编 <code>javap -c Main.class</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from <span class=\"string\">\"Main.java\"</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Main</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">       1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V</span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"comment\">//后面的#加数字代表动态链接，不然程序无法准确的找到</span></span><br><span class=\"line\">       <span class=\"comment\">// (执行静态方法#2【#2就代表一个静态方法，通过#2就可以准确找到所要执行的方法】)</span></span><br><span class=\"line\">       0: invokestatic  #2                  </span><br><span class=\"line\">       <span class=\"number\">3</span>: pop\t\t<span class=\"comment\">//将栈顶一个字长的数据弹出来</span></span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">demo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: bipush        <span class=\"number\">20</span>  <span class=\"comment\">//将一个8位带符号整数（20）压入栈</span></span><br><span class=\"line\">       <span class=\"number\">2</span>: istore_0\t\t\t<span class=\"comment\">//将操作数栈中栈顶int类型的值存入局部变量0</span></span><br><span class=\"line\">       <span class=\"number\">3</span>: bipush        <span class=\"number\">30</span>\t<span class=\"comment\">//将一个8位带符号整数（30）压入栈</span></span><br><span class=\"line\">       <span class=\"number\">5</span>: istore_1\t\t\t<span class=\"comment\">//将操作数栈中栈顶int类型的值存入局部变量1</span></span><br><span class=\"line\">       <span class=\"number\">6</span>: iload_0\t\t\t<span class=\"comment\">//将局部变量0中的int类型值装载到操作数栈</span></span><br><span class=\"line\">       <span class=\"number\">7</span>: iload_1\t\t\t<span class=\"comment\">//将局部变量1中的int类型值装载到操作数栈</span></span><br><span class=\"line\">       <span class=\"number\">8</span>: iadd\t\t\t\t<span class=\"comment\">//操作数栈中的前两个int弹出并相加，并将结果压入操作数栈顶</span></span><br><span class=\"line\">       <span class=\"number\">9</span>: bipush        <span class=\"number\">100</span>\t<span class=\"comment\">//将一个8位带符号整数（100）压入栈</span></span><br><span class=\"line\">      <span class=\"number\">11</span>: imul\t\t\t\t<span class=\"comment\">//操作数栈中的前两个int弹出并相乘，并将结果压入操作数栈顶</span></span><br><span class=\"line\">      <span class=\"number\">12</span>: istore_2\t\t\t<span class=\"comment\">//将操作数栈中栈顶int类型的值存入局部变量2</span></span><br><span class=\"line\">      <span class=\"number\">13</span>: iload_2\t\t\t<span class=\"comment\">//将局部变量2中的int类型值装载到操作数栈</span></span><br><span class=\"line\">      <span class=\"number\">14</span>: ireturn\t\t\t<span class=\"comment\">//将操作数栈中的int值返回</span></span><br><span class=\"line\">          </span><br><span class=\"line\">      <span class=\"comment\">//那么前面的序号什么意思呢，这里就是程序计数器为了保证指令的正确执行所需要的序号</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>从注释可以很清晰的看出来没一步都在做什么，至于JVM指令都代表什么可以看一下这个记录文档<a href=\"https://jontree.github.io/2020/04/03/JVM-%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95%E4%B8%80%E8%A7%88\" target=\"_blank\">JVM指令一览收藏</a></p>\n<p>至于动态上面的动态链接，这里重新给一个例子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这次我们使用输出信息更加精确的<code>javap -v Main.class</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from <span class=\"string\">\"Main.java\"</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span></span></span><br><span class=\"line\">  minor version: 0</span><br><span class=\"line\">  major version: <span class=\"number\">56</span></span><br><span class=\"line\">  flags: (<span class=\"number\">0x0021</span>) ACC_PUBLIC, ACC_SUPER</span><br><span class=\"line\">  this_class: #4                          // Main</span><br><span class=\"line\">  super_class: #5                         // java/lang/Object</span><br><span class=\"line\">  interfaces: <span class=\"number\">0</span>, fields: <span class=\"number\">0</span>, methods: <span class=\"number\">2</span>, attributes: <span class=\"number\">1</span></span><br><span class=\"line\">Constant pool:<span class=\"comment\">//这里声明一些映射，方便下面链接</span></span><br><span class=\"line\">   #1 = Methodref          #5.#21         // java/lang/Object.\"&lt;init&gt;\":()V</span><br><span class=\"line\">   #2 = Class              #22            // Demo</span><br><span class=\"line\">   #3 = Methodref          #2.#21         // Demo.\"&lt;init&gt;\":()V</span><br><span class=\"line\">   #4 = Class              #23            // Main</span><br><span class=\"line\">   #5 = Class              #24            // java/lang/Object</span><br><span class=\"line\">   #6 = Utf8               &lt;init&gt;</span><br><span class=\"line\">   #7 = Utf8               ()V</span><br><span class=\"line\">   #8 = Utf8               Code</span><br><span class=\"line\">   #9 = Utf8               LineNumberTable</span><br><span class=\"line\">  #10 = Utf8               LocalVariableTable</span><br><span class=\"line\">  #11 = Utf8               this</span><br><span class=\"line\">  #12 = Utf8               LMain;</span><br><span class=\"line\">  #13 = Utf8               main</span><br><span class=\"line\">  #14 = Utf8               ([Ljava/lang/String;)V</span><br><span class=\"line\">  #15 = Utf8               args</span><br><span class=\"line\">  #16 = Utf8               [Ljava/lang/String;</span><br><span class=\"line\">  #17 = Utf8               demo</span><br><span class=\"line\">  #18 = Utf8               LDemo;</span><br><span class=\"line\">  #19 = Utf8               SourceFile</span><br><span class=\"line\">  #20 = Utf8               Main.java</span><br><span class=\"line\">  #21 = NameAndType        #6:#7          // \"&lt;init&gt;\":()V</span><br><span class=\"line\">  #22 = Utf8               Demo</span><br><span class=\"line\">  #23 = Utf8               Main</span><br><span class=\"line\">  #24 = Utf8               java/lang/Object</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Main</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0001</span>) ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">         1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V</span><br><span class=\"line\">         <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">5</span>: <span class=\"number\">0</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">5</span>     <span class=\"number\">0</span>  <span class=\"keyword\">this</span>   LMain;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;<span class=\"comment\">//main方法</span></span><br><span class=\"line\">    descriptor: ([Ljava/lang/String;)V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">2</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"comment\">//new 指令在堆中创建一个Java对象，并将该对象的地址压入操作数栈</span></span><br><span class=\"line\">         0: new           #2                  // class Demo</span><br><span class=\"line\">         <span class=\"comment\">//复制栈顶一个字长的数据（这里是上面创建的java对象的地址，此时操作数栈中有两个地址）</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: dup</span><br><span class=\"line\">         <span class=\"comment\">//使用栈顶的地址调用方法并弹出栈顶</span></span><br><span class=\"line\">         4: invokespecial #3                  // Method Demo.\"&lt;init&gt;\":()V</span><br><span class=\"line\">         <span class=\"comment\">//将引用类型或returnAddress类型值存入局部变量1(这里将剩下的一份地址存到局部变量里面去了)</span></span><br><span class=\"line\">         <span class=\"number\">7</span>: astore_1</span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">7</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">8</span>: <span class=\"number\">8</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">9</span>     <span class=\"number\">0</span>  args   [Ljava/lang/String;</span><br><span class=\"line\">            <span class=\"number\">8</span>       <span class=\"number\">1</span>     <span class=\"number\">1</span>  demo   LDemo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"程序计数器\">程序计数器<a href=\"#程序计数器\" title=\"程序计数器\"></a></h3><p>当前线程执行的字节码的位置指示器</p>\n<h3 id=\"本地方法栈\">本地方法栈<a href=\"#本地方法栈\" title=\"本地方法栈\"></a></h3><p>为JVM提供使用native方法的服务大致结构和虚拟机栈差不多 </p>\n<h2 id=\"垃圾回收\">垃圾回收<a href=\"#垃圾回收\" title=\"垃圾回收\"></a></h2><p>STW（stop the world）：停止其他所有工作</p>\n<p>Minor GC：轻量级，耗时短，会出现STW</p>\n<p>Full GC：重量级，耗时长，会出现STW</p>\n<h3 id=\"判断是否可回收\">判断是否可回收<a href=\"#判断是否可回收\" title=\"判断是否可回收\"></a></h3><h4 id=\"引用计数\">引用计数<a href=\"#引用计数\" title=\"引用计数\"></a></h4><h4 id=\"根搜索算法\">根搜索算法<a href=\"#根搜索算法\" title=\"根搜索算法\"></a></h4><p>所谓的GC根对象包括：</p>\n<ul><li>虚拟机栈中引用的对象（<strong>栈帧</strong>中的<strong>本地变量表</strong>）；</li><li>方法区中的<strong>常量引用的对象</strong>；</li><li>方法区中的<strong>类静态属性引用的对象</strong>；</li><li>本地方法栈中<strong>JNI（Native方法）的引用对象</strong>。</li><li><strong>活跃线程</strong>。</li></ul><p>从根对象开始向下寻找，能够在引用链上找到这个对象就说明这个对象是可以存活的。</p>\n<p>在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：</p>\n<ul><li>如果对象在进行根搜索后发现没有与<code>GC Roots</code>相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 <code>finalize（）</code>方法（可看作析构函数）。当对象没有覆盖<code>finalize（）</code>方法，或<code>finalize（）</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。</li><li>如果该对象被判定为有必要执行<code>finalize（）</code>方法，那么这个对象将会被放置在一个名为<code>F-Queue</code>队列中，并在稍后由一条由虚拟机自动建立的、低优先级的<code>Finalizer</code>线程去执行<code>finalize（）</code>方法。<code>finalize（）</code>方法是对象逃脱死亡命运的最后一次机会（因为一个对象的<code>finalize（）</code>方法最多只会被系统自动调用一次），稍后GC将对<code>F-Queue</code>中的对象进行第二次小规模的标记，如果要在<code>finalize（）</code>方法中成功拯救自己，只要在<code>finalize（）</code>方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。</li></ul><h3 id=\"分代垃圾回收\">分代垃圾回收<a href=\"#分代垃圾回收\" title=\"分代垃圾回收\"></a></h3><h4 id=\"新生代\">新生代<a href=\"#新生代\" title=\"新生代\"></a></h4><p>对象会被优先被分配到这个地方</p>\n<h4 id=\"老年代\">老年代<a href=\"#老年代\" title=\"老年代\"></a></h4><p>当对象满足一定条件之后会被放到老年代</p>\n<p><strong>注意</strong>：java8之后老年代在Full GC之前是会执行一次Minor GC的，如果内存依然不足，才会执行Full GC</p>\n<h4 id=\"算法\">算法<a href=\"#算法\" title=\"算法\"></a></h4><ul><li><p>标记清除</p><p>优点：快</p><p>缺点：会出现内存碎片，导致大对象进来会直接进入老年代</p></li></ul><p><img src=\"/2020/04/01/JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/复杂清除算法.svg\" class=\"φcy\" alt=\"复杂清除算法\"></p>\n<ul><li><p>标记整理（老年代回收算法）</p><p>解决上面的的内存碎片问题，合并内存碎片，也就是将仍存在的对象移动到一起，比较耗时</p></li><li><p>复制</p><p>From区和To区来实现这个算法，这两个区域分别是Survivor 0和Survivor 1</p><blockquote><p>这也是为什么需要交换的原因，To区永远保持空白</p></blockquote></li></ul><p><img src=\"/2020/04/01/JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/复制-1585862631136.svg\" class=\"φcy\" alt=\"复制\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"内存管理\">内存管理<a href=\"#内存管理\" title=\"内存管理\"></a></h2><p><img src=\"/2020/04/01/JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/w.png\" class=\"φcy\" alt=\"JVM内存管理总图w\"></p>\n<h3 id=\"方法区-（元空间持久代）\">方法区 （元空间/持久代）<a href=\"#方法区-（元空间持久代）\" title=\"方法区 （元空间/持久代）\"></a></h3><p><strong>线程共享</strong>，存放类加载之后存放类的数据结构，静态常量，JIT(即时编译器)编译后代码也在方法区存放</p>\n<h3 id=\"堆区\">堆区<a href=\"#堆区\" title=\"堆区\"></a></h3><p><strong>线程共享</strong>，对象所在的区域，也是垃圾回收的主要场所</p>\n<h3 id=\"虚拟机栈\">虚拟机栈<a href=\"#虚拟机栈\" title=\"虚拟机栈\"></a></h3><p>按照方法执行的顺序，先进后出</p>\n<h4 id=\"栈帧\">栈帧<a href=\"#栈帧\" title=\"栈帧\"></a></h4><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口</li></ul><p>来看看一段简单的代码，主要分析demo()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        demo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>  <span class=\"title\">demo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">30</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = (a + b) * <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里的demo（）方法会有一个局部变量表</p>\n<p><img src=\"/2020/04/01/JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%20(1).png\" class=\"φcy\" alt=\"局部变量表 \"></p>\n<p>赋默认值，真正使用的时候才会对其进行初始化。</p>\n<p>我们把编译好了的java文件利用javap命令对class文件进行反汇编 <code>javap -c Main.class</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from <span class=\"string\">\"Main.java\"</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Main</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">       1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V</span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"comment\">//后面的#加数字代表动态链接，不然程序无法准确的找到</span></span><br><span class=\"line\">       <span class=\"comment\">// (执行静态方法#2【#2就代表一个静态方法，通过#2就可以准确找到所要执行的方法】)</span></span><br><span class=\"line\">       0: invokestatic  #2                  </span><br><span class=\"line\">       <span class=\"number\">3</span>: pop\t\t<span class=\"comment\">//将栈顶一个字长的数据弹出来</span></span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">demo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: bipush        <span class=\"number\">20</span>  <span class=\"comment\">//将一个8位带符号整数（20）压入栈</span></span><br><span class=\"line\">       <span class=\"number\">2</span>: istore_0\t\t\t<span class=\"comment\">//将操作数栈中栈顶int类型的值存入局部变量0</span></span><br><span class=\"line\">       <span class=\"number\">3</span>: bipush        <span class=\"number\">30</span>\t<span class=\"comment\">//将一个8位带符号整数（30）压入栈</span></span><br><span class=\"line\">       <span class=\"number\">5</span>: istore_1\t\t\t<span class=\"comment\">//将操作数栈中栈顶int类型的值存入局部变量1</span></span><br><span class=\"line\">       <span class=\"number\">6</span>: iload_0\t\t\t<span class=\"comment\">//将局部变量0中的int类型值装载到操作数栈</span></span><br><span class=\"line\">       <span class=\"number\">7</span>: iload_1\t\t\t<span class=\"comment\">//将局部变量1中的int类型值装载到操作数栈</span></span><br><span class=\"line\">       <span class=\"number\">8</span>: iadd\t\t\t\t<span class=\"comment\">//操作数栈中的前两个int弹出并相加，并将结果压入操作数栈顶</span></span><br><span class=\"line\">       <span class=\"number\">9</span>: bipush        <span class=\"number\">100</span>\t<span class=\"comment\">//将一个8位带符号整数（100）压入栈</span></span><br><span class=\"line\">      <span class=\"number\">11</span>: imul\t\t\t\t<span class=\"comment\">//操作数栈中的前两个int弹出并相乘，并将结果压入操作数栈顶</span></span><br><span class=\"line\">      <span class=\"number\">12</span>: istore_2\t\t\t<span class=\"comment\">//将操作数栈中栈顶int类型的值存入局部变量2</span></span><br><span class=\"line\">      <span class=\"number\">13</span>: iload_2\t\t\t<span class=\"comment\">//将局部变量2中的int类型值装载到操作数栈</span></span><br><span class=\"line\">      <span class=\"number\">14</span>: ireturn\t\t\t<span class=\"comment\">//将操作数栈中的int值返回</span></span><br><span class=\"line\">          </span><br><span class=\"line\">      <span class=\"comment\">//那么前面的序号什么意思呢，这里就是程序计数器为了保证指令的正确执行所需要的序号</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>从注释可以很清晰的看出来没一步都在做什么，至于JVM指令都代表什么可以看一下这个记录文档<a href=\"https://jontree.github.io/2020/04/03/JVM-%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E8%AE%B0%E5%BD%95%E4%B8%80%E8%A7%88\" target=\"_blank\">JVM指令一览收藏</a></p>\n<p>至于动态上面的动态链接，这里重新给一个例子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这次我们使用输出信息更加精确的<code>javap -v Main.class</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from <span class=\"string\">\"Main.java\"</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span></span></span><br><span class=\"line\">  minor version: 0</span><br><span class=\"line\">  major version: <span class=\"number\">56</span></span><br><span class=\"line\">  flags: (<span class=\"number\">0x0021</span>) ACC_PUBLIC, ACC_SUPER</span><br><span class=\"line\">  this_class: #4                          // Main</span><br><span class=\"line\">  super_class: #5                         // java/lang/Object</span><br><span class=\"line\">  interfaces: <span class=\"number\">0</span>, fields: <span class=\"number\">0</span>, methods: <span class=\"number\">2</span>, attributes: <span class=\"number\">1</span></span><br><span class=\"line\">Constant pool:<span class=\"comment\">//这里声明一些映射，方便下面链接</span></span><br><span class=\"line\">   #1 = Methodref          #5.#21         // java/lang/Object.\"&lt;init&gt;\":()V</span><br><span class=\"line\">   #2 = Class              #22            // Demo</span><br><span class=\"line\">   #3 = Methodref          #2.#21         // Demo.\"&lt;init&gt;\":()V</span><br><span class=\"line\">   #4 = Class              #23            // Main</span><br><span class=\"line\">   #5 = Class              #24            // java/lang/Object</span><br><span class=\"line\">   #6 = Utf8               &lt;init&gt;</span><br><span class=\"line\">   #7 = Utf8               ()V</span><br><span class=\"line\">   #8 = Utf8               Code</span><br><span class=\"line\">   #9 = Utf8               LineNumberTable</span><br><span class=\"line\">  #10 = Utf8               LocalVariableTable</span><br><span class=\"line\">  #11 = Utf8               this</span><br><span class=\"line\">  #12 = Utf8               LMain;</span><br><span class=\"line\">  #13 = Utf8               main</span><br><span class=\"line\">  #14 = Utf8               ([Ljava/lang/String;)V</span><br><span class=\"line\">  #15 = Utf8               args</span><br><span class=\"line\">  #16 = Utf8               [Ljava/lang/String;</span><br><span class=\"line\">  #17 = Utf8               demo</span><br><span class=\"line\">  #18 = Utf8               LDemo;</span><br><span class=\"line\">  #19 = Utf8               SourceFile</span><br><span class=\"line\">  #20 = Utf8               Main.java</span><br><span class=\"line\">  #21 = NameAndType        #6:#7          // \"&lt;init&gt;\":()V</span><br><span class=\"line\">  #22 = Utf8               Demo</span><br><span class=\"line\">  #23 = Utf8               Main</span><br><span class=\"line\">  #24 = Utf8               java/lang/Object</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Main</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0001</span>) ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">         1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V</span><br><span class=\"line\">         <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">5</span>: <span class=\"number\">0</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">5</span>     <span class=\"number\">0</span>  <span class=\"keyword\">this</span>   LMain;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;<span class=\"comment\">//main方法</span></span><br><span class=\"line\">    descriptor: ([Ljava/lang/String;)V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">2</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"comment\">//new 指令在堆中创建一个Java对象，并将该对象的地址压入操作数栈</span></span><br><span class=\"line\">         0: new           #2                  // class Demo</span><br><span class=\"line\">         <span class=\"comment\">//复制栈顶一个字长的数据（这里是上面创建的java对象的地址，此时操作数栈中有两个地址）</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: dup</span><br><span class=\"line\">         <span class=\"comment\">//使用栈顶的地址调用方法并弹出栈顶</span></span><br><span class=\"line\">         4: invokespecial #3                  // Method Demo.\"&lt;init&gt;\":()V</span><br><span class=\"line\">         <span class=\"comment\">//将引用类型或returnAddress类型值存入局部变量1(这里将剩下的一份地址存到局部变量里面去了)</span></span><br><span class=\"line\">         <span class=\"number\">7</span>: astore_1</span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">7</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">8</span>: <span class=\"number\">8</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">9</span>     <span class=\"number\">0</span>  args   [Ljava/lang/String;</span><br><span class=\"line\">            <span class=\"number\">8</span>       <span class=\"number\">1</span>     <span class=\"number\">1</span>  demo   LDemo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"程序计数器\">程序计数器<a href=\"#程序计数器\" title=\"程序计数器\"></a></h3><p>当前线程执行的字节码的位置指示器</p>\n<h3 id=\"本地方法栈\">本地方法栈<a href=\"#本地方法栈\" title=\"本地方法栈\"></a></h3><p>为JVM提供使用native方法的服务大致结构和虚拟机栈差不多 </p>\n<h2 id=\"垃圾回收\">垃圾回收<a href=\"#垃圾回收\" title=\"垃圾回收\"></a></h2><p>STW（stop the world）：停止其他所有工作</p>\n<p>Minor GC：轻量级，耗时短，会出现STW</p>\n<p>Full GC：重量级，耗时长，会出现STW</p>\n<h3 id=\"判断是否可回收\">判断是否可回收<a href=\"#判断是否可回收\" title=\"判断是否可回收\"></a></h3><h4 id=\"引用计数\">引用计数<a href=\"#引用计数\" title=\"引用计数\"></a></h4><h4 id=\"根搜索算法\">根搜索算法<a href=\"#根搜索算法\" title=\"根搜索算法\"></a></h4><p>所谓的GC根对象包括：</p>\n<ul><li>虚拟机栈中引用的对象（<strong>栈帧</strong>中的<strong>本地变量表</strong>）；</li><li>方法区中的<strong>常量引用的对象</strong>；</li><li>方法区中的<strong>类静态属性引用的对象</strong>；</li><li>本地方法栈中<strong>JNI（Native方法）的引用对象</strong>。</li><li><strong>活跃线程</strong>。</li></ul><p>从根对象开始向下寻找，能够在引用链上找到这个对象就说明这个对象是可以存活的。</p>\n<p>在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：</p>\n<ul><li>如果对象在进行根搜索后发现没有与<code>GC Roots</code>相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 <code>finalize（）</code>方法（可看作析构函数）。当对象没有覆盖<code>finalize（）</code>方法，或<code>finalize（）</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。</li><li>如果该对象被判定为有必要执行<code>finalize（）</code>方法，那么这个对象将会被放置在一个名为<code>F-Queue</code>队列中，并在稍后由一条由虚拟机自动建立的、低优先级的<code>Finalizer</code>线程去执行<code>finalize（）</code>方法。<code>finalize（）</code>方法是对象逃脱死亡命运的最后一次机会（因为一个对象的<code>finalize（）</code>方法最多只会被系统自动调用一次），稍后GC将对<code>F-Queue</code>中的对象进行第二次小规模的标记，如果要在<code>finalize（）</code>方法中成功拯救自己，只要在<code>finalize（）</code>方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。</li></ul><h3 id=\"分代垃圾回收\">分代垃圾回收<a href=\"#分代垃圾回收\" title=\"分代垃圾回收\"></a></h3><h4 id=\"新生代\">新生代<a href=\"#新生代\" title=\"新生代\"></a></h4><p>对象会被优先被分配到这个地方</p>\n<h4 id=\"老年代\">老年代<a href=\"#老年代\" title=\"老年代\"></a></h4><p>当对象满足一定条件之后会被放到老年代</p>\n<p><strong>注意</strong>：java8之后老年代在Full GC之前是会执行一次Minor GC的，如果内存依然不足，才会执行Full GC</p>\n<h4 id=\"算法\">算法<a href=\"#算法\" title=\"算法\"></a></h4><ul><li><p>标记清除</p><p>优点：快</p><p>缺点：会出现内存碎片，导致大对象进来会直接进入老年代</p></li></ul><p><img src=\"/2020/04/01/JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/复杂清除算法.svg\" class=\"φcy\" alt=\"复杂清除算法\"></p>\n<ul><li><p>标记整理（老年代回收算法）</p><p>解决上面的的内存碎片问题，合并内存碎片，也就是将仍存在的对象移动到一起，比较耗时</p></li><li><p>复制</p><p>From区和To区来实现这个算法，这两个区域分别是Survivor 0和Survivor 1</p><blockquote><p>这也是为什么需要交换的原因，To区永远保持空白</p></blockquote></li></ul><p><img src=\"/2020/04/01/JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/复制-1585862631136.svg\" class=\"φcy\" alt=\"复制\"></p>\n","date_formatted":{"ll":"2020年4月1日","L":"2020/04/01","MM-DD":"04-01"},"plink":"https://jonvines.github.io/2020/04/01/JVM-内存管理和垃圾回收/","type":"post","toc":[{"id":"内存管理","title":"内存管理","index":"1","children":[{"id":"方法区-（元空间持久代）","title":"方法区 （元空间&#x2F;持久代）","index":"1.1"},{"id":"堆区","title":"堆区","index":"1.2"},{"id":"虚拟机栈","title":"虚拟机栈","index":"1.3","children":[{"id":"栈帧","title":"栈帧","index":"1.3.1"}]},{"id":"程序计数器","title":"程序计数器","index":"1.4"},{"id":"本地方法栈","title":"本地方法栈","index":"1.5"}]},{"id":"垃圾回收","title":"垃圾回收","index":"2","children":[{"id":"判断是否可回收","title":"判断是否可回收","index":"2.1","children":[{"id":"引用计数","title":"引用计数","index":"2.1.1"},{"id":"根搜索算法","title":"根搜索算法","index":"2.1.2"}]},{"id":"分代垃圾回收","title":"分代垃圾回收","index":"2.2","children":[{"id":"新生代","title":"新生代","index":"2.2.1"},{"id":"老年代","title":"老年代","index":"2.2.2"},{"id":"算法","title":"算法","index":"2.2.3"}]}]}]},{"title":"JVM 操作指令记录一览","date":"2020-04-02T16:06:00.000Z","_content":"\n# 栈和局部变量操作\n\n## 将常量压入栈的指令\n\naconst_null 将null对象引用压入栈\niconst_m1 将int类型常量-1压入栈\niconst_0 将int类型常量0压入栈\niconst_1 将int类型常量1压入栈\niconst_2 将int类型常量2压入栈\niconst_3 将int类型常量3压入栈\niconst_4 将int类型常量4压入栈\niconst_5 将int类型常量5压入栈\nlconst_0 将long类型常量0压入栈\nlconst_1 将long类型常量1压入栈\nfconst_0 将float类型常量0压入栈\nfconst_1 将float类型常量1压入栈\ndconst_0 将double类型常量0压入栈\ndconst_1 将double类型常量1压入栈\nbipush 将一个8位带符号整数压入栈\nsipush 将16位带符号整数压入栈\nldc 把常量池中的项压入栈\nldc_w 把常量池中的项压入栈（使用宽索引）\nldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）\n从栈中的局部变量中装载值的指令\niload 从局部变量中装载int类型值\nlload 从局部变量中装载long类型值\nfload 从局部变量中装载float类型值\ndload 从局部变量中装载double类型值\naload 从局部变量中装载引用类型值（refernce）\niload_0 从局部变量0中装载int类型值\niload_1 从局部变量1中装载int类型值\niload_2 从局部变量2中装载int类型值\niload_3 从局部变量3中装载int类型值\nlload_0 从局部变量0中装载long类型值\nlload_1 从局部变量1中装载long类型值\nlload_2 从局部变量2中装载long类型值\nlload_3 从局部变量3中装载long类型值\nfload_0 从局部变量0中装载float类型值\nfload_1 从局部变量1中装载float类型值\nfload_2 从局部变量2中装载float类型值\nfload_3 从局部变量3中装载float类型值\ndload_0 从局部变量0中装载double类型值\ndload_1 从局部变量1中装载double类型值\ndload_2 从局部变量2中装载double类型值\ndload_3 从局部变量3中装载double类型值\naload_0 从局部变量0中装载引用类型值\naload_1 从局部变量1中装载引用类型值\naload_2 从局部变量2中装载引用类型值\naload_3 从局部变量3中装载引用类型值\niaload 从数组中装载int类型值\nlaload 从数组中装载long类型值\nfaload 从数组中装载float类型值\ndaload 从数组中装载double类型值\naaload 从数组中装载引用类型值\nbaload 从数组中装载byte类型或boolean类型值\ncaload 从数组中装载char类型值\nsaload 从数组中装载short类型值\n\n## 将操作数栈中的值存入局部变量的指令\n\nistore 将int类型值存入局部变量\nlstore 将long类型值存入局部变量\nfstore 将float类型值存入局部变量\ndstore 将double类型值存入局部变量\nastore 将将引用类型或returnAddress类型值存入局部变量\nistore_0 将int类型值存入局部变量0\nistore_1 将int类型值存入局部变量1\nistore_2 将int类型值存入局部变量2\nistore_3 将int类型值存入局部变量3\nlstore_0 将long类型值存入局部变量0\nlstore_1 将long类型值存入局部变量1\nlstore_2 将long类型值存入局部变量2\nlstore_3 将long类型值存入局部变量3\nfstore_0 将float类型值存入局部变量0\nfstore_1 将float类型值存入局部变量1\nfstore_2 将float类型值存入局部变量2\nfstore_3 将float类型值存入局部变量3\ndstore_0 将double类型值存入局部变量0\ndstore_1 将double类型值存入局部变量1\ndstore_2 将double类型值存入局部变量2\ndstore_3 将double类型值存入局部变量3\nastore_0 将引用类型或returnAddress类型值存入局部变量0\nastore_1 将引用类型或returnAddress类型值存入局部变量1\nastore_2 将引用类型或returnAddress类型值存入局部变量2\nastore_3 将引用类型或returnAddress类型值存入局部变量3\niastore 将int类型值存入数组中\nlastore 将long类型值存入数组中\nfastore 将float类型值存入数组中\ndastore 将double类型值存入数组中\naastore 将引用类型值存入数组中\nbastore 将byte类型或者boolean类型值存入数组中\ncastore 将char类型值存入数组中\nsastore 将short类型值存入数组中\n\n# wide指令\n\nwide 使用附加字节扩展局部变量索引\n\n# 通用(无类型）栈操作\n\nnop 不做任何操作\npop 弹出栈顶端一个字长的内容\npop2 弹出栈顶端两个字长的内容\ndup 复制栈顶部一个字长内容\ndup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈\ndup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈\ndup2 复制栈顶部两个字长内容\ndup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈\ndup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈\nswap 交换栈顶部两个字长内容\n\n# 类型转换\n\ni2l 把int类型的数据转化为long类型\ni2f 把int类型的数据转化为float类型\ni2d 把int类型的数据转化为double类型\nl2i 把long类型的数据转化为int类型\nl2f 把long类型的数据转化为float类型\nl2d 把long类型的数据转化为double类型\nf2i 把float类型的数据转化为int类型\nf2l 把float类型的数据转化为long类型\nf2d 把float类型的数据转化为double类型\nd2i 把double类型的数据转化为int类型\nd2l 把double类型的数据转化为long类型\nd2f 把double类型的数据转化为float类型\ni2b 把int类型的数据转化为byte类型\ni2c 把int类型的数据转化为char类型\ni2s 把int类型的数据转化为short类型\n\n# 整数运算\n\niadd 执行int类型的加法\nladd 执行long类型的加法\nisub 执行int类型的减法\nlsub 执行long类型的减法\nimul 执行int类型的乘法\nlmul 执行long类型的乘法\nidiv 执行int类型的除法\nldiv 执行long类型的除法\nirem 计算int类型除法的余数\nlrem 计算long类型除法的余数\nineg 对一个int类型值进行取反操作\nlneg 对一个long类型值进行取反操作\niinc 把一个常量值加到一个int类型的局部变量上\n\n# 逻辑运算\n\n## 移位操作\n\nishl 执行int类型的向左移位操作\nlshl 执行long类型的向左移位操作\nishr 执行int类型的向右移位操作\nlshr 执行long类型的向右移位操作\niushr 执行int类型的向右逻辑移位操作\nlushr 执行long类型的向右逻辑移位操作\n\n## 按位布尔运算\n\niand 对int类型值进行“逻辑与”操作\nland 对long类型值进行“逻辑与”操作\nior 对int类型值进行“逻辑或”操作\nlor 对long类型值进行“逻辑或”操作\nixor 对int类型值进行“逻辑异或”操作\nlxor 对long类型值进行“逻辑异或”操作\n\n## 浮点运算\n\nfadd 执行float类型的加法\ndadd 执行double类型的加法\nfsub 执行float类型的减法\ndsub 执行double类型的减法\nfmul 执行float类型的乘法\ndmul 执行double类型的乘法\nfdiv 执行float类型的除法\nddiv 执行double类型的除法\nfrem 计算float类型除法的余数\ndrem 计算double类型除法的余数\nfneg 将一个float类型的数值取反\ndneg 将一个double类型的数值取反\n\n# 对象和数组\n\n## 对象操作指令\n\nnew 创建一个新对象\ncheckcast 确定对象为所给定的类型\ngetfield 从对象中获取字段\nputfield 设置对象中字段的值\ngetstatic 从类中获取静态字段\nputstatic 设置类中静态字段的值\ninstanceof 判断对象是否为给定的类型\n\n## 数组操作指令\n\nnewarray 分配数据成员类型为基本上数据类型的新数组\nanewarray 分配数据成员类型为引用类型的新数组\narraylength 获取数组长度\nmultianewarray 分配新的多维数组\n\n# 控制流\n\n## 条件分支指令\n\nifeq 如果等于0，则跳转\nifne 如果不等于0，则跳转\niflt 如果小于0，则跳转\nifge 如果大于等于0，则跳转\nifgt 如果大于0，则跳转\nifle 如果小于等于0，则跳转\nif_icmpcq 如果两个int值相等，则跳转\nif_icmpne 如果两个int类型值不相等，则跳转\nif_icmplt 如果一个int类型值小于另外一个int类型值，则跳转\nif_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转\nif_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转\nif_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转\nifnull 如果等于null，则跳转\nifnonnull 如果不等于null，则跳转\nif_acmpeq 如果两个对象引用相等，则跳转\nif_acmpnc 如果两个对象引用不相等，则跳转\n\n## 比较指令\n\nlcmp 比较long类型值\nfcmpl 比较float类型值（当遇到NaN时，返回-1）\nfcmpg 比较float类型值（当遇到NaN时，返回1）\ndcmpl 比较double类型值（当遇到NaN时，返回-1）\ndcmpg 比较double类型值（当遇到NaN时，返回1）\n\n# 无条件转移指令\n\ngoto 无条件跳转\ngoto_w 无条件跳转（宽索引）\n\n## 表跳转指令\n\ntableswitch 通过索引访问跳转表，并跳转\nlookupswitch 通过键值匹配访问跳转表，并执行跳转操作\n\n## 异常\n\nathrow 抛出异常或错误\nfinally子句\njsr 跳转到子例程\njsr_w 跳转到子例程（宽索引）\nrct 从子例程返回\n方法调用与返回\n\n## 方法调用指令\n\ninvokcvirtual 运行时按照对象的类来调用实例方法\ninvokespecial 根据编译时类型来调用实例方法\ninvokestatic 调用类（静态）方法\ninvokcinterface 调用接口方法\n\n## 方法返回指令\n\nireturn 从方法中返回int类型的数据\nlreturn 从方法中返回long类型的数据\nfreturn 从方法中返回float类型的数据\ndreturn 从方法中返回double类型的数据\nareturn 从方法中返回引用类型的数据\nreturn 从方法中返回，返回值为void\n\n# 线程同步\n\nmontiorenter 进入并获取对象监视器\nmonitorexit 释放并退出对象监视器\n\n# JVM指令助记符\n\n变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_\n操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_\n常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_\n加：iadd,ladd,fadd,dadd\n减：isub,lsub,fsub,dsub\n乘：imul,lmul,fmul,dmul\n除：idiv,ldiv,fdiv,ddiv\n余数：irem,lrem,frem,drem\n取负：ineg,lneg,fneg,dneg\n移位：ishl,lshr,iushr,lshl,lshr,lushr\n按位或：ior,lor\n按位与：iand,land\n按位异或：ixor,lxor\n类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)\ni2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)\n创建类实便：new\n创建新数组：newarray,anewarray,multianwarray\n访问类的域和类实例域：getfield,putfield,getstatic,putstatic\n把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload\n从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore\n获取数组长度：arraylength\n检相类实例或数组属性：instanceof,checkcast\n操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap\n有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,\nif_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl\nfcmpg,dcmpl,dcmpg\n复合条件转移：tableswitch,lookupswitch\n无条件转移：goto,goto_w,jsr,jsr_w,ret\n调度对象的实便方法：invokevirtual\n调用由接口实现的方法：invokeinterface\n调用需要特殊处理的实例方法：invokespecial\n调用命名类中的静态方法：invokestatic\n方法返回：ireturn,lreturn,freturn,dreturn,areturn,return\n异常：athrow\nfinally关键字的实现使用：jsr,jsr_w,ret","source":"_posts/JVM-操作指令记录一览.md","raw":"---\ntitle: JVM 操作指令记录一览\ndate: 2020-04-03 00:06:00\ntags:\n- 备份\ncategories:\n- Java\n---\n\n# 栈和局部变量操作\n\n## 将常量压入栈的指令\n\naconst_null 将null对象引用压入栈\niconst_m1 将int类型常量-1压入栈\niconst_0 将int类型常量0压入栈\niconst_1 将int类型常量1压入栈\niconst_2 将int类型常量2压入栈\niconst_3 将int类型常量3压入栈\niconst_4 将int类型常量4压入栈\niconst_5 将int类型常量5压入栈\nlconst_0 将long类型常量0压入栈\nlconst_1 将long类型常量1压入栈\nfconst_0 将float类型常量0压入栈\nfconst_1 将float类型常量1压入栈\ndconst_0 将double类型常量0压入栈\ndconst_1 将double类型常量1压入栈\nbipush 将一个8位带符号整数压入栈\nsipush 将16位带符号整数压入栈\nldc 把常量池中的项压入栈\nldc_w 把常量池中的项压入栈（使用宽索引）\nldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）\n从栈中的局部变量中装载值的指令\niload 从局部变量中装载int类型值\nlload 从局部变量中装载long类型值\nfload 从局部变量中装载float类型值\ndload 从局部变量中装载double类型值\naload 从局部变量中装载引用类型值（refernce）\niload_0 从局部变量0中装载int类型值\niload_1 从局部变量1中装载int类型值\niload_2 从局部变量2中装载int类型值\niload_3 从局部变量3中装载int类型值\nlload_0 从局部变量0中装载long类型值\nlload_1 从局部变量1中装载long类型值\nlload_2 从局部变量2中装载long类型值\nlload_3 从局部变量3中装载long类型值\nfload_0 从局部变量0中装载float类型值\nfload_1 从局部变量1中装载float类型值\nfload_2 从局部变量2中装载float类型值\nfload_3 从局部变量3中装载float类型值\ndload_0 从局部变量0中装载double类型值\ndload_1 从局部变量1中装载double类型值\ndload_2 从局部变量2中装载double类型值\ndload_3 从局部变量3中装载double类型值\naload_0 从局部变量0中装载引用类型值\naload_1 从局部变量1中装载引用类型值\naload_2 从局部变量2中装载引用类型值\naload_3 从局部变量3中装载引用类型值\niaload 从数组中装载int类型值\nlaload 从数组中装载long类型值\nfaload 从数组中装载float类型值\ndaload 从数组中装载double类型值\naaload 从数组中装载引用类型值\nbaload 从数组中装载byte类型或boolean类型值\ncaload 从数组中装载char类型值\nsaload 从数组中装载short类型值\n\n## 将操作数栈中的值存入局部变量的指令\n\nistore 将int类型值存入局部变量\nlstore 将long类型值存入局部变量\nfstore 将float类型值存入局部变量\ndstore 将double类型值存入局部变量\nastore 将将引用类型或returnAddress类型值存入局部变量\nistore_0 将int类型值存入局部变量0\nistore_1 将int类型值存入局部变量1\nistore_2 将int类型值存入局部变量2\nistore_3 将int类型值存入局部变量3\nlstore_0 将long类型值存入局部变量0\nlstore_1 将long类型值存入局部变量1\nlstore_2 将long类型值存入局部变量2\nlstore_3 将long类型值存入局部变量3\nfstore_0 将float类型值存入局部变量0\nfstore_1 将float类型值存入局部变量1\nfstore_2 将float类型值存入局部变量2\nfstore_3 将float类型值存入局部变量3\ndstore_0 将double类型值存入局部变量0\ndstore_1 将double类型值存入局部变量1\ndstore_2 将double类型值存入局部变量2\ndstore_3 将double类型值存入局部变量3\nastore_0 将引用类型或returnAddress类型值存入局部变量0\nastore_1 将引用类型或returnAddress类型值存入局部变量1\nastore_2 将引用类型或returnAddress类型值存入局部变量2\nastore_3 将引用类型或returnAddress类型值存入局部变量3\niastore 将int类型值存入数组中\nlastore 将long类型值存入数组中\nfastore 将float类型值存入数组中\ndastore 将double类型值存入数组中\naastore 将引用类型值存入数组中\nbastore 将byte类型或者boolean类型值存入数组中\ncastore 将char类型值存入数组中\nsastore 将short类型值存入数组中\n\n# wide指令\n\nwide 使用附加字节扩展局部变量索引\n\n# 通用(无类型）栈操作\n\nnop 不做任何操作\npop 弹出栈顶端一个字长的内容\npop2 弹出栈顶端两个字长的内容\ndup 复制栈顶部一个字长内容\ndup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈\ndup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈\ndup2 复制栈顶部两个字长内容\ndup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈\ndup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈\nswap 交换栈顶部两个字长内容\n\n# 类型转换\n\ni2l 把int类型的数据转化为long类型\ni2f 把int类型的数据转化为float类型\ni2d 把int类型的数据转化为double类型\nl2i 把long类型的数据转化为int类型\nl2f 把long类型的数据转化为float类型\nl2d 把long类型的数据转化为double类型\nf2i 把float类型的数据转化为int类型\nf2l 把float类型的数据转化为long类型\nf2d 把float类型的数据转化为double类型\nd2i 把double类型的数据转化为int类型\nd2l 把double类型的数据转化为long类型\nd2f 把double类型的数据转化为float类型\ni2b 把int类型的数据转化为byte类型\ni2c 把int类型的数据转化为char类型\ni2s 把int类型的数据转化为short类型\n\n# 整数运算\n\niadd 执行int类型的加法\nladd 执行long类型的加法\nisub 执行int类型的减法\nlsub 执行long类型的减法\nimul 执行int类型的乘法\nlmul 执行long类型的乘法\nidiv 执行int类型的除法\nldiv 执行long类型的除法\nirem 计算int类型除法的余数\nlrem 计算long类型除法的余数\nineg 对一个int类型值进行取反操作\nlneg 对一个long类型值进行取反操作\niinc 把一个常量值加到一个int类型的局部变量上\n\n# 逻辑运算\n\n## 移位操作\n\nishl 执行int类型的向左移位操作\nlshl 执行long类型的向左移位操作\nishr 执行int类型的向右移位操作\nlshr 执行long类型的向右移位操作\niushr 执行int类型的向右逻辑移位操作\nlushr 执行long类型的向右逻辑移位操作\n\n## 按位布尔运算\n\niand 对int类型值进行“逻辑与”操作\nland 对long类型值进行“逻辑与”操作\nior 对int类型值进行“逻辑或”操作\nlor 对long类型值进行“逻辑或”操作\nixor 对int类型值进行“逻辑异或”操作\nlxor 对long类型值进行“逻辑异或”操作\n\n## 浮点运算\n\nfadd 执行float类型的加法\ndadd 执行double类型的加法\nfsub 执行float类型的减法\ndsub 执行double类型的减法\nfmul 执行float类型的乘法\ndmul 执行double类型的乘法\nfdiv 执行float类型的除法\nddiv 执行double类型的除法\nfrem 计算float类型除法的余数\ndrem 计算double类型除法的余数\nfneg 将一个float类型的数值取反\ndneg 将一个double类型的数值取反\n\n# 对象和数组\n\n## 对象操作指令\n\nnew 创建一个新对象\ncheckcast 确定对象为所给定的类型\ngetfield 从对象中获取字段\nputfield 设置对象中字段的值\ngetstatic 从类中获取静态字段\nputstatic 设置类中静态字段的值\ninstanceof 判断对象是否为给定的类型\n\n## 数组操作指令\n\nnewarray 分配数据成员类型为基本上数据类型的新数组\nanewarray 分配数据成员类型为引用类型的新数组\narraylength 获取数组长度\nmultianewarray 分配新的多维数组\n\n# 控制流\n\n## 条件分支指令\n\nifeq 如果等于0，则跳转\nifne 如果不等于0，则跳转\niflt 如果小于0，则跳转\nifge 如果大于等于0，则跳转\nifgt 如果大于0，则跳转\nifle 如果小于等于0，则跳转\nif_icmpcq 如果两个int值相等，则跳转\nif_icmpne 如果两个int类型值不相等，则跳转\nif_icmplt 如果一个int类型值小于另外一个int类型值，则跳转\nif_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转\nif_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转\nif_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转\nifnull 如果等于null，则跳转\nifnonnull 如果不等于null，则跳转\nif_acmpeq 如果两个对象引用相等，则跳转\nif_acmpnc 如果两个对象引用不相等，则跳转\n\n## 比较指令\n\nlcmp 比较long类型值\nfcmpl 比较float类型值（当遇到NaN时，返回-1）\nfcmpg 比较float类型值（当遇到NaN时，返回1）\ndcmpl 比较double类型值（当遇到NaN时，返回-1）\ndcmpg 比较double类型值（当遇到NaN时，返回1）\n\n# 无条件转移指令\n\ngoto 无条件跳转\ngoto_w 无条件跳转（宽索引）\n\n## 表跳转指令\n\ntableswitch 通过索引访问跳转表，并跳转\nlookupswitch 通过键值匹配访问跳转表，并执行跳转操作\n\n## 异常\n\nathrow 抛出异常或错误\nfinally子句\njsr 跳转到子例程\njsr_w 跳转到子例程（宽索引）\nrct 从子例程返回\n方法调用与返回\n\n## 方法调用指令\n\ninvokcvirtual 运行时按照对象的类来调用实例方法\ninvokespecial 根据编译时类型来调用实例方法\ninvokestatic 调用类（静态）方法\ninvokcinterface 调用接口方法\n\n## 方法返回指令\n\nireturn 从方法中返回int类型的数据\nlreturn 从方法中返回long类型的数据\nfreturn 从方法中返回float类型的数据\ndreturn 从方法中返回double类型的数据\nareturn 从方法中返回引用类型的数据\nreturn 从方法中返回，返回值为void\n\n# 线程同步\n\nmontiorenter 进入并获取对象监视器\nmonitorexit 释放并退出对象监视器\n\n# JVM指令助记符\n\n变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_\n操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_\n常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_\n加：iadd,ladd,fadd,dadd\n减：isub,lsub,fsub,dsub\n乘：imul,lmul,fmul,dmul\n除：idiv,ldiv,fdiv,ddiv\n余数：irem,lrem,frem,drem\n取负：ineg,lneg,fneg,dneg\n移位：ishl,lshr,iushr,lshl,lshr,lushr\n按位或：ior,lor\n按位与：iand,land\n按位异或：ixor,lxor\n类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)\ni2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)\n创建类实便：new\n创建新数组：newarray,anewarray,multianwarray\n访问类的域和类实例域：getfield,putfield,getstatic,putstatic\n把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload\n从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore\n获取数组长度：arraylength\n检相类实例或数组属性：instanceof,checkcast\n操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap\n有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,\nif_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl\nfcmpg,dcmpl,dcmpg\n复合条件转移：tableswitch,lookupswitch\n无条件转移：goto,goto_w,jsr,jsr_w,ret\n调度对象的实便方法：invokevirtual\n调用由接口实现的方法：invokeinterface\n调用需要特殊处理的实例方法：invokespecial\n调用命名类中的静态方法：invokestatic\n方法返回：ireturn,lreturn,freturn,dreturn,areturn,return\n异常：athrow\nfinally关键字的实现使用：jsr,jsr_w,ret","slug":"JVM-操作指令记录一览","published":1,"updated":"2020-04-02T17:02:21.166Z","comments":1,"layout":"post","photos":[],"link":"2020/04/03/JVM-操作指令记录一览","_id":"ck8jl8qhs0004w0w01xpq3n89","content":"<h1 id=\"栈和局部变量操作\">栈和局部变量操作<a href=\"#栈和局部变量操作\" title=\"栈和局部变量操作\"></a></h1><h2 id=\"将常量压入栈的指令\">将常量压入栈的指令<a href=\"#将常量压入栈的指令\" title=\"将常量压入栈的指令\"></a></h2><p>aconst_null 将null对象引用压入栈<br>iconst_m1 将int类型常量-1压入栈<br>iconst_0 将int类型常量0压入栈<br>iconst_1 将int类型常量1压入栈<br>iconst_2 将int类型常量2压入栈<br>iconst_3 将int类型常量3压入栈<br>iconst_4 将int类型常量4压入栈<br>iconst_5 将int类型常量5压入栈<br>lconst_0 将long类型常量0压入栈<br>lconst_1 将long类型常量1压入栈<br>fconst_0 将float类型常量0压入栈<br>fconst_1 将float类型常量1压入栈<br>dconst_0 将double类型常量0压入栈<br>dconst_1 将double类型常量1压入栈<br>bipush 将一个8位带符号整数压入栈<br>sipush 将16位带符号整数压入栈<br>ldc 把常量池中的项压入栈<br>ldc_w 把常量池中的项压入栈（使用宽索引）<br>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）<br>从栈中的局部变量中装载值的指令<br>iload 从局部变量中装载int类型值<br>lload 从局部变量中装载long类型值<br>fload 从局部变量中装载float类型值<br>dload 从局部变量中装载double类型值<br>aload 从局部变量中装载引用类型值（refernce）<br>iload_0 从局部变量0中装载int类型值<br>iload_1 从局部变量1中装载int类型值<br>iload_2 从局部变量2中装载int类型值<br>iload_3 从局部变量3中装载int类型值<br>lload_0 从局部变量0中装载long类型值<br>lload_1 从局部变量1中装载long类型值<br>lload_2 从局部变量2中装载long类型值<br>lload_3 从局部变量3中装载long类型值<br>fload_0 从局部变量0中装载float类型值<br>fload_1 从局部变量1中装载float类型值<br>fload_2 从局部变量2中装载float类型值<br>fload_3 从局部变量3中装载float类型值<br>dload_0 从局部变量0中装载double类型值<br>dload_1 从局部变量1中装载double类型值<br>dload_2 从局部变量2中装载double类型值<br>dload_3 从局部变量3中装载double类型值<br>aload_0 从局部变量0中装载引用类型值<br>aload_1 从局部变量1中装载引用类型值<br>aload_2 从局部变量2中装载引用类型值<br>aload_3 从局部变量3中装载引用类型值<br>iaload 从数组中装载int类型值<br>laload 从数组中装载long类型值<br>faload 从数组中装载float类型值<br>daload 从数组中装载double类型值<br>aaload 从数组中装载引用类型值<br>baload 从数组中装载byte类型或boolean类型值<br>caload 从数组中装载char类型值<br>saload 从数组中装载short类型值</p>\n<h2 id=\"将操作数栈中的值存入局部变量的指令\">将操作数栈中的值存入局部变量的指令<a href=\"#将操作数栈中的值存入局部变量的指令\" title=\"将操作数栈中的值存入局部变量的指令\"></a></h2><p>istore 将int类型值存入局部变量<br>lstore 将long类型值存入局部变量<br>fstore 将float类型值存入局部变量<br>dstore 将double类型值存入局部变量<br>astore 将将引用类型或returnAddress类型值存入局部变量<br>istore_0 将int类型值存入局部变量0<br>istore_1 将int类型值存入局部变量1<br>istore_2 将int类型值存入局部变量2<br>istore_3 将int类型值存入局部变量3<br>lstore_0 将long类型值存入局部变量0<br>lstore_1 将long类型值存入局部变量1<br>lstore_2 将long类型值存入局部变量2<br>lstore_3 将long类型值存入局部变量3<br>fstore_0 将float类型值存入局部变量0<br>fstore_1 将float类型值存入局部变量1<br>fstore_2 将float类型值存入局部变量2<br>fstore_3 将float类型值存入局部变量3<br>dstore_0 将double类型值存入局部变量0<br>dstore_1 将double类型值存入局部变量1<br>dstore_2 将double类型值存入局部变量2<br>dstore_3 将double类型值存入局部变量3<br>astore_0 将引用类型或returnAddress类型值存入局部变量0<br>astore_1 将引用类型或returnAddress类型值存入局部变量1<br>astore_2 将引用类型或returnAddress类型值存入局部变量2<br>astore_3 将引用类型或returnAddress类型值存入局部变量3<br>iastore 将int类型值存入数组中<br>lastore 将long类型值存入数组中<br>fastore 将float类型值存入数组中<br>dastore 将double类型值存入数组中<br>aastore 将引用类型值存入数组中<br>bastore 将byte类型或者boolean类型值存入数组中<br>castore 将char类型值存入数组中<br>sastore 将short类型值存入数组中</p>\n<h1 id=\"wide指令\">wide指令<a href=\"#wide指令\" title=\"wide指令\"></a></h1><p>wide 使用附加字节扩展局部变量索引</p>\n<h1 id=\"通用无类型）栈操作\">通用(无类型）栈操作<a href=\"#通用无类型）栈操作\" title=\"通用(无类型）栈操作\"></a></h1><p>nop 不做任何操作<br>pop 弹出栈顶端一个字长的内容<br>pop2 弹出栈顶端两个字长的内容<br>dup 复制栈顶部一个字长内容<br>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈<br>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2 复制栈顶部两个字长内容<br>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈<br>swap 交换栈顶部两个字长内容</p>\n<h1 id=\"类型转换\">类型转换<a href=\"#类型转换\" title=\"类型转换\"></a></h1><p>i2l 把int类型的数据转化为long类型<br>i2f 把int类型的数据转化为float类型<br>i2d 把int类型的数据转化为double类型<br>l2i 把long类型的数据转化为int类型<br>l2f 把long类型的数据转化为float类型<br>l2d 把long类型的数据转化为double类型<br>f2i 把float类型的数据转化为int类型<br>f2l 把float类型的数据转化为long类型<br>f2d 把float类型的数据转化为double类型<br>d2i 把double类型的数据转化为int类型<br>d2l 把double类型的数据转化为long类型<br>d2f 把double类型的数据转化为float类型<br>i2b 把int类型的数据转化为byte类型<br>i2c 把int类型的数据转化为char类型<br>i2s 把int类型的数据转化为short类型</p>\n<h1 id=\"整数运算\">整数运算<a href=\"#整数运算\" title=\"整数运算\"></a></h1><p>iadd 执行int类型的加法<br>ladd 执行long类型的加法<br>isub 执行int类型的减法<br>lsub 执行long类型的减法<br>imul 执行int类型的乘法<br>lmul 执行long类型的乘法<br>idiv 执行int类型的除法<br>ldiv 执行long类型的除法<br>irem 计算int类型除法的余数<br>lrem 计算long类型除法的余数<br>ineg 对一个int类型值进行取反操作<br>lneg 对一个long类型值进行取反操作<br>iinc 把一个常量值加到一个int类型的局部变量上</p>\n<h1 id=\"逻辑运算\">逻辑运算<a href=\"#逻辑运算\" title=\"逻辑运算\"></a></h1><h2 id=\"移位操作\">移位操作<a href=\"#移位操作\" title=\"移位操作\"></a></h2><p>ishl 执行int类型的向左移位操作<br>lshl 执行long类型的向左移位操作<br>ishr 执行int类型的向右移位操作<br>lshr 执行long类型的向右移位操作<br>iushr 执行int类型的向右逻辑移位操作<br>lushr 执行long类型的向右逻辑移位操作</p>\n<h2 id=\"按位布尔运算\">按位布尔运算<a href=\"#按位布尔运算\" title=\"按位布尔运算\"></a></h2><p>iand 对int类型值进行“逻辑与”操作<br>land 对long类型值进行“逻辑与”操作<br>ior 对int类型值进行“逻辑或”操作<br>lor 对long类型值进行“逻辑或”操作<br>ixor 对int类型值进行“逻辑异或”操作<br>lxor 对long类型值进行“逻辑异或”操作</p>\n<h2 id=\"浮点运算\">浮点运算<a href=\"#浮点运算\" title=\"浮点运算\"></a></h2><p>fadd 执行float类型的加法<br>dadd 执行double类型的加法<br>fsub 执行float类型的减法<br>dsub 执行double类型的减法<br>fmul 执行float类型的乘法<br>dmul 执行double类型的乘法<br>fdiv 执行float类型的除法<br>ddiv 执行double类型的除法<br>frem 计算float类型除法的余数<br>drem 计算double类型除法的余数<br>fneg 将一个float类型的数值取反<br>dneg 将一个double类型的数值取反</p>\n<h1 id=\"对象和数组\">对象和数组<a href=\"#对象和数组\" title=\"对象和数组\"></a></h1><h2 id=\"对象操作指令\">对象操作指令<a href=\"#对象操作指令\" title=\"对象操作指令\"></a></h2><p>new 创建一个新对象<br>checkcast 确定对象为所给定的类型<br>getfield 从对象中获取字段<br>putfield 设置对象中字段的值<br>getstatic 从类中获取静态字段<br>putstatic 设置类中静态字段的值<br>instanceof 判断对象是否为给定的类型</p>\n<h2 id=\"数组操作指令\">数组操作指令<a href=\"#数组操作指令\" title=\"数组操作指令\"></a></h2><p>newarray 分配数据成员类型为基本上数据类型的新数组<br>anewarray 分配数据成员类型为引用类型的新数组<br>arraylength 获取数组长度<br>multianewarray 分配新的多维数组</p>\n<h1 id=\"控制流\">控制流<a href=\"#控制流\" title=\"控制流\"></a></h1><h2 id=\"条件分支指令\">条件分支指令<a href=\"#条件分支指令\" title=\"条件分支指令\"></a></h2><p>ifeq 如果等于0，则跳转<br>ifne 如果不等于0，则跳转<br>iflt 如果小于0，则跳转<br>ifge 如果大于等于0，则跳转<br>ifgt 如果大于0，则跳转<br>ifle 如果小于等于0，则跳转<br>if_icmpcq 如果两个int值相等，则跳转<br>if_icmpne 如果两个int类型值不相等，则跳转<br>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转<br>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转<br>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转<br>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转<br>ifnull 如果等于null，则跳转<br>ifnonnull 如果不等于null，则跳转<br>if_acmpeq 如果两个对象引用相等，则跳转<br>if_acmpnc 如果两个对象引用不相等，则跳转</p>\n<h2 id=\"比较指令\">比较指令<a href=\"#比较指令\" title=\"比较指令\"></a></h2><p>lcmp 比较long类型值<br>fcmpl 比较float类型值（当遇到NaN时，返回-1）<br>fcmpg 比较float类型值（当遇到NaN时，返回1）<br>dcmpl 比较double类型值（当遇到NaN时，返回-1）<br>dcmpg 比较double类型值（当遇到NaN时，返回1）</p>\n<h1 id=\"无条件转移指令\">无条件转移指令<a href=\"#无条件转移指令\" title=\"无条件转移指令\"></a></h1><p>goto 无条件跳转<br>goto_w 无条件跳转（宽索引）</p>\n<h2 id=\"表跳转指令\">表跳转指令<a href=\"#表跳转指令\" title=\"表跳转指令\"></a></h2><p>tableswitch 通过索引访问跳转表，并跳转<br>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作</p>\n<h2 id=\"异常\">异常<a href=\"#异常\" title=\"异常\"></a></h2><p>athrow 抛出异常或错误<br>finally子句<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>rct 从子例程返回<br>方法调用与返回</p>\n<h2 id=\"方法调用指令\">方法调用指令<a href=\"#方法调用指令\" title=\"方法调用指令\"></a></h2><p>invokcvirtual 运行时按照对象的类来调用实例方法<br>invokespecial 根据编译时类型来调用实例方法<br>invokestatic 调用类（静态）方法<br>invokcinterface 调用接口方法</p>\n<h2 id=\"方法返回指令\">方法返回指令<a href=\"#方法返回指令\" title=\"方法返回指令\"></a></h2><p>ireturn 从方法中返回int类型的数据<br>lreturn 从方法中返回long类型的数据<br>freturn 从方法中返回float类型的数据<br>dreturn 从方法中返回double类型的数据<br>areturn 从方法中返回引用类型的数据<br>return 从方法中返回，返回值为void</p>\n<h1 id=\"线程同步\">线程同步<a href=\"#线程同步\" title=\"线程同步\"></a></h1><p>montiorenter 进入并获取对象监视器<br>monitorexit 释放并退出对象监视器</p>\n<h1 id=\"jvm指令助记符\">JVM指令助记符<a href=\"#jvm指令助记符\" title=\"JVM指令助记符\"></a></h1><p>变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_<br>操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_<br>常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_<br>加：iadd,ladd,fadd,dadd<br>减：isub,lsub,fsub,dsub<br>乘：imul,lmul,fmul,dmul<br>除：idiv,ldiv,fdiv,ddiv<br>余数：irem,lrem,frem,drem<br>取负：ineg,lneg,fneg,dneg<br>移位：ishl,lshr,iushr,lshl,lshr,lushr<br>按位或：ior,lor<br>按位与：iand,land<br>按位异或：ixor,lxor<br>类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)<br>i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)<br>创建类实便：new<br>创建新数组：newarray,anewarray,multianwarray<br>访问类的域和类实例域：getfield,putfield,getstatic,putstatic<br>把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload<br>从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore<br>获取数组长度：arraylength<br>检相类实例或数组属性：instanceof,checkcast<br>操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap<br>有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,<br>if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl<br>fcmpg,dcmpl,dcmpg<br>复合条件转移：tableswitch,lookupswitch<br>无条件转移：goto,goto_w,jsr,jsr_w,ret<br>调度对象的实便方法：invokevirtual<br>调用由接口实现的方法：invokeinterface<br>调用需要特殊处理的实例方法：invokespecial<br>调用命名类中的静态方法：invokestatic<br>方法返回：ireturn,lreturn,freturn,dreturn,areturn,return<br>异常：athrow<br>finally关键字的实现使用：jsr,jsr_w,ret</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"栈和局部变量操作\">栈和局部变量操作<a href=\"#栈和局部变量操作\" title=\"栈和局部变量操作\"></a></h1><h2 id=\"将常量压入栈的指令\">将常量压入栈的指令<a href=\"#将常量压入栈的指令\" title=\"将常量压入栈的指令\"></a></h2><p>aconst_null 将null对象引用压入栈<br>iconst_m1 将int类型常量-1压入栈<br>iconst_0 将int类型常量0压入栈<br>iconst_1 将int类型常量1压入栈<br>iconst_2 将int类型常量2压入栈<br>iconst_3 将int类型常量3压入栈<br>iconst_4 将int类型常量4压入栈<br>iconst_5 将int类型常量5压入栈<br>lconst_0 将long类型常量0压入栈<br>lconst_1 将long类型常量1压入栈<br>fconst_0 将float类型常量0压入栈<br>fconst_1 将float类型常量1压入栈<br>dconst_0 将double类型常量0压入栈<br>dconst_1 将double类型常量1压入栈<br>bipush 将一个8位带符号整数压入栈<br>sipush 将16位带符号整数压入栈<br>ldc 把常量池中的项压入栈<br>ldc_w 把常量池中的项压入栈（使用宽索引）<br>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）<br>从栈中的局部变量中装载值的指令<br>iload 从局部变量中装载int类型值<br>lload 从局部变量中装载long类型值<br>fload 从局部变量中装载float类型值<br>dload 从局部变量中装载double类型值<br>aload 从局部变量中装载引用类型值（refernce）<br>iload_0 从局部变量0中装载int类型值<br>iload_1 从局部变量1中装载int类型值<br>iload_2 从局部变量2中装载int类型值<br>iload_3 从局部变量3中装载int类型值<br>lload_0 从局部变量0中装载long类型值<br>lload_1 从局部变量1中装载long类型值<br>lload_2 从局部变量2中装载long类型值<br>lload_3 从局部变量3中装载long类型值<br>fload_0 从局部变量0中装载float类型值<br>fload_1 从局部变量1中装载float类型值<br>fload_2 从局部变量2中装载float类型值<br>fload_3 从局部变量3中装载float类型值<br>dload_0 从局部变量0中装载double类型值<br>dload_1 从局部变量1中装载double类型值<br>dload_2 从局部变量2中装载double类型值<br>dload_3 从局部变量3中装载double类型值<br>aload_0 从局部变量0中装载引用类型值<br>aload_1 从局部变量1中装载引用类型值<br>aload_2 从局部变量2中装载引用类型值<br>aload_3 从局部变量3中装载引用类型值<br>iaload 从数组中装载int类型值<br>laload 从数组中装载long类型值<br>faload 从数组中装载float类型值<br>daload 从数组中装载double类型值<br>aaload 从数组中装载引用类型值<br>baload 从数组中装载byte类型或boolean类型值<br>caload 从数组中装载char类型值<br>saload 从数组中装载short类型值</p>\n<h2 id=\"将操作数栈中的值存入局部变量的指令\">将操作数栈中的值存入局部变量的指令<a href=\"#将操作数栈中的值存入局部变量的指令\" title=\"将操作数栈中的值存入局部变量的指令\"></a></h2><p>istore 将int类型值存入局部变量<br>lstore 将long类型值存入局部变量<br>fstore 将float类型值存入局部变量<br>dstore 将double类型值存入局部变量<br>astore 将将引用类型或returnAddress类型值存入局部变量<br>istore_0 将int类型值存入局部变量0<br>istore_1 将int类型值存入局部变量1<br>istore_2 将int类型值存入局部变量2<br>istore_3 将int类型值存入局部变量3<br>lstore_0 将long类型值存入局部变量0<br>lstore_1 将long类型值存入局部变量1<br>lstore_2 将long类型值存入局部变量2<br>lstore_3 将long类型值存入局部变量3<br>fstore_0 将float类型值存入局部变量0<br>fstore_1 将float类型值存入局部变量1<br>fstore_2 将float类型值存入局部变量2<br>fstore_3 将float类型值存入局部变量3<br>dstore_0 将double类型值存入局部变量0<br>dstore_1 将double类型值存入局部变量1<br>dstore_2 将double类型值存入局部变量2<br>dstore_3 将double类型值存入局部变量3<br>astore_0 将引用类型或returnAddress类型值存入局部变量0<br>astore_1 将引用类型或returnAddress类型值存入局部变量1<br>astore_2 将引用类型或returnAddress类型值存入局部变量2<br>astore_3 将引用类型或returnAddress类型值存入局部变量3<br>iastore 将int类型值存入数组中<br>lastore 将long类型值存入数组中<br>fastore 将float类型值存入数组中<br>dastore 将double类型值存入数组中<br>aastore 将引用类型值存入数组中<br>bastore 将byte类型或者boolean类型值存入数组中<br>castore 将char类型值存入数组中<br>sastore 将short类型值存入数组中</p>\n<h1 id=\"wide指令\">wide指令<a href=\"#wide指令\" title=\"wide指令\"></a></h1><p>wide 使用附加字节扩展局部变量索引</p>\n<h1 id=\"通用无类型）栈操作\">通用(无类型）栈操作<a href=\"#通用无类型）栈操作\" title=\"通用(无类型）栈操作\"></a></h1><p>nop 不做任何操作<br>pop 弹出栈顶端一个字长的内容<br>pop2 弹出栈顶端两个字长的内容<br>dup 复制栈顶部一个字长内容<br>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈<br>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2 复制栈顶部两个字长内容<br>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈<br>swap 交换栈顶部两个字长内容</p>\n<h1 id=\"类型转换\">类型转换<a href=\"#类型转换\" title=\"类型转换\"></a></h1><p>i2l 把int类型的数据转化为long类型<br>i2f 把int类型的数据转化为float类型<br>i2d 把int类型的数据转化为double类型<br>l2i 把long类型的数据转化为int类型<br>l2f 把long类型的数据转化为float类型<br>l2d 把long类型的数据转化为double类型<br>f2i 把float类型的数据转化为int类型<br>f2l 把float类型的数据转化为long类型<br>f2d 把float类型的数据转化为double类型<br>d2i 把double类型的数据转化为int类型<br>d2l 把double类型的数据转化为long类型<br>d2f 把double类型的数据转化为float类型<br>i2b 把int类型的数据转化为byte类型<br>i2c 把int类型的数据转化为char类型<br>i2s 把int类型的数据转化为short类型</p>\n<h1 id=\"整数运算\">整数运算<a href=\"#整数运算\" title=\"整数运算\"></a></h1><p>iadd 执行int类型的加法<br>ladd 执行long类型的加法<br>isub 执行int类型的减法<br>lsub 执行long类型的减法<br>imul 执行int类型的乘法<br>lmul 执行long类型的乘法<br>idiv 执行int类型的除法<br>ldiv 执行long类型的除法<br>irem 计算int类型除法的余数<br>lrem 计算long类型除法的余数<br>ineg 对一个int类型值进行取反操作<br>lneg 对一个long类型值进行取反操作<br>iinc 把一个常量值加到一个int类型的局部变量上</p>\n<h1 id=\"逻辑运算\">逻辑运算<a href=\"#逻辑运算\" title=\"逻辑运算\"></a></h1><h2 id=\"移位操作\">移位操作<a href=\"#移位操作\" title=\"移位操作\"></a></h2><p>ishl 执行int类型的向左移位操作<br>lshl 执行long类型的向左移位操作<br>ishr 执行int类型的向右移位操作<br>lshr 执行long类型的向右移位操作<br>iushr 执行int类型的向右逻辑移位操作<br>lushr 执行long类型的向右逻辑移位操作</p>\n<h2 id=\"按位布尔运算\">按位布尔运算<a href=\"#按位布尔运算\" title=\"按位布尔运算\"></a></h2><p>iand 对int类型值进行“逻辑与”操作<br>land 对long类型值进行“逻辑与”操作<br>ior 对int类型值进行“逻辑或”操作<br>lor 对long类型值进行“逻辑或”操作<br>ixor 对int类型值进行“逻辑异或”操作<br>lxor 对long类型值进行“逻辑异或”操作</p>\n<h2 id=\"浮点运算\">浮点运算<a href=\"#浮点运算\" title=\"浮点运算\"></a></h2><p>fadd 执行float类型的加法<br>dadd 执行double类型的加法<br>fsub 执行float类型的减法<br>dsub 执行double类型的减法<br>fmul 执行float类型的乘法<br>dmul 执行double类型的乘法<br>fdiv 执行float类型的除法<br>ddiv 执行double类型的除法<br>frem 计算float类型除法的余数<br>drem 计算double类型除法的余数<br>fneg 将一个float类型的数值取反<br>dneg 将一个double类型的数值取反</p>\n<h1 id=\"对象和数组\">对象和数组<a href=\"#对象和数组\" title=\"对象和数组\"></a></h1><h2 id=\"对象操作指令\">对象操作指令<a href=\"#对象操作指令\" title=\"对象操作指令\"></a></h2><p>new 创建一个新对象<br>checkcast 确定对象为所给定的类型<br>getfield 从对象中获取字段<br>putfield 设置对象中字段的值<br>getstatic 从类中获取静态字段<br>putstatic 设置类中静态字段的值<br>instanceof 判断对象是否为给定的类型</p>\n<h2 id=\"数组操作指令\">数组操作指令<a href=\"#数组操作指令\" title=\"数组操作指令\"></a></h2><p>newarray 分配数据成员类型为基本上数据类型的新数组<br>anewarray 分配数据成员类型为引用类型的新数组<br>arraylength 获取数组长度<br>multianewarray 分配新的多维数组</p>\n<h1 id=\"控制流\">控制流<a href=\"#控制流\" title=\"控制流\"></a></h1><h2 id=\"条件分支指令\">条件分支指令<a href=\"#条件分支指令\" title=\"条件分支指令\"></a></h2><p>ifeq 如果等于0，则跳转<br>ifne 如果不等于0，则跳转<br>iflt 如果小于0，则跳转<br>ifge 如果大于等于0，则跳转<br>ifgt 如果大于0，则跳转<br>ifle 如果小于等于0，则跳转<br>if_icmpcq 如果两个int值相等，则跳转<br>if_icmpne 如果两个int类型值不相等，则跳转<br>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转<br>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转<br>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转<br>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转<br>ifnull 如果等于null，则跳转<br>ifnonnull 如果不等于null，则跳转<br>if_acmpeq 如果两个对象引用相等，则跳转<br>if_acmpnc 如果两个对象引用不相等，则跳转</p>\n<h2 id=\"比较指令\">比较指令<a href=\"#比较指令\" title=\"比较指令\"></a></h2><p>lcmp 比较long类型值<br>fcmpl 比较float类型值（当遇到NaN时，返回-1）<br>fcmpg 比较float类型值（当遇到NaN时，返回1）<br>dcmpl 比较double类型值（当遇到NaN时，返回-1）<br>dcmpg 比较double类型值（当遇到NaN时，返回1）</p>\n<h1 id=\"无条件转移指令\">无条件转移指令<a href=\"#无条件转移指令\" title=\"无条件转移指令\"></a></h1><p>goto 无条件跳转<br>goto_w 无条件跳转（宽索引）</p>\n<h2 id=\"表跳转指令\">表跳转指令<a href=\"#表跳转指令\" title=\"表跳转指令\"></a></h2><p>tableswitch 通过索引访问跳转表，并跳转<br>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作</p>\n<h2 id=\"异常\">异常<a href=\"#异常\" title=\"异常\"></a></h2><p>athrow 抛出异常或错误<br>finally子句<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>rct 从子例程返回<br>方法调用与返回</p>\n<h2 id=\"方法调用指令\">方法调用指令<a href=\"#方法调用指令\" title=\"方法调用指令\"></a></h2><p>invokcvirtual 运行时按照对象的类来调用实例方法<br>invokespecial 根据编译时类型来调用实例方法<br>invokestatic 调用类（静态）方法<br>invokcinterface 调用接口方法</p>\n<h2 id=\"方法返回指令\">方法返回指令<a href=\"#方法返回指令\" title=\"方法返回指令\"></a></h2><p>ireturn 从方法中返回int类型的数据<br>lreturn 从方法中返回long类型的数据<br>freturn 从方法中返回float类型的数据<br>dreturn 从方法中返回double类型的数据<br>areturn 从方法中返回引用类型的数据<br>return 从方法中返回，返回值为void</p>\n<h1 id=\"线程同步\">线程同步<a href=\"#线程同步\" title=\"线程同步\"></a></h1><p>montiorenter 进入并获取对象监视器<br>monitorexit 释放并退出对象监视器</p>\n<h1 id=\"jvm指令助记符\">JVM指令助记符<a href=\"#jvm指令助记符\" title=\"JVM指令助记符\"></a></h1><p>变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_<br>操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_<br>常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_<br>加：iadd,ladd,fadd,dadd<br>减：isub,lsub,fsub,dsub<br>乘：imul,lmul,fmul,dmul<br>除：idiv,ldiv,fdiv,ddiv<br>余数：irem,lrem,frem,drem<br>取负：ineg,lneg,fneg,dneg<br>移位：ishl,lshr,iushr,lshl,lshr,lushr<br>按位或：ior,lor<br>按位与：iand,land<br>按位异或：ixor,lxor<br>类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)<br>i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)<br>创建类实便：new<br>创建新数组：newarray,anewarray,multianwarray<br>访问类的域和类实例域：getfield,putfield,getstatic,putstatic<br>把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload<br>从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore<br>获取数组长度：arraylength<br>检相类实例或数组属性：instanceof,checkcast<br>操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap<br>有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,<br>if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl<br>fcmpg,dcmpl,dcmpg<br>复合条件转移：tableswitch,lookupswitch<br>无条件转移：goto,goto_w,jsr,jsr_w,ret<br>调度对象的实便方法：invokevirtual<br>调用由接口实现的方法：invokeinterface<br>调用需要特殊处理的实例方法：invokespecial<br>调用命名类中的静态方法：invokestatic<br>方法返回：ireturn,lreturn,freturn,dreturn,areturn,return<br>异常：athrow<br>finally关键字的实现使用：jsr,jsr_w,ret</p>\n","date_formatted":{"ll":"Apr 3, 2020","L":"04/03/2020","MM-DD":"04-03"},"plink":"https://treeeeeeee.github.io/2020/04/03/JVM-操作指令记录一览/","type":"post","toc":[{"id":"栈和局部变量操作","title":"栈和局部变量操作","index":"1","children":[{"id":"将常量压入栈的指令","title":"将常量压入栈的指令","index":"1.1"},{"id":"将操作数栈中的值存入局部变量的指令","title":"将操作数栈中的值存入局部变量的指令","index":"1.2"}]},{"id":"wide指令","title":"wide指令","index":"2"},{"id":"通用无类型）栈操作","title":"通用(无类型）栈操作","index":"3"},{"id":"类型转换","title":"类型转换","index":"4"},{"id":"整数运算","title":"整数运算","index":"5"},{"id":"逻辑运算","title":"逻辑运算","index":"6","children":[{"id":"移位操作","title":"移位操作","index":"6.1"},{"id":"按位布尔运算","title":"按位布尔运算","index":"6.2"},{"id":"浮点运算","title":"浮点运算","index":"6.3"}]},{"id":"对象和数组","title":"对象和数组","index":"7","children":[{"id":"对象操作指令","title":"对象操作指令","index":"7.1"},{"id":"数组操作指令","title":"数组操作指令","index":"7.2"}]},{"id":"控制流","title":"控制流","index":"8","children":[{"id":"条件分支指令","title":"条件分支指令","index":"8.1"},{"id":"比较指令","title":"比较指令","index":"8.2"}]},{"id":"无条件转移指令","title":"无条件转移指令","index":"9","children":[{"id":"表跳转指令","title":"表跳转指令","index":"9.1"},{"id":"异常","title":"异常","index":"9.2"},{"id":"方法调用指令","title":"方法调用指令","index":"9.3"},{"id":"方法返回指令","title":"方法返回指令","index":"9.4"}]},{"id":"线程同步","title":"线程同步","index":"10"},{"id":"jvm指令助记符","title":"JVM指令助记符","index":"11"}]},{"title":"eclipse的常用15个快捷键","author":"Jon","date":"2019-10-28T12:22:00.000Z","_content":"\n# **15 个 Eclipse 常用开发快捷键使用技巧**\n\n1. **alt+?** 或 **alt+/**：自动补全代码或者提示代码\n2. **ctrl+o**：快速outline视图\n3. **ctrl+shift+r**：打开资源列表\n4. **ctrl+shift+f**：格式化代码\n5. **ctrl+e**：快速转换编辑器\n6. **ctrl+page down** 或 **ctrl+page up**： 选项卡之间快速切换\n7. **shift+enter** 及 **ctrl+shift+enter**： 在当前行上或者下边创建空白。\n8. **Alt+方向键上下**：上下行交换内容或把当前行内容把上或下移动\n9. **Control+Alt+方向上下键**：复制高亮显示的一行或多行\n10. **ctrl+m**：当前编辑页面窗口最大化\n11. **ctrl+/**：自动注释当前行或者选择的多行\n12. **ctrl+shift+/**：自动注释掉选择的代码块\n13. **ctrl+d**：删除当前行\n14. **ctrl+shift+x** 和 **ctrl+shift+y** ：英文字母大小写的转换\n15. **ctrl+shift+o**：自动引入包和删除无用包","source":"_posts/eclipse的常用15个快捷键.md","raw":"title: eclipse的常用15个快捷键\ntags:\n  - 开发工具探索\ncategories:\n  - 开发工具\nauthor: Jon\ndate: 2019-10-28 20:22:00\n---\n\n# **15 个 Eclipse 常用开发快捷键使用技巧**\n\n1. **alt+?** 或 **alt+/**：自动补全代码或者提示代码\n2. **ctrl+o**：快速outline视图\n3. **ctrl+shift+r**：打开资源列表\n4. **ctrl+shift+f**：格式化代码\n5. **ctrl+e**：快速转换编辑器\n6. **ctrl+page down** 或 **ctrl+page up**： 选项卡之间快速切换\n7. **shift+enter** 及 **ctrl+shift+enter**： 在当前行上或者下边创建空白。\n8. **Alt+方向键上下**：上下行交换内容或把当前行内容把上或下移动\n9. **Control+Alt+方向上下键**：复制高亮显示的一行或多行\n10. **ctrl+m**：当前编辑页面窗口最大化\n11. **ctrl+/**：自动注释当前行或者选择的多行\n12. **ctrl+shift+/**：自动注释掉选择的代码块\n13. **ctrl+d**：删除当前行\n14. **ctrl+shift+x** 和 **ctrl+shift+y** ：英文字母大小写的转换\n15. **ctrl+shift+o**：自动引入包和删除无用包","slug":"eclipse的常用15个快捷键","published":1,"updated":"2019-12-30T02:50:50.746Z","comments":1,"layout":"post","photos":[],"link":"2019/10/28/eclipse的常用15个快捷键","_id":"ck8jl8qhv0005w0w0g0hgcuho","content":"<h1 id=\"15-个-eclipse-常用开发快捷键使用技巧\"><strong>15 个 Eclipse 常用开发快捷键使用技巧</strong><a href=\"#15-个-eclipse-常用开发快捷键使用技巧\" title=\"15 个 Eclipse 常用开发快捷键使用技巧\"></a></h1><ol><li><strong>alt+?</strong> 或 <strong>alt+/</strong>：自动补全代码或者提示代码</li><li><strong>ctrl+o</strong>：快速outline视图</li><li><strong>ctrl+shift+r</strong>：打开资源列表</li><li><strong>ctrl+shift+f</strong>：格式化代码</li><li><strong>ctrl+e</strong>：快速转换编辑器</li><li><strong>ctrl+page down</strong> 或 <strong>ctrl+page up</strong>： 选项卡之间快速切换</li><li><strong>shift+enter</strong> 及 <strong>ctrl+shift+enter</strong>： 在当前行上或者下边创建空白。</li><li><strong>Alt+方向键上下</strong>：上下行交换内容或把当前行内容把上或下移动</li><li><strong>Control+Alt+方向上下键</strong>：复制高亮显示的一行或多行</li><li><strong>ctrl+m</strong>：当前编辑页面窗口最大化</li><li><strong>ctrl+/</strong>：自动注释当前行或者选择的多行</li><li><strong>ctrl+shift+/</strong>：自动注释掉选择的代码块</li><li><strong>ctrl+d</strong>：删除当前行</li><li><strong>ctrl+shift+x</strong> 和 <strong>ctrl+shift+y</strong> ：英文字母大小写的转换</li><li><strong>ctrl+shift+o</strong>：自动引入包和删除无用包</li></ol>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"15-个-eclipse-常用开发快捷键使用技巧\"><strong>15 个 Eclipse 常用开发快捷键使用技巧</strong><a href=\"#15-个-eclipse-常用开发快捷键使用技巧\" title=\"15 个 Eclipse 常用开发快捷键使用技巧\"></a></h1><ol><li><strong>alt+?</strong> 或 <strong>alt+/</strong>：自动补全代码或者提示代码</li><li><strong>ctrl+o</strong>：快速outline视图</li><li><strong>ctrl+shift+r</strong>：打开资源列表</li><li><strong>ctrl+shift+f</strong>：格式化代码</li><li><strong>ctrl+e</strong>：快速转换编辑器</li><li><strong>ctrl+page down</strong> 或 <strong>ctrl+page up</strong>： 选项卡之间快速切换</li><li><strong>shift+enter</strong> 及 <strong>ctrl+shift+enter</strong>： 在当前行上或者下边创建空白。</li><li><strong>Alt+方向键上下</strong>：上下行交换内容或把当前行内容把上或下移动</li><li><strong>Control+Alt+方向上下键</strong>：复制高亮显示的一行或多行</li><li><strong>ctrl+m</strong>：当前编辑页面窗口最大化</li><li><strong>ctrl+/</strong>：自动注释当前行或者选择的多行</li><li><strong>ctrl+shift+/</strong>：自动注释掉选择的代码块</li><li><strong>ctrl+d</strong>：删除当前行</li><li><strong>ctrl+shift+x</strong> 和 <strong>ctrl+shift+y</strong> ：英文字母大小写的转换</li><li><strong>ctrl+shift+o</strong>：自动引入包和删除无用包</li></ol>","date_formatted":{"ll":"Oct 28, 2019","L":"10/28/2019","MM-DD":"10-28"},"plink":"https://treeeeeeee.github.io/2019/10/28/eclipse的常用15个快捷键/","type":"post","toc":[{"id":"15-个-eclipse-常用开发快捷键使用技巧","title":"15 个 Eclipse 常用开发快捷键使用技巧","index":"1"}]},{"title":"fitsSystemWindows相关总结","date":"2020-03-18T15:50:07.000Z","_content":"\n## 先上结论\n\n```xml\nandroid:fitsSystemWindows=\"true\"\n```\n\n* 默认情况下，设置它的view会添加一些内边距，用来留出一些系统的window的区域，例如状态栏或者底部的虚拟键盘\n\n  > 日常我们最常见的就只有这两个，但不排除其他或者后面会出现的一些新的系统window要留出，所以一旦设置这个属性之后你自己设置的**所有的padding都会失效，上下左右全部，记住是全部**\n\n  另外在xml文件里，配置了这个属性为true的，**哪个控件写在前面谁的就生效**，而且**只能生效一个**，在它之后的后不会生效。\n\n* View是可以对`fitsSystemWindows`进行个性化的，也就是说可以替换默认的添加Padding预留系统视窗的操作，最好的例子我们在下面会讲\n","source":"_posts/fitsSystemWindows相关总结.md","raw":"---\ntitle: fitsSystemWindows相关总结\ndate: 2020-03-18 23:50:07\ntags:\n- 归纳总结\ncategories:\n- Android\n---\n\n## 先上结论\n\n```xml\nandroid:fitsSystemWindows=\"true\"\n```\n\n* 默认情况下，设置它的view会添加一些内边距，用来留出一些系统的window的区域，例如状态栏或者底部的虚拟键盘\n\n  > 日常我们最常见的就只有这两个，但不排除其他或者后面会出现的一些新的系统window要留出，所以一旦设置这个属性之后你自己设置的**所有的padding都会失效，上下左右全部，记住是全部**\n\n  另外在xml文件里，配置了这个属性为true的，**哪个控件写在前面谁的就生效**，而且**只能生效一个**，在它之后的后不会生效。\n\n* View是可以对`fitsSystemWindows`进行个性化的，也就是说可以替换默认的添加Padding预留系统视窗的操作，最好的例子我们在下面会讲\n","slug":"fitsSystemWindows相关总结","published":1,"updated":"2020-04-02T02:10:13.208Z","comments":1,"layout":"post","photos":[],"link":"2020/03/18/fitsSystemWindows相关总结","_id":"ck8jl8qhy0006w0w0blde9y7a","content":"<h2 id=\"先上结论\">先上结论<a href=\"#先上结论\" title=\"先上结论\"></a></h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:fitsSystemWindows=\"true\"</span><br></pre></td></tr></table></figure><ul><li><p>默认情况下，设置它的view会添加一些内边距，用来留出一些系统的window的区域，例如状态栏或者底部的虚拟键盘</p><blockquote><p>日常我们最常见的就只有这两个，但不排除其他或者后面会出现的一些新的系统window要留出，所以一旦设置这个属性之后你自己设置的<strong>所有的padding都会失效，上下左右全部，记住是全部</strong></p></blockquote><p>另外在xml文件里，配置了这个属性为true的，<strong>哪个控件写在前面谁的就生效</strong>，而且<strong>只能生效一个</strong>，在它之后的后不会生效。</p></li><li><p>View是可以对<code>fitsSystemWindows</code>进行个性化的，也就是说可以替换默认的添加Padding预留系统视窗的操作，最好的例子我们在下面会讲</p></li></ul>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"先上结论\">先上结论<a href=\"#先上结论\" title=\"先上结论\"></a></h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:fitsSystemWindows=\"true\"</span><br></pre></td></tr></table></figure><ul><li><p>默认情况下，设置它的view会添加一些内边距，用来留出一些系统的window的区域，例如状态栏或者底部的虚拟键盘</p><blockquote><p>日常我们最常见的就只有这两个，但不排除其他或者后面会出现的一些新的系统window要留出，所以一旦设置这个属性之后你自己设置的<strong>所有的padding都会失效，上下左右全部，记住是全部</strong></p></blockquote><p>另外在xml文件里，配置了这个属性为true的，<strong>哪个控件写在前面谁的就生效</strong>，而且<strong>只能生效一个</strong>，在它之后的后不会生效。</p></li><li><p>View是可以对<code>fitsSystemWindows</code>进行个性化的，也就是说可以替换默认的添加Padding预留系统视窗的操作，最好的例子我们在下面会讲</p></li></ul>","date_formatted":{"ll":"Mar 18, 2020","L":"03/18/2020","MM-DD":"03-18"},"plink":"https://treeeeeeee.github.io/2020/03/18/fitsSystemWindows相关总结/","type":"post","toc":[{"id":"先上结论","title":"先上结论","index":"1"}]},{"title":"git push 解决 弹出用户名和密码输入框","author":"Jon","date":"2019-10-03T18:32:00.000Z","_content":"\n## 首先查看你的远程仓库版本\n\n```bash\ngit remote -v \n\nresult：\norigin  https://github.com/username/username.github.io.git (fetch)\norigin  https://github.com/username/username.github.io.git (push)\n```\n\n若你没有添加别人的仓库，通常只有这两个\n\n## 重新设置对应远程仓库成ssh的方式:\n\n```\ngit remote rm origin\ngit remote add origin git@github.com:username/repository.git\ngit push -u origin master\n```\n\n","source":"_posts/git-push-解决-弹出用户名和密码输入框.md","raw":"title: git push 解决 弹出用户名和密码输入框\nauthor: Jon\ntags:\n  - 知识就是力量\ncategories:\n  - Git学习备忘\ndate: 2019-10-04 02:32:00\n---\n\n## 首先查看你的远程仓库版本\n\n```bash\ngit remote -v \n\nresult：\norigin  https://github.com/username/username.github.io.git (fetch)\norigin  https://github.com/username/username.github.io.git (push)\n```\n\n若你没有添加别人的仓库，通常只有这两个\n\n## 重新设置对应远程仓库成ssh的方式:\n\n```\ngit remote rm origin\ngit remote add origin git@github.com:username/repository.git\ngit push -u origin master\n```\n\n","slug":"git-push-解决-弹出用户名和密码输入框","published":1,"updated":"2019-12-30T02:50:50.749Z","comments":1,"layout":"post","photos":[],"link":"2019/10/04/git-push-解决-弹出用户名和密码输入框","_id":"ck8jl8qi2000aw0w0hytl9osg","content":"<h2 id=\"首先查看你的远程仓库版本\">首先查看你的远程仓库版本<a href=\"#首先查看你的远程仓库版本\" title=\"首先查看你的远程仓库版本\"></a></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v </span><br><span class=\"line\"></span><br><span class=\"line\">result：</span><br><span class=\"line\">origin  https://github.com/username/username.github.io.git (fetch)</span><br><span class=\"line\">origin  https://github.com/username/username.github.io.git (push)</span><br></pre></td></tr></table></figure><p>若你没有添加别人的仓库，通常只有这两个</p>\n<h2 id=\"重新设置对应远程仓库成ssh的方式\">重新设置对应远程仓库成ssh的方式:<a href=\"#重新设置对应远程仓库成ssh的方式\" title=\"重新设置对应远程仓库成ssh的方式:\"></a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin</span><br><span class=\"line\">git remote add origin git@github.com:username&#x2F;repository.git</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"首先查看你的远程仓库版本\">首先查看你的远程仓库版本<a href=\"#首先查看你的远程仓库版本\" title=\"首先查看你的远程仓库版本\"></a></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v </span><br><span class=\"line\"></span><br><span class=\"line\">result：</span><br><span class=\"line\">origin  https://github.com/username/username.github.io.git (fetch)</span><br><span class=\"line\">origin  https://github.com/username/username.github.io.git (push)</span><br></pre></td></tr></table></figure><p>若你没有添加别人的仓库，通常只有这两个</p>\n<h2 id=\"重新设置对应远程仓库成ssh的方式\">重新设置对应远程仓库成ssh的方式:<a href=\"#重新设置对应远程仓库成ssh的方式\" title=\"重新设置对应远程仓库成ssh的方式:\"></a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin</span><br><span class=\"line\">git remote add origin git@github.com:username&#x2F;repository.git</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>","date_formatted":{"ll":"Oct 4, 2019","L":"10/04/2019","MM-DD":"10-04"},"plink":"https://treeeeeeee.github.io/2019/10/04/git-push-解决-弹出用户名和密码输入框/","type":"post","toc":[{"id":"首先查看你的远程仓库版本","title":"首先查看你的远程仓库版本","index":"1"},{"id":"重新设置对应远程仓库成ssh的方式","title":"重新设置对应远程仓库成ssh的方式:","index":"2"}]},{"title":"git常用命令以及如何在idea上可视化操作git","date":"2019-12-30T03:23:44.000Z","thumbnail":"2019/12/30/git常用命令以及如何在idea上可视化操作git/../git常用命令以及如何在idea上可视化操作git/2429e4d2661e60027537aea0077f6e40.png","_content":"\n# git\n\n链接在手，天下你有，自己去详细学习吧：[ 史上最浅显易懂的Git教程！ ](https://www.liaoxuefeng.com/wiki/896043488029600)\n\n## 概念\n\n### 工作区（Working Directory）\n\n是我们直接编辑的地方，例如 idea 打开的项目，记事本打开的文本等，肉眼可见，直接操作。\n\n### 暂存区（Stage 或 Index）\n\n数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。\n\n### 版本库（commit History）\n\n存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程仓库了。\n\n![2429e4d2661e60027537aea0077f6e40](git常用命令以及如何在idea上可视化操作git/2429e4d2661e60027537aea0077f6e40.png)\n\n## 常用命令讲解\n\n### Git 常用命令汇总\n\n#### 1、远程仓库相关命令\n\n- 检出仓库：$ git clone [remoteName]\n- 查看远程仓库：$ git remote -v\n- 添加远程仓库：$ git remote add [name] [url]\n- 删除远程仓库：$ git rm [name]\n- 修改远程仓库：$ git remote set-url --push [name] [newUrl]\n- 拉取远程仓库：$ git pull [remoteName] [localBranchName]\n- 推送远程仓库：$ git push [remoteName] [localBranchName]\n\n*如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：*\n\n- $ git push origin test:master         // 提交本地test分支作为远程的master分支\n- $git push origin test:test              // 提交本地test分支作为远程的test分支\n\n#### 2、分支(branch)操作相关命令\n\n- 查看本地分支：$ git branch\n\n- 查看远程分支：$ git branch -r\n\n- 创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支\n\n  ```shell\n  git branch test\n  ```\n\n- 切换分支：$ git checkout [name]\n\n  ```shell\n  git checkout test\n  ```\n\n- 创建新分支并立即切换到新分支：$ git checkout -b [name]\n\n  ```shell\n  git checkout -b test\n  ```\n\n- 删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项\n\n  ```shell\n  git branch -d test\n  \n  #or\n  \n  git branch -D test\n  ```\n\n- 合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并\n\n- 创建远程分支(本地分支push到远程)：$ git push origin [name]\n\n- 删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name]\n\n- *创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)*\n\n- $git symbolic-ref HEAD refs/heads/[name]\n\n- $rm .git/index\n\n- $git clean -fdx\n\n#### 3、版本(tag)操作相关命令\n\n- 查看版本：$ git tag\n- 创建版本：$ git tag [name]\n- 删除版本：$ git tag -d [name]\n- 查看远程版本：$ git tag -r\n- 创建远程版本(本地版本push到远程)：$ git push origin [name]\n- 删除远程版本：$ git push origin :refs/tags/[name]\n- 合并远程仓库的tag到本地：$ git pull origin --tags\n- 上传本地tag到远程仓库：$ git push origin --tags\n- 创建带注释的tag：$ git tag -a [name] -m 'yourMessage'\n\n#### 4、忽略一些文件、文件夹不提交\n\n[.gitignore文件详解](https://jontree.github.io/2019/10/04/gitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93)\n\n### 附页： Git 常用命令速查\n\n- git branch 查看本地所有分支\n- git status 查看当前状态\n- git commit 提交\n- git branch -a 查看所有的分支\n- git branch -r 查看远程所有分支\n- git commit -am \"init\" 提交并且加注释\n- git remote add origin git@192.168.1.119:ndshow\n- git push origin master 将文件给推到服务器上\n- git remote show origin 显示远程库origin里的资源\n- git push origin master:develop\n- git push origin master:hb-dev 将本地库与服务器上的库进行关联\n- git checkout --track origin/dev 切换到远程dev分支\n- git branch -D master develop 删除本地库develop\n- git checkout -b dev 建立一个新的本地分支dev\n- git merge origin/dev 将分支dev与当前分支进行合并\n- git checkout dev 切换到本地dev分支\n- git remote show 查看远程库\n- git add .\n- git rm 文件名(包括路径) 从git中删除指定文件\n- git clone git://github.com/schacon/grit.git从服务器上将代码给拉下来\n- git config --list 看所有用户\n- git ls-files 看已经被提交的\n- git rm [file name] 删除一个文件\n- git commit -a 提交当前repos的所有的改变\n- git add [file name] 添加一个文件到git index\n- git commit -v 当你用－v参数的时候可以看commit的差异\n- git commit -m \"This is the message describing the commit\" 添加commit信息\n- git commit -a -a是代表add，把所有的change加到git index里然后再commit\n- git commit -a -v 一般提交命令\n- git log 看你commit的日志\n- git diff 查看尚未暂存的更新\n- git rm a.a 移除文件(从暂存区和工作区中删除)\n- git rm --cached a.a 移除文件(只从暂存区中删除)\n- git commit -m \"remove\" 移除文件(从Git中删除)\n- git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)\n- git diff --cached 或 $ git diff --staged 查看尚未提交的更新\n- git stash push 将文件给push到一个临时空间中\n- git stash pop 将文件从临时空间pop下来\n\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n\n- git remote add origin it@github.com:username/Hello-World.git\n- git push origin master 将本地项目给提交到服务器中\n\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n\n- git pull 本地与服务器端同步\n\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n\n- git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。\n- git push origin server fix:awesome branch\n\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n\n- git fetch 相当于是从远程获取最新版本到本地，不会自动merge\n- git commit -a -m \"log_message\" (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：\n- git branch branch_0.1 master 从主分支master创建branch_0.1分支\n- git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0\n- git checkout branch_1.0/master 切换到branch_1.0/master分支\n- du -hs\n- git branch 删除远程branch\n- git push origin:branch_remote_name\n- git branch -r -d branch_remote_name\n\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n\n初始化版本库，并提交到远程服务器端\n\n- mkdir \n\n  新建一个文件夹，一个空格后接你的文件夹的名字\n\n- cd \n\n  进入你的名字\n\n- git init本地初始化\n\n- touch README\n\n- git add README添加文件\n\n- git commit -m 'first commit'\n\n- git remote add origin git@github.com:daixu/WebApp.git增加一个远程服务器端\n\n\n\n细讲我怕又是几小时 <img src=\"java面向对象-接口和其他的类/v2-daba4efa3f71587ad62c168eeb711a01_hd-1571838207875.jpg\" alt=\"img\" style=\"zoom:50%;\" />，下面我给你们简单介绍几个常用命令，也就是我门作业会用到的。也是今后我们用到最多的。\n\n \n\n# github注册\n\n链接在手，天下你有，自己去注册吧：[github注册链接](https://github.com/join?source=header-home)\n\n好了现在你们什么都有了，你就是一个成熟的程序员的了\n\n![IT 从业者的压力究竟有多大？北京某互联网公司28岁程序员王某：其实我觉得吧，压力也没那么大 - 程序员表情包系列_程序员_码农表情](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/006szvLFgy1fwll8fpyzdj30b407dq5d.jpg)\n\n\n\n# 接下来我们来偷懒\n\n你觉得上面的git命令复杂可以先不看，github里面新建工程啥的太麻烦可以先不看。\n\n打开你神奇的idea，并打开你的项目\n\n假如现在你要上传你的项目到你的github，你只需要 点  点  点\n\n![TIM截图20191023163526](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023163526.png)\n\n这一步如果你还没登陆的话会要求你登陆，我这已经登陆了所以直接弹出了这个框，点击share就会帮你在本地执行`git init` `git add .` `git add remote` 你的github里面创建仓库并把你的整个工程传上去，一把梭爽不爽 <img src=\"java面向对象-接口和其他的类/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd.jpg\" alt=\"img\" style=\"zoom: 50%;\" />爽\n\n![TIM截图20191023163817](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023163817.png)\n\n\n\n\n\n好了正式开始你的程序员生活了<img src=\"java面向对象-接口和其他的类/1571820564925.jpeg\" alt=\"1571820564925\" style=\"zoom: 18%;\" />，如何拉网络去你仓库的更新呢？只需  **点**   **点 **   **点**\n\n![TIM截图20191023165925](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023165925.png)\n\n其实拉取对现阶段的你们还没啥用，毕竟远程的就是你本地的本地提交的，但是你和别人合作开发的时候就需要拉取了，为啥呢，因为可能他改了之后提交到远程了呀，你需要更新本地到远程的最新版\n\n\n\n那如何提交呢？<img src=\"java面向对象-接口和其他的类/1571820567750.jpeg\" alt=\"1571820567750\" style=\"zoom:25%;\" /> 只需要  **点  点  点** \n\n![TIM截图20191023170652](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023170652.png)\n\n中间那个大框框里写你这次提交描述，点击下面的，commit就会提交到本地的版本库，你要是想提交到版本库之后直接把代码更新到远程github的仓库里，右边那个小三角，然后commit and push，提交到本地时同时上传远程，会出现，如下页面：\n\n![TIM截图20191023170946](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023170946.png)\n\n点击push就可以了。\n\n\n\n那么问题来了，要是你就想直接commit在本地，等今天工作完了，再push到远程呢？只需   **点**   **点**    **点**\n\n![TIM截图20191023171200](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023171200.png)\n\n好了 ，现在为止你已经会了基本的git操作，是不是超简单。\n\n\n\n好了我来学习更多的git操作，对你自己说，**”我  。 才  。  不  。  要  。   记  。   命  。  令。<img src=\"java面向对象-接口和其他的类/v2-fdddf30851f4370410c068f923e0c405_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />“**\n\n假如你现在突发奇想有另外一个想法，想创建一个测试分支，来写那个功能，咋啦呢？ 只需  **点    点    点**\n\n ![TIM截图20191023171820](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023171820.png)\n\n点击最下面的git 就能唤出这个窗口，这个英文应该大家都能看懂吧，这个英文看不懂就退群吧，思考一下怎么上大学几个月就把高中英语忘完了。\n\n\n\n\n\n好了然后，你写了很多了，也提交了几次之后，你突然发现前面提交的那个有问题，不想提交了那咋办呢？ 只需**点    点    点**\n\n![TIM截图20191023172756](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023172756.png)\n\n那就退到你刚刚新提交的那个版本前面一个呗，例如我觉得`test2`有问题那我就右键点击`test1`，然后\n\n![TIM截图20191023173110](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023173110.png)\n\n这样你刚刚的修改的提交就没了，但是如果你选择的时mix的话，你的修改还是会在的，变成没有提交状态了，我来解释一下这四个选项。\n\n* `soft`重置版本库但是暂存区和工作区不会\n* `mixed`会充值版本库和暂存区，但是工作区还在\n* `hard`会重置版本库暂存区工作区（危险操作，但是找都是可以找回来的）\n* `keep`重置所有的但是会保留文件\n\n\n\n如果你完全不要本地的所有更改了，可以直接hard到最近一个commit（危险操作，虽然我经常做<img src=\"java面向对象-接口和其他的类/v2-a11eadf17f85c2caef8ac2e391d0cf69_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />）\n\n\n\n好了现在假如你完成了你突发奇想的功能感觉还不错，想把test分支合并到主分支要咋办呢？ 还是**点    点    点**\n\n先切换回主分支\n\n![TIM截图20191023175603](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023175603.png)\n\n然后\n\n点击test分支\n\n![TIM截图20191023175637](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023175637.png)\n\n这样就合并啦\n\n这也太简单了吧<img src=\"java面向对象-接口和其他的类/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />","source":"_posts/git常用命令以及如何在idea上可视化操作git.md","raw":"---\ntitle: git常用命令以及如何在idea上可视化操作git\ndate: 2019-12-30 11:23:44\ntags:\n- git常用命令备份\ncategories:\n- git\nthumbnail: ../git常用命令以及如何在idea上可视化操作git/2429e4d2661e60027537aea0077f6e40.png\n---\n\n# git\n\n链接在手，天下你有，自己去详细学习吧：[ 史上最浅显易懂的Git教程！ ](https://www.liaoxuefeng.com/wiki/896043488029600)\n\n## 概念\n\n### 工作区（Working Directory）\n\n是我们直接编辑的地方，例如 idea 打开的项目，记事本打开的文本等，肉眼可见，直接操作。\n\n### 暂存区（Stage 或 Index）\n\n数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。\n\n### 版本库（commit History）\n\n存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程仓库了。\n\n![2429e4d2661e60027537aea0077f6e40](git常用命令以及如何在idea上可视化操作git/2429e4d2661e60027537aea0077f6e40.png)\n\n## 常用命令讲解\n\n### Git 常用命令汇总\n\n#### 1、远程仓库相关命令\n\n- 检出仓库：$ git clone [remoteName]\n- 查看远程仓库：$ git remote -v\n- 添加远程仓库：$ git remote add [name] [url]\n- 删除远程仓库：$ git rm [name]\n- 修改远程仓库：$ git remote set-url --push [name] [newUrl]\n- 拉取远程仓库：$ git pull [remoteName] [localBranchName]\n- 推送远程仓库：$ git push [remoteName] [localBranchName]\n\n*如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：*\n\n- $ git push origin test:master         // 提交本地test分支作为远程的master分支\n- $git push origin test:test              // 提交本地test分支作为远程的test分支\n\n#### 2、分支(branch)操作相关命令\n\n- 查看本地分支：$ git branch\n\n- 查看远程分支：$ git branch -r\n\n- 创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支\n\n  ```shell\n  git branch test\n  ```\n\n- 切换分支：$ git checkout [name]\n\n  ```shell\n  git checkout test\n  ```\n\n- 创建新分支并立即切换到新分支：$ git checkout -b [name]\n\n  ```shell\n  git checkout -b test\n  ```\n\n- 删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项\n\n  ```shell\n  git branch -d test\n  \n  #or\n  \n  git branch -D test\n  ```\n\n- 合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并\n\n- 创建远程分支(本地分支push到远程)：$ git push origin [name]\n\n- 删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name]\n\n- *创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)*\n\n- $git symbolic-ref HEAD refs/heads/[name]\n\n- $rm .git/index\n\n- $git clean -fdx\n\n#### 3、版本(tag)操作相关命令\n\n- 查看版本：$ git tag\n- 创建版本：$ git tag [name]\n- 删除版本：$ git tag -d [name]\n- 查看远程版本：$ git tag -r\n- 创建远程版本(本地版本push到远程)：$ git push origin [name]\n- 删除远程版本：$ git push origin :refs/tags/[name]\n- 合并远程仓库的tag到本地：$ git pull origin --tags\n- 上传本地tag到远程仓库：$ git push origin --tags\n- 创建带注释的tag：$ git tag -a [name] -m 'yourMessage'\n\n#### 4、忽略一些文件、文件夹不提交\n\n[.gitignore文件详解](https://jontree.github.io/2019/10/04/gitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93)\n\n### 附页： Git 常用命令速查\n\n- git branch 查看本地所有分支\n- git status 查看当前状态\n- git commit 提交\n- git branch -a 查看所有的分支\n- git branch -r 查看远程所有分支\n- git commit -am \"init\" 提交并且加注释\n- git remote add origin git@192.168.1.119:ndshow\n- git push origin master 将文件给推到服务器上\n- git remote show origin 显示远程库origin里的资源\n- git push origin master:develop\n- git push origin master:hb-dev 将本地库与服务器上的库进行关联\n- git checkout --track origin/dev 切换到远程dev分支\n- git branch -D master develop 删除本地库develop\n- git checkout -b dev 建立一个新的本地分支dev\n- git merge origin/dev 将分支dev与当前分支进行合并\n- git checkout dev 切换到本地dev分支\n- git remote show 查看远程库\n- git add .\n- git rm 文件名(包括路径) 从git中删除指定文件\n- git clone git://github.com/schacon/grit.git从服务器上将代码给拉下来\n- git config --list 看所有用户\n- git ls-files 看已经被提交的\n- git rm [file name] 删除一个文件\n- git commit -a 提交当前repos的所有的改变\n- git add [file name] 添加一个文件到git index\n- git commit -v 当你用－v参数的时候可以看commit的差异\n- git commit -m \"This is the message describing the commit\" 添加commit信息\n- git commit -a -a是代表add，把所有的change加到git index里然后再commit\n- git commit -a -v 一般提交命令\n- git log 看你commit的日志\n- git diff 查看尚未暂存的更新\n- git rm a.a 移除文件(从暂存区和工作区中删除)\n- git rm --cached a.a 移除文件(只从暂存区中删除)\n- git commit -m \"remove\" 移除文件(从Git中删除)\n- git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)\n- git diff --cached 或 $ git diff --staged 查看尚未提交的更新\n- git stash push 将文件给push到一个临时空间中\n- git stash pop 将文件从临时空间pop下来\n\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n\n- git remote add origin it@github.com:username/Hello-World.git\n- git push origin master 将本地项目给提交到服务器中\n\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n\n- git pull 本地与服务器端同步\n\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n\n- git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。\n- git push origin server fix:awesome branch\n\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n\n- git fetch 相当于是从远程获取最新版本到本地，不会自动merge\n- git commit -a -m \"log_message\" (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：\n- git branch branch_0.1 master 从主分支master创建branch_0.1分支\n- git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0\n- git checkout branch_1.0/master 切换到branch_1.0/master分支\n- du -hs\n- git branch 删除远程branch\n- git push origin:branch_remote_name\n- git branch -r -d branch_remote_name\n\n－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n\n初始化版本库，并提交到远程服务器端\n\n- mkdir \n\n  新建一个文件夹，一个空格后接你的文件夹的名字\n\n- cd \n\n  进入你的名字\n\n- git init本地初始化\n\n- touch README\n\n- git add README添加文件\n\n- git commit -m 'first commit'\n\n- git remote add origin git@github.com:daixu/WebApp.git增加一个远程服务器端\n\n\n\n细讲我怕又是几小时 <img src=\"java面向对象-接口和其他的类/v2-daba4efa3f71587ad62c168eeb711a01_hd-1571838207875.jpg\" alt=\"img\" style=\"zoom:50%;\" />，下面我给你们简单介绍几个常用命令，也就是我门作业会用到的。也是今后我们用到最多的。\n\n \n\n# github注册\n\n链接在手，天下你有，自己去注册吧：[github注册链接](https://github.com/join?source=header-home)\n\n好了现在你们什么都有了，你就是一个成熟的程序员的了\n\n![IT 从业者的压力究竟有多大？北京某互联网公司28岁程序员王某：其实我觉得吧，压力也没那么大 - 程序员表情包系列_程序员_码农表情](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/006szvLFgy1fwll8fpyzdj30b407dq5d.jpg)\n\n\n\n# 接下来我们来偷懒\n\n你觉得上面的git命令复杂可以先不看，github里面新建工程啥的太麻烦可以先不看。\n\n打开你神奇的idea，并打开你的项目\n\n假如现在你要上传你的项目到你的github，你只需要 点  点  点\n\n![TIM截图20191023163526](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023163526.png)\n\n这一步如果你还没登陆的话会要求你登陆，我这已经登陆了所以直接弹出了这个框，点击share就会帮你在本地执行`git init` `git add .` `git add remote` 你的github里面创建仓库并把你的整个工程传上去，一把梭爽不爽 <img src=\"java面向对象-接口和其他的类/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd.jpg\" alt=\"img\" style=\"zoom: 50%;\" />爽\n\n![TIM截图20191023163817](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023163817.png)\n\n\n\n\n\n好了正式开始你的程序员生活了<img src=\"java面向对象-接口和其他的类/1571820564925.jpeg\" alt=\"1571820564925\" style=\"zoom: 18%;\" />，如何拉网络去你仓库的更新呢？只需  **点**   **点 **   **点**\n\n![TIM截图20191023165925](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023165925.png)\n\n其实拉取对现阶段的你们还没啥用，毕竟远程的就是你本地的本地提交的，但是你和别人合作开发的时候就需要拉取了，为啥呢，因为可能他改了之后提交到远程了呀，你需要更新本地到远程的最新版\n\n\n\n那如何提交呢？<img src=\"java面向对象-接口和其他的类/1571820567750.jpeg\" alt=\"1571820567750\" style=\"zoom:25%;\" /> 只需要  **点  点  点** \n\n![TIM截图20191023170652](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023170652.png)\n\n中间那个大框框里写你这次提交描述，点击下面的，commit就会提交到本地的版本库，你要是想提交到版本库之后直接把代码更新到远程github的仓库里，右边那个小三角，然后commit and push，提交到本地时同时上传远程，会出现，如下页面：\n\n![TIM截图20191023170946](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023170946.png)\n\n点击push就可以了。\n\n\n\n那么问题来了，要是你就想直接commit在本地，等今天工作完了，再push到远程呢？只需   **点**   **点**    **点**\n\n![TIM截图20191023171200](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023171200.png)\n\n好了 ，现在为止你已经会了基本的git操作，是不是超简单。\n\n\n\n好了我来学习更多的git操作，对你自己说，**”我  。 才  。  不  。  要  。   记  。   命  。  令。<img src=\"java面向对象-接口和其他的类/v2-fdddf30851f4370410c068f923e0c405_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />“**\n\n假如你现在突发奇想有另外一个想法，想创建一个测试分支，来写那个功能，咋啦呢？ 只需  **点    点    点**\n\n ![TIM截图20191023171820](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023171820.png)\n\n点击最下面的git 就能唤出这个窗口，这个英文应该大家都能看懂吧，这个英文看不懂就退群吧，思考一下怎么上大学几个月就把高中英语忘完了。\n\n\n\n\n\n好了然后，你写了很多了，也提交了几次之后，你突然发现前面提交的那个有问题，不想提交了那咋办呢？ 只需**点    点    点**\n\n![TIM截图20191023172756](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023172756.png)\n\n那就退到你刚刚新提交的那个版本前面一个呗，例如我觉得`test2`有问题那我就右键点击`test1`，然后\n\n![TIM截图20191023173110](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023173110.png)\n\n这样你刚刚的修改的提交就没了，但是如果你选择的时mix的话，你的修改还是会在的，变成没有提交状态了，我来解释一下这四个选项。\n\n* `soft`重置版本库但是暂存区和工作区不会\n* `mixed`会充值版本库和暂存区，但是工作区还在\n* `hard`会重置版本库暂存区工作区（危险操作，但是找都是可以找回来的）\n* `keep`重置所有的但是会保留文件\n\n\n\n如果你完全不要本地的所有更改了，可以直接hard到最近一个commit（危险操作，虽然我经常做<img src=\"java面向对象-接口和其他的类/v2-a11eadf17f85c2caef8ac2e391d0cf69_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />）\n\n\n\n好了现在假如你完成了你突发奇想的功能感觉还不错，想把test分支合并到主分支要咋办呢？ 还是**点    点    点**\n\n先切换回主分支\n\n![TIM截图20191023175603](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023175603.png)\n\n然后\n\n点击test分支\n\n![TIM截图20191023175637](git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023175637.png)\n\n这样就合并啦\n\n这也太简单了吧<img src=\"java面向对象-接口和其他的类/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />","slug":"git常用命令以及如何在idea上可视化操作git","published":1,"updated":"2020-04-02T19:34:29.721Z","_id":"ck8jl8qi7000bw0w0gl758ye2","comments":1,"layout":"post","photos":[],"link":"2019/12/30/git常用命令以及如何在idea上可视化操作git","content":"<h1 id=\"git\">git<a href=\"#git\" title=\"git\"></a></h1><p>链接在手，天下你有，自己去详细学习吧：<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\" target=\"_blank\">史上最浅显易懂的Git教程！</a></p>\n<h2 id=\"概念\">概念<a href=\"#概念\" title=\"概念\"></a></h2><h3 id=\"工作区（working-directory）\">工作区（Working Directory）<a href=\"#工作区（working-directory）\" title=\"工作区（Working Directory）\"></a></h3><p>是我们直接编辑的地方，例如 idea 打开的项目，记事本打开的文本等，肉眼可见，直接操作。</p>\n<h3 id=\"暂存区（stage-或-index）\">暂存区（Stage 或 Index）<a href=\"#暂存区（stage-或-index）\" title=\"暂存区（Stage 或 Index）\"></a></h3><p>数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。</p>\n<h3 id=\"版本库（commit-history）\">版本库（commit History）<a href=\"#版本库（commit-history）\" title=\"版本库（commit History）\"></a></h3><p>存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程仓库了。</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/2429e4d2661e60027537aea0077f6e40.png\" class=\"φcy\" alt=\"2429e4d2661e60027537aea0077f6e40\"></p>\n<h2 id=\"常用命令讲解\">常用命令讲解<a href=\"#常用命令讲解\" title=\"常用命令讲解\"></a></h2><h3 id=\"git-常用命令汇总\">Git 常用命令汇总<a href=\"#git-常用命令汇总\" title=\"Git 常用命令汇总\"></a></h3><h4 id=\"1、远程仓库相关命令\">1、远程仓库相关命令<a href=\"#1、远程仓库相关命令\" title=\"1、远程仓库相关命令\"></a></h4><ul><li>检出仓库：$ git clone [remoteName]</li><li>查看远程仓库：$ git remote -v</li><li>添加远程仓库：$ git remote add [name] [url]</li><li>删除远程仓库：$ git rm [name]</li><li>修改远程仓库：$ git remote set-url –push [name] [newUrl]</li><li>拉取远程仓库：$ git pull [remoteName] [localBranchName]</li><li>推送远程仓库：$ git push [remoteName] [localBranchName]</li></ul><p><em>如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：</em></p>\n<ul><li>$ git push origin test:master // 提交本地test分支作为远程的master分支</li><li>$git push origin test:test // 提交本地test分支作为远程的test分支</li></ul><h4 id=\"2、分支branch操作相关命令\">2、分支(branch)操作相关命令<a href=\"#2、分支branch操作相关命令\" title=\"2、分支(branch)操作相关命令\"></a></h4><ul><li><p>查看本地分支：$ git branch</p></li><li><p>查看远程分支：$ git branch -r</p></li><li><p>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支</p></li><li><p>切换分支：$ git checkout [name]</p></li><li><p>创建新分支并立即切换到新分支：$ git checkout -b [name]</p></li><li><p>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</p></li><li><p>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并</p></li><li><p>创建远程分支(本地分支push到远程)：$ git push origin [name]</p></li><li><p>删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name]</p></li><li><p><em>创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)</em></p></li><li><p>$git symbolic-ref HEAD refs/heads/[name]</p></li><li><p>$rm .git/index</p></li><li><p>$git clean -fdx</p></li></ul><h4 id=\"3、版本tag操作相关命令\">3、版本(tag)操作相关命令<a href=\"#3、版本tag操作相关命令\" title=\"3、版本(tag)操作相关命令\"></a></h4><ul><li>查看版本：$ git tag</li><li>创建版本：$ git tag [name]</li><li>删除版本：$ git tag -d [name]</li><li>查看远程版本：$ git tag -r</li><li>创建远程版本(本地版本push到远程)：$ git push origin [name]</li><li>删除远程版本：$ git push origin :refs/tags/[name]</li><li>合并远程仓库的tag到本地：$ git pull origin –tags</li><li>上传本地tag到远程仓库：$ git push origin –tags</li><li>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’</li></ul><h4 id=\"4、忽略一些文件、文件夹不提交\">4、忽略一些文件、文件夹不提交<a href=\"#4、忽略一些文件、文件夹不提交\" title=\"4、忽略一些文件、文件夹不提交\"></a></h4><p><a href=\"https://jontree.github.io/2019/10/04/gitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93\" target=\"_blank\">.gitignore文件详解</a></p>\n<h3 id=\"附页：-git-常用命令速查\">附页： Git 常用命令速查<a href=\"#附页：-git-常用命令速查\" title=\"附页： Git 常用命令速查\"></a></h3><ul><li>git branch 查看本地所有分支</li><li>git status 查看当前状态</li><li>git commit 提交</li><li>git branch -a 查看所有的分支</li><li>git branch -r 查看远程所有分支</li><li>git commit -am “init” 提交并且加注释</li><li>git remote add origin <a href=\"mailto:git@192.168.1.119\">git@192.168.1.119</a>:ndshow</li><li>git push origin master 将文件给推到服务器上</li><li>git remote show origin 显示远程库origin里的资源</li><li>git push origin master:develop</li><li>git push origin master:hb-dev 将本地库与服务器上的库进行关联</li><li>git checkout –track origin/dev 切换到远程dev分支</li><li>git branch -D master develop 删除本地库develop</li><li>git checkout -b dev 建立一个新的本地分支dev</li><li>git merge origin/dev 将分支dev与当前分支进行合并</li><li>git checkout dev 切换到本地dev分支</li><li>git remote show 查看远程库</li><li>git add .</li><li>git rm 文件名(包括路径) 从git中删除指定文件</li><li>git clone git://github.com/schacon/grit.git从服务器上将代码给拉下来</li><li>git config –list 看所有用户</li><li>git ls-files 看已经被提交的</li><li>git rm [file name] 删除一个文件</li><li>git commit -a 提交当前repos的所有的改变</li><li>git add [file name] 添加一个文件到git index</li><li>git commit -v 当你用－v参数的时候可以看commit的差异</li><li>git commit -m “This is the message describing the commit” 添加commit信息</li><li>git commit -a -a是代表add，把所有的change加到git index里然后再commit</li><li>git commit -a -v 一般提交命令</li><li>git log 看你commit的日志</li><li>git diff 查看尚未暂存的更新</li><li>git rm a.a 移除文件(从暂存区和工作区中删除)</li><li>git rm –cached a.a 移除文件(只从暂存区中删除)</li><li>git commit -m “remove” 移除文件(从Git中删除)</li><li>git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)</li><li>git diff –cached 或 $ git diff –staged 查看尚未提交的更新</li><li>git stash push 将文件给push到一个临时空间中</li><li>git stash pop 将文件从临时空间pop下来</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>\n<ul><li>git remote add origin <a href=\"mailto:it@github.com\">it@github.com</a>:username/Hello-World.git</li><li>git push origin master 将本地项目给提交到服务器中</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>\n<ul><li>git pull 本地与服务器端同步</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>\n<ul><li>git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。</li><li>git push origin server fix:awesome branch</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>\n<ul><li>git fetch 相当于是从远程获取最新版本到本地，不会自动merge</li><li>git commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：</li><li>git branch branch_0.1 master 从主分支master创建branch_0.1分支</li><li>git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0</li><li>git checkout branch_1.0/master 切换到branch_1.0/master分支</li><li>du -hs</li><li>git branch 删除远程branch</li><li>git push origin:branch_remote_name</li><li>git branch -r -d branch_remote_name</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>\n<p>初始化版本库，并提交到远程服务器端</p>\n<ul><li><p>mkdir</p><p>新建一个文件夹，一个空格后接你的文件夹的名字</p></li><li><p>cd</p><p>进入你的名字</p></li><li><p>git init本地初始化</p></li><li><p>touch README</p></li><li><p>git add README添加文件</p></li><li><p>git commit -m ‘first commit’</p></li><li><p>git remote add origin <a href=\"mailto:git@github.com\">git@github.com</a>:daixu/WebApp.git增加一个远程服务器端</p></li></ul><p>细讲我怕又是几小时 <img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/v2-daba4efa3f71587ad62c168eeb711a01_hd-1571838207875.jpg\" alt=\"img\" style=\"zoom:50%;\">，下面我给你们简单介绍几个常用命令，也就是我门作业会用到的。也是今后我们用到最多的。</p>\n<h1 id=\"github注册\">github注册<a href=\"#github注册\" title=\"github注册\"></a></h1><p>链接在手，天下你有，自己去注册吧：<a href=\"https://github.com/join?source=header-home\" target=\"_blank\">github注册链接</a></p>\n<p>好了现在你们什么都有了，你就是一个成熟的程序员的了</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/006szvLFgy1fwll8fpyzdj30b407dq5d.jpg\" class=\"φcy\" alt=\"IT 从业者的压力究竟有多大？北京某互联网公司28岁程序员王某：其实我觉得吧，压力也没那么大 - 程序员表情包系列_程序员_码农表情\"></p>\n<h1 id=\"接下来我们来偷懒\">接下来我们来偷懒<a href=\"#接下来我们来偷懒\" title=\"接下来我们来偷懒\"></a></h1><p>你觉得上面的git命令复杂可以先不看，github里面新建工程啥的太麻烦可以先不看。</p>\n<p>打开你神奇的idea，并打开你的项目</p>\n<p>假如现在你要上传你的项目到你的github，你只需要 点  点  点</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023163526.png\" class=\"φcy\" alt=\"TIM截图20191023163526\"></p>\n<p>这一步如果你还没登陆的话会要求你登陆，我这已经登陆了所以直接弹出了这个框，点击share就会帮你在本地执行<code>git init</code> <code>git add .</code> <code>git add remote</code> 你的github里面创建仓库并把你的整个工程传上去，一把梭爽不爽 <img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd.jpg\" alt=\"img\" style=\"zoom: 50%;\">爽</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023163817.png\" class=\"φcy\" alt=\"TIM截图20191023163817\"></p>\n<p>好了正式开始你的程序员生活了<img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/1571820564925.jpeg\" alt=\"1571820564925\" style=\"zoom: 18%;\">，如何拉网络去你仓库的更新呢？只需  <strong>点</strong>   <strong>点 **   **点</strong></p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023165925.png\" class=\"φcy\" alt=\"TIM截图20191023165925\"></p>\n<p>其实拉取对现阶段的你们还没啥用，毕竟远程的就是你本地的本地提交的，但是你和别人合作开发的时候就需要拉取了，为啥呢，因为可能他改了之后提交到远程了呀，你需要更新本地到远程的最新版</p>\n<p>那如何提交呢？<img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/1571820567750.jpeg\" alt=\"1571820567750\" style=\"zoom:25%;\"> 只需要  <strong>点  点  点</strong> </p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023170652.png\" class=\"φcy\" alt=\"TIM截图20191023170652\"></p>\n<p>中间那个大框框里写你这次提交描述，点击下面的，commit就会提交到本地的版本库，你要是想提交到版本库之后直接把代码更新到远程github的仓库里，右边那个小三角，然后commit and push，提交到本地时同时上传远程，会出现，如下页面：</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023170946.png\" class=\"φcy\" alt=\"TIM截图20191023170946\"></p>\n<p>点击push就可以了。</p>\n<p>那么问题来了，要是你就想直接commit在本地，等今天工作完了，再push到远程呢？只需   <strong>点</strong>   <strong>点</strong>    <strong>点</strong></p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023171200.png\" class=\"φcy\" alt=\"TIM截图20191023171200\"></p>\n<p>好了 ，现在为止你已经会了基本的git操作，是不是超简单。</p>\n<p>好了我来学习更多的git操作，对你自己说，<strong>”我  。 才  。  不  。  要  。   记  。   命  。  令。<img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/v2-fdddf30851f4370410c068f923e0c405_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">“</strong></p>\n<p>假如你现在突发奇想有另外一个想法，想创建一个测试分支，来写那个功能，咋啦呢？ 只需  <strong>点    点    点</strong></p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023171820.png\" class=\"φcy\" alt=\"TIM截图20191023171820\"></p>\n<p>点击最下面的git 就能唤出这个窗口，这个英文应该大家都能看懂吧，这个英文看不懂就退群吧，思考一下怎么上大学几个月就把高中英语忘完了。</p>\n<p>好了然后，你写了很多了，也提交了几次之后，你突然发现前面提交的那个有问题，不想提交了那咋办呢？ 只需<strong>点    点    点</strong></p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023172756.png\" class=\"φcy\" alt=\"TIM截图20191023172756\"></p>\n<p>那就退到你刚刚新提交的那个版本前面一个呗，例如我觉得<code>test2</code>有问题那我就右键点击<code>test1</code>，然后</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023173110.png\" class=\"φcy\" alt=\"TIM截图20191023173110\"></p>\n<p>这样你刚刚的修改的提交就没了，但是如果你选择的时mix的话，你的修改还是会在的，变成没有提交状态了，我来解释一下这四个选项。</p>\n<ul><li><code>soft</code>重置版本库但是暂存区和工作区不会</li><li><code>mixed</code>会充值版本库和暂存区，但是工作区还在</li><li><code>hard</code>会重置版本库暂存区工作区（危险操作，但是找都是可以找回来的）</li><li><code>keep</code>重置所有的但是会保留文件</li></ul><p>如果你完全不要本地的所有更改了，可以直接hard到最近一个commit（危险操作，虽然我经常做<img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/v2-a11eadf17f85c2caef8ac2e391d0cf69_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">）</p>\n<p>好了现在假如你完成了你突发奇想的功能感觉还不错，想把test分支合并到主分支要咋办呢？ 还是<strong>点    点    点</strong></p>\n<p>先切换回主分支</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023175603.png\" class=\"φcy\" alt=\"TIM截图20191023175603\"></p>\n<p>然后</p>\n<p>点击test分支</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023175637.png\" class=\"φcy\" alt=\"TIM截图20191023175637\"></p>\n<p>这样就合并啦</p>\n<p>这也太简单了吧<img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"git\">git<a href=\"#git\" title=\"git\"></a></h1><p>链接在手，天下你有，自己去详细学习吧：<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\" target=\"_blank\">史上最浅显易懂的Git教程！</a></p>\n<h2 id=\"概念\">概念<a href=\"#概念\" title=\"概念\"></a></h2><h3 id=\"工作区（working-directory）\">工作区（Working Directory）<a href=\"#工作区（working-directory）\" title=\"工作区（Working Directory）\"></a></h3><p>是我们直接编辑的地方，例如 idea 打开的项目，记事本打开的文本等，肉眼可见，直接操作。</p>\n<h3 id=\"暂存区（stage-或-index）\">暂存区（Stage 或 Index）<a href=\"#暂存区（stage-或-index）\" title=\"暂存区（Stage 或 Index）\"></a></h3><p>数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。</p>\n<h3 id=\"版本库（commit-history）\">版本库（commit History）<a href=\"#版本库（commit-history）\" title=\"版本库（commit History）\"></a></h3><p>存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程仓库了。</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/2429e4d2661e60027537aea0077f6e40.png\" class=\"φcy\" alt=\"2429e4d2661e60027537aea0077f6e40\"></p>\n<h2 id=\"常用命令讲解\">常用命令讲解<a href=\"#常用命令讲解\" title=\"常用命令讲解\"></a></h2><h3 id=\"git-常用命令汇总\">Git 常用命令汇总<a href=\"#git-常用命令汇总\" title=\"Git 常用命令汇总\"></a></h3><h4 id=\"1、远程仓库相关命令\">1、远程仓库相关命令<a href=\"#1、远程仓库相关命令\" title=\"1、远程仓库相关命令\"></a></h4><ul><li>检出仓库：$ git clone [remoteName]</li><li>查看远程仓库：$ git remote -v</li><li>添加远程仓库：$ git remote add [name] [url]</li><li>删除远程仓库：$ git rm [name]</li><li>修改远程仓库：$ git remote set-url –push [name] [newUrl]</li><li>拉取远程仓库：$ git pull [remoteName] [localBranchName]</li><li>推送远程仓库：$ git push [remoteName] [localBranchName]</li></ul><p><em>如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：</em></p>\n<ul><li>$ git push origin test:master // 提交本地test分支作为远程的master分支</li><li>$git push origin test:test // 提交本地test分支作为远程的test分支</li></ul><h4 id=\"2、分支branch操作相关命令\">2、分支(branch)操作相关命令<a href=\"#2、分支branch操作相关命令\" title=\"2、分支(branch)操作相关命令\"></a></h4><ul><li><p>查看本地分支：$ git branch</p></li><li><p>查看远程分支：$ git branch -r</p></li><li><p>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支</p></li><li><p>切换分支：$ git checkout [name]</p></li><li><p>创建新分支并立即切换到新分支：$ git checkout -b [name]</p></li><li><p>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</p></li><li><p>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并</p></li><li><p>创建远程分支(本地分支push到远程)：$ git push origin [name]</p></li><li><p>删除远程分支：$ git push origin :heads/[name] 或 $ git push origin :[name]</p></li><li><p><em>创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)</em></p></li><li><p>$git symbolic-ref HEAD refs/heads/[name]</p></li><li><p>$rm .git/index</p></li><li><p>$git clean -fdx</p></li></ul><h4 id=\"3、版本tag操作相关命令\">3、版本(tag)操作相关命令<a href=\"#3、版本tag操作相关命令\" title=\"3、版本(tag)操作相关命令\"></a></h4><ul><li>查看版本：$ git tag</li><li>创建版本：$ git tag [name]</li><li>删除版本：$ git tag -d [name]</li><li>查看远程版本：$ git tag -r</li><li>创建远程版本(本地版本push到远程)：$ git push origin [name]</li><li>删除远程版本：$ git push origin :refs/tags/[name]</li><li>合并远程仓库的tag到本地：$ git pull origin –tags</li><li>上传本地tag到远程仓库：$ git push origin –tags</li><li>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’</li></ul><h4 id=\"4、忽略一些文件、文件夹不提交\">4、忽略一些文件、文件夹不提交<a href=\"#4、忽略一些文件、文件夹不提交\" title=\"4、忽略一些文件、文件夹不提交\"></a></h4><p><a href=\"https://jontree.github.io/2019/10/04/gitignore%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93\" target=\"_blank\">.gitignore文件详解</a></p>\n<h3 id=\"附页：-git-常用命令速查\">附页： Git 常用命令速查<a href=\"#附页：-git-常用命令速查\" title=\"附页： Git 常用命令速查\"></a></h3><ul><li>git branch 查看本地所有分支</li><li>git status 查看当前状态</li><li>git commit 提交</li><li>git branch -a 查看所有的分支</li><li>git branch -r 查看远程所有分支</li><li>git commit -am “init” 提交并且加注释</li><li>git remote add origin <a href=\"mailto:git@192.168.1.119\">git@192.168.1.119</a>:ndshow</li><li>git push origin master 将文件给推到服务器上</li><li>git remote show origin 显示远程库origin里的资源</li><li>git push origin master:develop</li><li>git push origin master:hb-dev 将本地库与服务器上的库进行关联</li><li>git checkout –track origin/dev 切换到远程dev分支</li><li>git branch -D master develop 删除本地库develop</li><li>git checkout -b dev 建立一个新的本地分支dev</li><li>git merge origin/dev 将分支dev与当前分支进行合并</li><li>git checkout dev 切换到本地dev分支</li><li>git remote show 查看远程库</li><li>git add .</li><li>git rm 文件名(包括路径) 从git中删除指定文件</li><li>git clone git://github.com/schacon/grit.git从服务器上将代码给拉下来</li><li>git config –list 看所有用户</li><li>git ls-files 看已经被提交的</li><li>git rm [file name] 删除一个文件</li><li>git commit -a 提交当前repos的所有的改变</li><li>git add [file name] 添加一个文件到git index</li><li>git commit -v 当你用－v参数的时候可以看commit的差异</li><li>git commit -m “This is the message describing the commit” 添加commit信息</li><li>git commit -a -a是代表add，把所有的change加到git index里然后再commit</li><li>git commit -a -v 一般提交命令</li><li>git log 看你commit的日志</li><li>git diff 查看尚未暂存的更新</li><li>git rm a.a 移除文件(从暂存区和工作区中删除)</li><li>git rm –cached a.a 移除文件(只从暂存区中删除)</li><li>git commit -m “remove” 移除文件(从Git中删除)</li><li>git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)</li><li>git diff –cached 或 $ git diff –staged 查看尚未提交的更新</li><li>git stash push 将文件给push到一个临时空间中</li><li>git stash pop 将文件从临时空间pop下来</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>\n<ul><li>git remote add origin <a href=\"mailto:it@github.com\">it@github.com</a>:username/Hello-World.git</li><li>git push origin master 将本地项目给提交到服务器中</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>\n<ul><li>git pull 本地与服务器端同步</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>\n<ul><li>git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。</li><li>git push origin server fix:awesome branch</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>\n<ul><li>git fetch 相当于是从远程获取最新版本到本地，不会自动merge</li><li>git commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：</li><li>git branch branch_0.1 master 从主分支master创建branch_0.1分支</li><li>git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0</li><li>git checkout branch_1.0/master 切换到branch_1.0/master分支</li><li>du -hs</li><li>git branch 删除远程branch</li><li>git push origin:branch_remote_name</li><li>git branch -r -d branch_remote_name</li></ul><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>\n<p>初始化版本库，并提交到远程服务器端</p>\n<ul><li><p>mkdir</p><p>新建一个文件夹，一个空格后接你的文件夹的名字</p></li><li><p>cd</p><p>进入你的名字</p></li><li><p>git init本地初始化</p></li><li><p>touch README</p></li><li><p>git add README添加文件</p></li><li><p>git commit -m ‘first commit’</p></li><li><p>git remote add origin <a href=\"mailto:git@github.com\">git@github.com</a>:daixu/WebApp.git增加一个远程服务器端</p></li></ul><p>细讲我怕又是几小时 <img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/v2-daba4efa3f71587ad62c168eeb711a01_hd-1571838207875.jpg\" alt=\"img\" style=\"zoom:50%;\">，下面我给你们简单介绍几个常用命令，也就是我门作业会用到的。也是今后我们用到最多的。</p>\n<h1 id=\"github注册\">github注册<a href=\"#github注册\" title=\"github注册\"></a></h1><p>链接在手，天下你有，自己去注册吧：<a href=\"https://github.com/join?source=header-home\" target=\"_blank\">github注册链接</a></p>\n<p>好了现在你们什么都有了，你就是一个成熟的程序员的了</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/006szvLFgy1fwll8fpyzdj30b407dq5d.jpg\" class=\"φcy\" alt=\"IT 从业者的压力究竟有多大？北京某互联网公司28岁程序员王某：其实我觉得吧，压力也没那么大 - 程序员表情包系列_程序员_码农表情\"></p>\n<h1 id=\"接下来我们来偷懒\">接下来我们来偷懒<a href=\"#接下来我们来偷懒\" title=\"接下来我们来偷懒\"></a></h1><p>你觉得上面的git命令复杂可以先不看，github里面新建工程啥的太麻烦可以先不看。</p>\n<p>打开你神奇的idea，并打开你的项目</p>\n<p>假如现在你要上传你的项目到你的github，你只需要 点  点  点</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023163526.png\" class=\"φcy\" alt=\"TIM截图20191023163526\"></p>\n<p>这一步如果你还没登陆的话会要求你登陆，我这已经登陆了所以直接弹出了这个框，点击share就会帮你在本地执行<code>git init</code> <code>git add .</code> <code>git add remote</code> 你的github里面创建仓库并把你的整个工程传上去，一把梭爽不爽 <img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd.jpg\" alt=\"img\" style=\"zoom: 50%;\">爽</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023163817.png\" class=\"φcy\" alt=\"TIM截图20191023163817\"></p>\n<p>好了正式开始你的程序员生活了<img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/1571820564925.jpeg\" alt=\"1571820564925\" style=\"zoom: 18%;\">，如何拉网络去你仓库的更新呢？只需  <strong>点</strong>   <strong>点 **   **点</strong></p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023165925.png\" class=\"φcy\" alt=\"TIM截图20191023165925\"></p>\n<p>其实拉取对现阶段的你们还没啥用，毕竟远程的就是你本地的本地提交的，但是你和别人合作开发的时候就需要拉取了，为啥呢，因为可能他改了之后提交到远程了呀，你需要更新本地到远程的最新版</p>\n<p>那如何提交呢？<img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/1571820567750.jpeg\" alt=\"1571820567750\" style=\"zoom:25%;\"> 只需要  <strong>点  点  点</strong> </p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023170652.png\" class=\"φcy\" alt=\"TIM截图20191023170652\"></p>\n<p>中间那个大框框里写你这次提交描述，点击下面的，commit就会提交到本地的版本库，你要是想提交到版本库之后直接把代码更新到远程github的仓库里，右边那个小三角，然后commit and push，提交到本地时同时上传远程，会出现，如下页面：</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023170946.png\" class=\"φcy\" alt=\"TIM截图20191023170946\"></p>\n<p>点击push就可以了。</p>\n<p>那么问题来了，要是你就想直接commit在本地，等今天工作完了，再push到远程呢？只需   <strong>点</strong>   <strong>点</strong>    <strong>点</strong></p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023171200.png\" class=\"φcy\" alt=\"TIM截图20191023171200\"></p>\n<p>好了 ，现在为止你已经会了基本的git操作，是不是超简单。</p>\n<p>好了我来学习更多的git操作，对你自己说，<strong>”我  。 才  。  不  。  要  。   记  。   命  。  令。<img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/v2-fdddf30851f4370410c068f923e0c405_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">“</strong></p>\n<p>假如你现在突发奇想有另外一个想法，想创建一个测试分支，来写那个功能，咋啦呢？ 只需  <strong>点    点    点</strong></p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023171820.png\" class=\"φcy\" alt=\"TIM截图20191023171820\"></p>\n<p>点击最下面的git 就能唤出这个窗口，这个英文应该大家都能看懂吧，这个英文看不懂就退群吧，思考一下怎么上大学几个月就把高中英语忘完了。</p>\n<p>好了然后，你写了很多了，也提交了几次之后，你突然发现前面提交的那个有问题，不想提交了那咋办呢？ 只需<strong>点    点    点</strong></p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023172756.png\" class=\"φcy\" alt=\"TIM截图20191023172756\"></p>\n<p>那就退到你刚刚新提交的那个版本前面一个呗，例如我觉得<code>test2</code>有问题那我就右键点击<code>test1</code>，然后</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023173110.png\" class=\"φcy\" alt=\"TIM截图20191023173110\"></p>\n<p>这样你刚刚的修改的提交就没了，但是如果你选择的时mix的话，你的修改还是会在的，变成没有提交状态了，我来解释一下这四个选项。</p>\n<ul><li><code>soft</code>重置版本库但是暂存区和工作区不会</li><li><code>mixed</code>会充值版本库和暂存区，但是工作区还在</li><li><code>hard</code>会重置版本库暂存区工作区（危险操作，但是找都是可以找回来的）</li><li><code>keep</code>重置所有的但是会保留文件</li></ul><p>如果你完全不要本地的所有更改了，可以直接hard到最近一个commit（危险操作，虽然我经常做<img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/v2-a11eadf17f85c2caef8ac2e391d0cf69_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">）</p>\n<p>好了现在假如你完成了你突发奇想的功能感觉还不错，想把test分支合并到主分支要咋办呢？ 还是<strong>点    点    点</strong></p>\n<p>先切换回主分支</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023175603.png\" class=\"φcy\" alt=\"TIM截图20191023175603\"></p>\n<p>然后</p>\n<p>点击test分支</p>\n<p><img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/TIM%E6%88%AA%E5%9B%BE20191023175637.png\" class=\"φcy\" alt=\"TIM截图20191023175637\"></p>\n<p>这样就合并啦</p>\n<p>这也太简单了吧<img src=\"/2019/12/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8idea%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%93%8D%E4%BD%9Cgit/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n","date_formatted":{"ll":"Dec 30, 2019","L":"12/30/2019","MM-DD":"12-30"},"plink":"https://treeeeeeee.github.io/2019/12/30/git常用命令以及如何在idea上可视化操作git/","type":"post","toc":[{"id":"git","title":"git","index":"1","children":[{"id":"概念","title":"概念","index":"1.1","children":[{"id":"工作区（working-directory）","title":"工作区（Working Directory）","index":"1.1.1"},{"id":"暂存区（stage-或-index）","title":"暂存区（Stage 或 Index）","index":"1.1.2"},{"id":"版本库（commit-history）","title":"版本库（commit History）","index":"1.1.3"}]},{"id":"常用命令讲解","title":"常用命令讲解","index":"1.2","children":[{"id":"git-常用命令汇总","title":"Git 常用命令汇总","index":"1.2.1","children":[{"id":"1、远程仓库相关命令","title":"1、远程仓库相关命令","index":"1.2.1.1"},{"id":"2、分支branch操作相关命令","title":"2、分支(branch)操作相关命令","index":"1.2.1.2"},{"id":"3、版本tag操作相关命令","title":"3、版本(tag)操作相关命令","index":"1.2.1.3"},{"id":"4、忽略一些文件、文件夹不提交","title":"4、忽略一些文件、文件夹不提交","index":"1.2.1.4"}]},{"id":"附页：-git-常用命令速查","title":"附页： Git 常用命令速查","index":"1.2.2"}]}]},{"id":"github注册","title":"github注册","index":"2"},{"id":"接下来我们来偷懒","title":"接下来我们来偷懒","index":"3"}]},{"title":".gitignore忽略文件总结","author":"Jon","date":"2019-10-03T17:23:00.000Z","_content":"\n## 语法归纳\n\n```bash\n#               表示此为注释,将被Git忽略\n*.a             表示忽略所有 .a 结尾的文件\n!lib.a          表示但lib.a除外\n/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO\nbuild/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；\ndoc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt\n \nbin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件\n/bin:           表示忽略根目录下的bin文件\n/*.c:           表示忽略cat.c，不忽略 build/cat.c\ndebug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj\n**/foo:         表示忽略/foo,a/foo,a/b/foo等\na/**/b:         表示忽略a/b, a/x/b,a/x/y/b等\n!/bin/run.sh    表示不忽略bin目录下的run.sh文件\n*.log:          表示忽略所有 .log 文件\nconfig.php:     表示忽略当前路径的 config.php 文件\n \n/mtk/           表示过滤整个文件夹\n*.zip           表示过滤所有.zip文件\n/mtk/do.c       表示过滤某个具体文件\n \n被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。\n \n需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：\n!*.zip\n!/mtk/one.txt\n \n唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？\n想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：\n/mtk/*\n!/mtk/one.txt\n \n假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！\n注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！\n \n----------------------------------------------------------------------------------\n还有一些规则如下：\nfd1/*\n说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；\n \n/fd1/*\n说明：忽略根目录下的 /fd1/ 目录的全部内容；\n \n/*\n!.gitignore\n!/fw/ \n/fw/*\n!/fw/bin/\n!/fw/sf/\n说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。\n```\n\n## 从版本库去除并忽略提交\n\n### 先执行以下任意删除命令\n\n```bash\ngit rm file\t\t\t\t\t\t# 从版本库删除，并删除本地文件\ngit rm --cached file\t\t\t# 从版本库删除文件并保留本地文件\ngit rm -r --cached loggers \t \t# -r 是允许递归删除，当要删除的是文件夹的时候有用\n```\n\n### 在.gitignore文件中添加\n\n\n\n## 提醒\n\n### .gitignore忽略规则的匹配语法\n\n每一行的忽略规则的语法如下：\n\n- **空格**不匹配任意文件，可作为分隔符，可用反斜杠转义\n- 以“**＃**”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。\n- 可以使用标准的**glob**模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。\n- 以斜杠\"**/**\"开头表示目录；\"/\"结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；\"/\"开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。\n- 以星号\"*****\"通配多个字符，即匹配多个任意字符；使用两个星号\"***\\***\" 表示匹配任意中间目录，比如`a/**/z`可以匹配 a/z, a/b/z 或 a/b/c/z等。\n- 以问号\"**?**\"通配单个字符，即匹配一个任意字符；\n- 以方括号\"**[]**\"包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。\n- 以叹号\"**!**\"表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：**如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用\"!\"规则是不起作用的**。也就是说\"!\"开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用\"!\"也不会再次被包含。可以使用反斜杠进行转义。\n\n**需要谨记**：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；\n\n\n\n### .gitignore忽略规则的优先级\n\n在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：\n\n* 从命令行中读取可用的忽略规则\n* 当前目录定义的规则\n* 父级目录定义的规则，依次递推\n* $GIT_DIR/info/exclude 文件中定义的规则\n* core.excludesfile中定义的全局规则","source":"_posts/gitignore忽略文件总结.md","raw":"\n\ntitle: .gitignore忽略文件总结\nauthor: Jon\ntags:\n\n  - 知识就是力量\ncategories:\n  - Git学习备忘\ndate: 2019-10-04 01:23:00\n\n---\n\n## 语法归纳\n\n```bash\n#               表示此为注释,将被Git忽略\n*.a             表示忽略所有 .a 结尾的文件\n!lib.a          表示但lib.a除外\n/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO\nbuild/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；\ndoc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt\n \nbin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件\n/bin:           表示忽略根目录下的bin文件\n/*.c:           表示忽略cat.c，不忽略 build/cat.c\ndebug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj\n**/foo:         表示忽略/foo,a/foo,a/b/foo等\na/**/b:         表示忽略a/b, a/x/b,a/x/y/b等\n!/bin/run.sh    表示不忽略bin目录下的run.sh文件\n*.log:          表示忽略所有 .log 文件\nconfig.php:     表示忽略当前路径的 config.php 文件\n \n/mtk/           表示过滤整个文件夹\n*.zip           表示过滤所有.zip文件\n/mtk/do.c       表示过滤某个具体文件\n \n被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。\n \n需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：\n!*.zip\n!/mtk/one.txt\n \n唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？\n想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：\n/mtk/*\n!/mtk/one.txt\n \n假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！\n注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！\n \n----------------------------------------------------------------------------------\n还有一些规则如下：\nfd1/*\n说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；\n \n/fd1/*\n说明：忽略根目录下的 /fd1/ 目录的全部内容；\n \n/*\n!.gitignore\n!/fw/ \n/fw/*\n!/fw/bin/\n!/fw/sf/\n说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。\n```\n\n## 从版本库去除并忽略提交\n\n### 先执行以下任意删除命令\n\n```bash\ngit rm file\t\t\t\t\t\t# 从版本库删除，并删除本地文件\ngit rm --cached file\t\t\t# 从版本库删除文件并保留本地文件\ngit rm -r --cached loggers \t \t# -r 是允许递归删除，当要删除的是文件夹的时候有用\n```\n\n### 在.gitignore文件中添加\n\n\n\n## 提醒\n\n### .gitignore忽略规则的匹配语法\n\n每一行的忽略规则的语法如下：\n\n- **空格**不匹配任意文件，可作为分隔符，可用反斜杠转义\n- 以“**＃**”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。\n- 可以使用标准的**glob**模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。\n- 以斜杠\"**/**\"开头表示目录；\"/\"结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；\"/\"开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。\n- 以星号\"*****\"通配多个字符，即匹配多个任意字符；使用两个星号\"***\\***\" 表示匹配任意中间目录，比如`a/**/z`可以匹配 a/z, a/b/z 或 a/b/c/z等。\n- 以问号\"**?**\"通配单个字符，即匹配一个任意字符；\n- 以方括号\"**[]**\"包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。\n- 以叹号\"**!**\"表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：**如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用\"!\"规则是不起作用的**。也就是说\"!\"开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用\"!\"也不会再次被包含。可以使用反斜杠进行转义。\n\n**需要谨记**：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；\n\n\n\n### .gitignore忽略规则的优先级\n\n在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：\n\n* 从命令行中读取可用的忽略规则\n* 当前目录定义的规则\n* 父级目录定义的规则，依次递推\n* $GIT_DIR/info/exclude 文件中定义的规则\n* core.excludesfile中定义的全局规则","slug":"gitignore忽略文件总结","published":1,"updated":"2019-12-30T02:50:50.751Z","comments":1,"layout":"post","photos":[],"link":"2019/10/04/gitignore忽略文件总结","_id":"ck8jl8qid000fw0w0f9czfatd","content":"<h2 id=\"语法归纳\">语法归纳<a href=\"#语法归纳\" title=\"语法归纳\"></a></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#               表示此为注释,将被Git忽略</span></span><br><span class=\"line\">*.a             表示忽略所有 .a 结尾的文件</span><br><span class=\"line\">!lib.a          表示但lib.a除外</span><br><span class=\"line\">/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class=\"line\">build/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；</span><br><span class=\"line\">doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt</span><br><span class=\"line\"> </span><br><span class=\"line\">bin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件</span><br><span class=\"line\">/bin:           表示忽略根目录下的bin文件</span><br><span class=\"line\">/*.c:           表示忽略cat.c，不忽略 build/cat.c</span><br><span class=\"line\">debug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj</span><br><span class=\"line\">**/foo:         表示忽略/foo,a/foo,a/b/foo等</span><br><span class=\"line\">a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等</span><br><span class=\"line\">!/bin/run.sh    表示不忽略bin目录下的run.sh文件</span><br><span class=\"line\">*.<span class=\"built_in\">log</span>:          表示忽略所有 .<span class=\"built_in\">log</span> 文件</span><br><span class=\"line\">config.php:     表示忽略当前路径的 config.php 文件</span><br><span class=\"line\"> </span><br><span class=\"line\">/mtk/           表示过滤整个文件夹</span><br><span class=\"line\">*.zip           表示过滤所有.zip文件</span><br><span class=\"line\">/mtk/do.c       表示过滤某个具体文件</span><br><span class=\"line\"> </span><br><span class=\"line\">被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。</span><br><span class=\"line\"> </span><br><span class=\"line\">需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：</span><br><span class=\"line\">!*.zip</span><br><span class=\"line\">!/mtk/one.txt</span><br><span class=\"line\"> </span><br><span class=\"line\">唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？</span><br><span class=\"line\">想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：</span><br><span class=\"line\">/mtk/*</span><br><span class=\"line\">!/mtk/one.txt</span><br><span class=\"line\"> </span><br><span class=\"line\">假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</span><br><span class=\"line\">注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！</span><br><span class=\"line\"> </span><br><span class=\"line\">----------------------------------------------------------------------------------</span><br><span class=\"line\">还有一些规则如下：</span><br><span class=\"line\">fd1/*</span><br><span class=\"line\">说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；</span><br><span class=\"line\"> </span><br><span class=\"line\">/fd1/*</span><br><span class=\"line\">说明：忽略根目录下的 /fd1/ 目录的全部内容；</span><br><span class=\"line\"> </span><br><span class=\"line\">/*</span><br><span class=\"line\">!.gitignore</span><br><span class=\"line\">!/fw/ </span><br><span class=\"line\">/fw/*</span><br><span class=\"line\">!/fw/bin/</span><br><span class=\"line\">!/fw/sf/</span><br><span class=\"line\">说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。</span><br></pre></td></tr></table></figure><h2 id=\"从版本库去除并忽略提交\">从版本库去除并忽略提交<a href=\"#从版本库去除并忽略提交\" title=\"从版本库去除并忽略提交\"></a></h2><h3 id=\"先执行以下任意删除命令\">先执行以下任意删除命令<a href=\"#先执行以下任意删除命令\" title=\"先执行以下任意删除命令\"></a></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm file\t\t\t\t\t\t<span class=\"comment\"># 从版本库删除，并删除本地文件</span></span><br><span class=\"line\">git rm --cached file\t\t\t<span class=\"comment\"># 从版本库删除文件并保留本地文件</span></span><br><span class=\"line\">git rm -r --cached loggers \t \t<span class=\"comment\"># -r 是允许递归删除，当要删除的是文件夹的时候有用</span></span><br></pre></td></tr></table></figure><h3 id=\"在gitignore文件中添加\">在.gitignore文件中添加<a href=\"#在gitignore文件中添加\" title=\"在.gitignore文件中添加\"></a></h3><h2 id=\"提醒\">提醒<a href=\"#提醒\" title=\"提醒\"></a></h2><h3 id=\"gitignore忽略规则的匹配语法\">.gitignore忽略规则的匹配语法<a href=\"#gitignore忽略规则的匹配语法\" title=\".gitignore忽略规则的匹配语法\"></a></h3><p>每一行的忽略规则的语法如下：</p>\n<ul><li><strong>空格</strong>不匹配任意文件，可作为分隔符，可用反斜杠转义</li><li>以“<strong>＃</strong>”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。</li><li>可以使用标准的<strong>glob</strong>模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。</li><li>以斜杠”<strong>/</strong>“开头表示目录；”/“结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；”/“开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。</li><li>以星号”<strong><em>**”通配多个字符，即匹配多个任意字符；使用两个星号”</em></strong>*<strong>“ 表示匹配任意中间目录，比如`a/</strong>/z`可以匹配 a/z, a/b/z 或 a/b/c/z等。</li><li>以问号”<strong>?</strong>“通配单个字符，即匹配一个任意字符；</li><li>以方括号”<strong>[]</strong>“包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。</li><li>以叹号”<strong>!</strong>“表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：<strong>如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用”!”规则是不起作用的</strong>。也就是说”!”开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用”!”也不会再次被包含。可以使用反斜杠进行转义。</li></ul><p><strong>需要谨记</strong>：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p>\n<h3 id=\"gitignore忽略规则的优先级\">.gitignore忽略规则的优先级<a href=\"#gitignore忽略规则的优先级\" title=\".gitignore忽略规则的优先级\"></a></h3><p>在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：</p>\n<ul><li>从命令行中读取可用的忽略规则</li><li>当前目录定义的规则</li><li>父级目录定义的规则，依次递推</li><li>$GIT_DIR/info/exclude 文件中定义的规则</li><li>core.excludesfile中定义的全局规则</li></ul>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"语法归纳\">语法归纳<a href=\"#语法归纳\" title=\"语法归纳\"></a></h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#               表示此为注释,将被Git忽略</span></span><br><span class=\"line\">*.a             表示忽略所有 .a 结尾的文件</span><br><span class=\"line\">!lib.a          表示但lib.a除外</span><br><span class=\"line\">/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class=\"line\">build/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；</span><br><span class=\"line\">doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt</span><br><span class=\"line\"> </span><br><span class=\"line\">bin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件</span><br><span class=\"line\">/bin:           表示忽略根目录下的bin文件</span><br><span class=\"line\">/*.c:           表示忽略cat.c，不忽略 build/cat.c</span><br><span class=\"line\">debug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj</span><br><span class=\"line\">**/foo:         表示忽略/foo,a/foo,a/b/foo等</span><br><span class=\"line\">a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等</span><br><span class=\"line\">!/bin/run.sh    表示不忽略bin目录下的run.sh文件</span><br><span class=\"line\">*.<span class=\"built_in\">log</span>:          表示忽略所有 .<span class=\"built_in\">log</span> 文件</span><br><span class=\"line\">config.php:     表示忽略当前路径的 config.php 文件</span><br><span class=\"line\"> </span><br><span class=\"line\">/mtk/           表示过滤整个文件夹</span><br><span class=\"line\">*.zip           表示过滤所有.zip文件</span><br><span class=\"line\">/mtk/do.c       表示过滤某个具体文件</span><br><span class=\"line\"> </span><br><span class=\"line\">被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。</span><br><span class=\"line\"> </span><br><span class=\"line\">需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：</span><br><span class=\"line\">!*.zip</span><br><span class=\"line\">!/mtk/one.txt</span><br><span class=\"line\"> </span><br><span class=\"line\">唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？</span><br><span class=\"line\">想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：</span><br><span class=\"line\">/mtk/*</span><br><span class=\"line\">!/mtk/one.txt</span><br><span class=\"line\"> </span><br><span class=\"line\">假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</span><br><span class=\"line\">注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！</span><br><span class=\"line\"> </span><br><span class=\"line\">----------------------------------------------------------------------------------</span><br><span class=\"line\">还有一些规则如下：</span><br><span class=\"line\">fd1/*</span><br><span class=\"line\">说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；</span><br><span class=\"line\"> </span><br><span class=\"line\">/fd1/*</span><br><span class=\"line\">说明：忽略根目录下的 /fd1/ 目录的全部内容；</span><br><span class=\"line\"> </span><br><span class=\"line\">/*</span><br><span class=\"line\">!.gitignore</span><br><span class=\"line\">!/fw/ </span><br><span class=\"line\">/fw/*</span><br><span class=\"line\">!/fw/bin/</span><br><span class=\"line\">!/fw/sf/</span><br><span class=\"line\">说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。</span><br></pre></td></tr></table></figure><h2 id=\"从版本库去除并忽略提交\">从版本库去除并忽略提交<a href=\"#从版本库去除并忽略提交\" title=\"从版本库去除并忽略提交\"></a></h2><h3 id=\"先执行以下任意删除命令\">先执行以下任意删除命令<a href=\"#先执行以下任意删除命令\" title=\"先执行以下任意删除命令\"></a></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm file\t\t\t\t\t\t<span class=\"comment\"># 从版本库删除，并删除本地文件</span></span><br><span class=\"line\">git rm --cached file\t\t\t<span class=\"comment\"># 从版本库删除文件并保留本地文件</span></span><br><span class=\"line\">git rm -r --cached loggers \t \t<span class=\"comment\"># -r 是允许递归删除，当要删除的是文件夹的时候有用</span></span><br></pre></td></tr></table></figure><h3 id=\"在gitignore文件中添加\">在.gitignore文件中添加<a href=\"#在gitignore文件中添加\" title=\"在.gitignore文件中添加\"></a></h3><h2 id=\"提醒\">提醒<a href=\"#提醒\" title=\"提醒\"></a></h2><h3 id=\"gitignore忽略规则的匹配语法\">.gitignore忽略规则的匹配语法<a href=\"#gitignore忽略规则的匹配语法\" title=\".gitignore忽略规则的匹配语法\"></a></h3><p>每一行的忽略规则的语法如下：</p>\n<ul><li><strong>空格</strong>不匹配任意文件，可作为分隔符，可用反斜杠转义</li><li>以“<strong>＃</strong>”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。</li><li>可以使用标准的<strong>glob</strong>模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。</li><li>以斜杠”<strong>/</strong>“开头表示目录；”/“结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；”/“开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。</li><li>以星号”<strong><em>**”通配多个字符，即匹配多个任意字符；使用两个星号”</em></strong>*<strong>“ 表示匹配任意中间目录，比如`a/</strong>/z`可以匹配 a/z, a/b/z 或 a/b/c/z等。</li><li>以问号”<strong>?</strong>“通配单个字符，即匹配一个任意字符；</li><li>以方括号”<strong>[]</strong>“包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。</li><li>以叹号”<strong>!</strong>“表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：<strong>如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用”!”规则是不起作用的</strong>。也就是说”!”开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用”!”也不会再次被包含。可以使用反斜杠进行转义。</li></ul><p><strong>需要谨记</strong>：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p>\n<h3 id=\"gitignore忽略规则的优先级\">.gitignore忽略规则的优先级<a href=\"#gitignore忽略规则的优先级\" title=\".gitignore忽略规则的优先级\"></a></h3><p>在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：</p>\n<ul><li>从命令行中读取可用的忽略规则</li><li>当前目录定义的规则</li><li>父级目录定义的规则，依次递推</li><li>$GIT_DIR/info/exclude 文件中定义的规则</li><li>core.excludesfile中定义的全局规则</li></ul>","date_formatted":{"ll":"Oct 4, 2019","L":"10/04/2019","MM-DD":"10-04"},"plink":"https://treeeeeeee.github.io/2019/10/04/gitignore忽略文件总结/","type":"post","toc":[{"id":"语法归纳","title":"语法归纳","index":"1"},{"id":"从版本库去除并忽略提交","title":"从版本库去除并忽略提交","index":"2","children":[{"id":"先执行以下任意删除命令","title":"先执行以下任意删除命令","index":"2.1"},{"id":"在gitignore文件中添加","title":"在.gitignore文件中添加","index":"2.2"}]},{"id":"提醒","title":"提醒","index":"3","children":[{"id":"gitignore忽略规则的匹配语法","title":".gitignore忽略规则的匹配语法","index":"3.1"},{"id":"gitignore忽略规则的优先级","title":".gitignore忽略规则的优先级","index":"3.2"}]}]},{"title":"hexo+admin+windows服务器的综合博客平台","author":"Jon","date":"2019-10-03T08:43:00.000Z","_content":"# windows下的hexo+github博客搭建\n\n## 博客搭建\n\n不多说这里放上[大神的知乎](https://zhuanlan.zhihu.com/p/35668237)，点击自己按照流程来做就好了，下面我做一个归纳整理，也留作备份。\n\n### 安装Node.js\n\n> * [windows下载链接](https://nodejs.org/dist/v12.14.0/node-v12.14.0-x64.msi)\n>\n> * 下载之后一路next就好，环境变量默认会把帮你配好\n>\n> * 最后安装好之后，按`Win+R`打开命令提示符，输入`node -v`和`npm -v`，如果出现版本号，那么就安装成功了。\n> * 也有没有自动配的情况，可以手动配一下。\n\n### 添加国内镜像源\n\n> 如果没有K X S W(这是啥大家都明白吧)的话，可以使用阿里的国内镜像进行加速。\n>\n> ```bash\n> npm config set registry https://registry.npm.taobao.org\n> ```\n\n### 安装Git\n\n> * [Git的下载链接](https://git-scm.com/download/win)\n> * 安装选项还是全部默认，只不过最后一步添加路径时选择`Use Git from the Windows Command Prompt`，这样我们就可以直接在命令提示符里打开git了。\n> * 安装完成后在命令提示符中输入`git --version`验证是否安装成功。\n> * 同样如果没有找到版本号需要手动配置\n\n### 注册Github账号\n\n> * [注册地址](https://link.zhihu.com/?target=https%3A//github.com/)\n>\n> * 注册完成之后进入主页\n>\n> * ![Screenshot](hexo-admin-windows-服务器的综合博客平台/Screenshot.png)\n>\n>   点击新建项目\n>\n> * 项目名称是你的github用户名加.github.io \n>\n>   > 例如: `XXXXX.github.io`\n>   >\n>   > 同时也可以勾选一下Redme.md\n>\n>   ![new p](C:\\data\\Treeeeeeee.github.io\\blog\\source\\_posts\\hexo-admin-windows-服务器的综合博客平台\\new p.png)\n>\n> * 然后按照下面的流程你就可以获得一个最简单的博客\n>\n>   * ![m](hexo-admin-windows-服务器的综合博客平台/m.png)\n>\n>   * ![2](hexo-admin-windows-服务器的综合博客平台/2.png)\n>   * ![3](hexo-admin-windows-服务器的综合博客平台/3.png)\n>   * 进去之后随便选一个\n\n### 安装Hexo\n\n在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在`D:\\study\\program\\blog`目录下。\n\n在该目录下右键点击`Git Bash Here`，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。\n\n定位到该目录下，输入`npm i hexo-cli -g`安装Hexo。会有几个报错，无视它就行。\n\n安装完后输入`hexo -v`验证是否安装成功。\n\n然后就要初始化我们的网站，输入`hexo init`初始化文件夹，接着输入`npm install`安装必备的组件。\n\n这样本地的网站配置也弄好啦，输入`hexo g`生成静态网页，然后输入`hexo s`打开本地服务器，然后浏览器打开[http://localhost:4000/](https://link.zhihu.com/?target=http%3A//localhost%3A4000/)，就可以看到我们的博客啦，效果如下：\n\n![TIM图片20191003174050](hexo-admin-windows-服务器的综合博客平台/TIM图片20191003174050.png)\n\n按`ctrl+c`关闭本地服务器。\n\n### 连接Github与本地\n\n首先右键打开git bash，然后输入下面命令：\n\n```bash\ngit config --global user.name \"godweiyang\"\ngit config --global user.email \"792321264@qq.com\"\n```\n\n用户名和邮箱根据你注册github的信息自行修改。\n\n然后生成密钥SSH key：\n\n```bash\nssh-keygen -t rsa -C \"792321264@qq.com\"\n```\n\n打开[github](https://link.zhihu.com/?target=http%3A//github.com/)，在头像下面点击`settings`，再点击`SSH and GPG keys`，新建一个SSH，名字随便。\n\ngit bash中输入\n\n```bash\ncat ~/.ssh/id_rsa.pub\n```\n\n将输出的内容复制到框中，点击确定保存。\n\n输入`ssh -T git@github.com`，如果如下图所示，出现你的用户名，那就成功了。\n\n打开博客根目录下的`_config.yml`文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。\n\n修改最后一行的配置：\n\n```bash\ndeploy:\n  type: git\n  repo: \n  branch: master\n```\n\nrepository或者repo修改为你自己的github项目地址\n\n> 我这里默认的是使用`ssh`，如果想使用`https`点击更换就好了\n>\n> * 我推荐使用ssh，毕竟你已经在你的github中添加了你本机的ssh，免得再输密码\n> * 如果不懂ssh可以先使用https，后面我们做服务器的自动git用ssh会更好，如果不需要，而且是在windows下使用的话那就`https`的吧，没啥关系，windows有记住密码的功能\n\n![TIM截图20191003175326](hexo-admin-windows-服务器的综合博客平台/TIM截图20191003175326.png)\n\n### 写文章、发布文章\n\n首先在博客根目录下右键打开git bash，安装一个扩展`npm i hexo-deployer-git`。\n\n然后输入`hexo new post \"article title\"`，新建一篇文章。\n\n> article title 替换成你要写的文章的名字，需要注意一下：\n>\n> * 最好使用英文，使用中文的话博客的url会非常长\n>\n> * 如果想插入图片的话，打开你的博客目录里面的`_config.yml`找到`post_asset_folder: `属性，并复制未`true`，这样生成一篇新文章时，会在\n>\n>   ```\n>   \\source\\_posts\n>   ```\n>\n>   目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等。这样在文章中插入图片使用相对路径就可以即在本地书写的时候看到图片，又在生成的博客中看到，例如：\n>\n>   ![TIM截图20191003180656](hexo-admin-windows-服务器的综合博客平台/TIM截图20191003180656.png)\n>\n>   在文章中直接这样插入，就可以完美插入图片。详细可以借鉴我[另外一篇博客](https://treeeeeeee.github.io/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87)\n>\n>   ![TIM截图20191003180755](hexo-admin-windows-服务器的综合博客平台/TIM截图20191003180755.png)\n>\n> * 这里推荐一个超好用加方便的markdown编辑软件`Typora`，而且恰好支持这种图片资源文件，设置一下可以把任意来源图片直接弄到对应文件夹\n>\n>   > \n>   >\n>   > <img src=\"hexo-admin-windows-服务器的综合博客平台/TIM截图20191003183937.png\" alt=\"TIM截图20191003183937\" style=\"zoom: 67%;\" />\n>   >\n>   > ![TIM截图20191003184214](hexo-admin-windows-服务器的综合博客平台/TIM截图20191003184214.png)\n>   >\n>   > **这样设置以后你不管是从网络上来的图片还是任意地方拖动的进来的图片都会自动给你放到这个文件夹**\n\n然后打开`D:\\study\\program\\blog\\source\\_posts`的目录，可以发现下面多了一个文件夹和一个`.md`文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。\n\n编写完markdown文件后，根目录下输入`hexo g`生成静态网页，然后输入`hexo s`可以本地预览效果，最后输入`hexo d`上传到github上。这时打开你的github.io主页就能看到发布的文章啦。\n\n### 绑定域名\n\n现在默认的域名还是`xxx.github.io`，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。\n\n以我的百度云为例，如下图所示，添加两条解析记录：\n\n![img](hexo-admin-windows-服务器的综合博客平台/v2-e11377329d5cef129c0aefd10eaa1607_hd.jpg)\n\n\n\n然后打开你的github博客项目，点击`settings`，拉到下面`Custom domain`处，填上你自己的域名，保存：\n\n![img](hexo-admin-windows-服务器的综合博客平台/v2-8125794bbf0055917b820178489c7b0f_hd.jpg)\n\n\n\n这时候你的项目根目录应该会出现一个名为`CNAME`的文件了。如果没有的话，打开你本地博客`/source`目录，我的是`D:\\study\\program\\blog\\source`，新建`CNAME`文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行`hexo g`、`hexo d`上传到github。\n\n### 备份博客源文件\n\n有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。\n\n* **我的备份方法**\n\n  > 随便找个文件夹，右键打开git bash，依次执行以下命令\n  >\n  > ```\n  > git clone 你的博客仓库地址\n  > git checkout -b backup\n  > ```\n  >\n  > 然后删除你拉下来的所有东西文件夹，如果你开了隐藏文件夹也可见的话别把`.git`文件夹删除了，如果没开就放心删除所有文件吧（看见`.git`别动就对了）\n  >\n  > 然后把你你的整个博客文件夹移动到这里，并删除你博客文件下里面所有叫`.gitignore`的文件，通常来说，博客源码根目录有一个，主题文件夹里面都有\n  >\n  > > `.gitignore`文件是用来说明那些东西不被git push的，具体请自行百度\n  >\n  > 然后继续依次执行以下命令\n  >\n  > ```\n  > git add .\n  > git commit -s -m \"backup\"\n  > git push\n  > ```\n  >\n  > 等待完成就可以在任何地方直接拉下来使用了，在其他地方使用有以下几个要注意的：\n  >\n  > * 环境必须安装这个没得说\n  >\n  > * 如果你是使用shh来部署的项目需要把这台设备的生成的ssh添加到你的github账号里\n  >\n  >   > 指的是你前面属性`repo : `是用的https的还是ssh的\n\n* 其他备份方法(该内容是粘贴复制)\n\n  > 首先在github博客仓库下新建一个分支`hexo`，然后`git clone`到本地，把`.git`文件夹拿出来，放在博客根目录下。\n  >\n  > 然后`git branch -b hexo`切换到`hexo`分支，然后`git add .`，然后`git commit -m \"xxx\"`，最后`git push origin hexo`提交就行了。\n\n### 博客源代码下载\n\n### 个性化设置（matery主题）\n\n### 常见问题及解答（FAQ）\n\n## 个性化设置|更换主题|\n\n### 效果图\n\n![TIM截图20191003184704](hexo-admin-windows-服务器的综合博客平台/TIM截图20191003184704.png)\n\n[我的博客地址](https://treeeeeeee.github.io)有什么问题可以在文章下评论留言\n\n### inside主题\n\n* 直接下载源码放到你的博客源码目录的themes目录里面，并修改`_config.yml`文件中`theme: `属性，然后执行：\n\n  ```bash\n  hexo g\n  hexo s\n  ```\n\n  浏览器访问：localhost:4000 就能直接看到效果了\n\n* 具体配置我就不详细说明了可以去看主题制作者的博客：[链接](https://blog.oniuo.com/theme-inside)\n\n\n\n\n\n","source":"_posts/hexo-admin-windows-服务器的综合博客平台.md","raw":"title: hexo+admin+windows服务器的综合博客平台\nauthor: Jon\n\ntags:\n\n  - 踩坑\n\n  - 浪费了大好青春\ncategories:\n\n  - 兴趣\n\ndate: 2019-10-03 16:43:00\n\n---\n# windows下的hexo+github博客搭建\n\n## 博客搭建\n\n不多说这里放上[大神的知乎](https://zhuanlan.zhihu.com/p/35668237)，点击自己按照流程来做就好了，下面我做一个归纳整理，也留作备份。\n\n### 安装Node.js\n\n> * [windows下载链接](https://nodejs.org/dist/v12.14.0/node-v12.14.0-x64.msi)\n>\n> * 下载之后一路next就好，环境变量默认会把帮你配好\n>\n> * 最后安装好之后，按`Win+R`打开命令提示符，输入`node -v`和`npm -v`，如果出现版本号，那么就安装成功了。\n> * 也有没有自动配的情况，可以手动配一下。\n\n### 添加国内镜像源\n\n> 如果没有K X S W(这是啥大家都明白吧)的话，可以使用阿里的国内镜像进行加速。\n>\n> ```bash\n> npm config set registry https://registry.npm.taobao.org\n> ```\n\n### 安装Git\n\n> * [Git的下载链接](https://git-scm.com/download/win)\n> * 安装选项还是全部默认，只不过最后一步添加路径时选择`Use Git from the Windows Command Prompt`，这样我们就可以直接在命令提示符里打开git了。\n> * 安装完成后在命令提示符中输入`git --version`验证是否安装成功。\n> * 同样如果没有找到版本号需要手动配置\n\n### 注册Github账号\n\n> * [注册地址](https://link.zhihu.com/?target=https%3A//github.com/)\n>\n> * 注册完成之后进入主页\n>\n> * ![Screenshot](hexo-admin-windows-服务器的综合博客平台/Screenshot.png)\n>\n>   点击新建项目\n>\n> * 项目名称是你的github用户名加.github.io \n>\n>   > 例如: `XXXXX.github.io`\n>   >\n>   > 同时也可以勾选一下Redme.md\n>\n>   ![new p](C:\\data\\Treeeeeeee.github.io\\blog\\source\\_posts\\hexo-admin-windows-服务器的综合博客平台\\new p.png)\n>\n> * 然后按照下面的流程你就可以获得一个最简单的博客\n>\n>   * ![m](hexo-admin-windows-服务器的综合博客平台/m.png)\n>\n>   * ![2](hexo-admin-windows-服务器的综合博客平台/2.png)\n>   * ![3](hexo-admin-windows-服务器的综合博客平台/3.png)\n>   * 进去之后随便选一个\n\n### 安装Hexo\n\n在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在`D:\\study\\program\\blog`目录下。\n\n在该目录下右键点击`Git Bash Here`，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。\n\n定位到该目录下，输入`npm i hexo-cli -g`安装Hexo。会有几个报错，无视它就行。\n\n安装完后输入`hexo -v`验证是否安装成功。\n\n然后就要初始化我们的网站，输入`hexo init`初始化文件夹，接着输入`npm install`安装必备的组件。\n\n这样本地的网站配置也弄好啦，输入`hexo g`生成静态网页，然后输入`hexo s`打开本地服务器，然后浏览器打开[http://localhost:4000/](https://link.zhihu.com/?target=http%3A//localhost%3A4000/)，就可以看到我们的博客啦，效果如下：\n\n![TIM图片20191003174050](hexo-admin-windows-服务器的综合博客平台/TIM图片20191003174050.png)\n\n按`ctrl+c`关闭本地服务器。\n\n### 连接Github与本地\n\n首先右键打开git bash，然后输入下面命令：\n\n```bash\ngit config --global user.name \"godweiyang\"\ngit config --global user.email \"792321264@qq.com\"\n```\n\n用户名和邮箱根据你注册github的信息自行修改。\n\n然后生成密钥SSH key：\n\n```bash\nssh-keygen -t rsa -C \"792321264@qq.com\"\n```\n\n打开[github](https://link.zhihu.com/?target=http%3A//github.com/)，在头像下面点击`settings`，再点击`SSH and GPG keys`，新建一个SSH，名字随便。\n\ngit bash中输入\n\n```bash\ncat ~/.ssh/id_rsa.pub\n```\n\n将输出的内容复制到框中，点击确定保存。\n\n输入`ssh -T git@github.com`，如果如下图所示，出现你的用户名，那就成功了。\n\n打开博客根目录下的`_config.yml`文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。\n\n修改最后一行的配置：\n\n```bash\ndeploy:\n  type: git\n  repo: \n  branch: master\n```\n\nrepository或者repo修改为你自己的github项目地址\n\n> 我这里默认的是使用`ssh`，如果想使用`https`点击更换就好了\n>\n> * 我推荐使用ssh，毕竟你已经在你的github中添加了你本机的ssh，免得再输密码\n> * 如果不懂ssh可以先使用https，后面我们做服务器的自动git用ssh会更好，如果不需要，而且是在windows下使用的话那就`https`的吧，没啥关系，windows有记住密码的功能\n\n![TIM截图20191003175326](hexo-admin-windows-服务器的综合博客平台/TIM截图20191003175326.png)\n\n### 写文章、发布文章\n\n首先在博客根目录下右键打开git bash，安装一个扩展`npm i hexo-deployer-git`。\n\n然后输入`hexo new post \"article title\"`，新建一篇文章。\n\n> article title 替换成你要写的文章的名字，需要注意一下：\n>\n> * 最好使用英文，使用中文的话博客的url会非常长\n>\n> * 如果想插入图片的话，打开你的博客目录里面的`_config.yml`找到`post_asset_folder: `属性，并复制未`true`，这样生成一篇新文章时，会在\n>\n>   ```\n>   \\source\\_posts\n>   ```\n>\n>   目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等。这样在文章中插入图片使用相对路径就可以即在本地书写的时候看到图片，又在生成的博客中看到，例如：\n>\n>   ![TIM截图20191003180656](hexo-admin-windows-服务器的综合博客平台/TIM截图20191003180656.png)\n>\n>   在文章中直接这样插入，就可以完美插入图片。详细可以借鉴我[另外一篇博客](https://treeeeeeee.github.io/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87)\n>\n>   ![TIM截图20191003180755](hexo-admin-windows-服务器的综合博客平台/TIM截图20191003180755.png)\n>\n> * 这里推荐一个超好用加方便的markdown编辑软件`Typora`，而且恰好支持这种图片资源文件，设置一下可以把任意来源图片直接弄到对应文件夹\n>\n>   > \n>   >\n>   > <img src=\"hexo-admin-windows-服务器的综合博客平台/TIM截图20191003183937.png\" alt=\"TIM截图20191003183937\" style=\"zoom: 67%;\" />\n>   >\n>   > ![TIM截图20191003184214](hexo-admin-windows-服务器的综合博客平台/TIM截图20191003184214.png)\n>   >\n>   > **这样设置以后你不管是从网络上来的图片还是任意地方拖动的进来的图片都会自动给你放到这个文件夹**\n\n然后打开`D:\\study\\program\\blog\\source\\_posts`的目录，可以发现下面多了一个文件夹和一个`.md`文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。\n\n编写完markdown文件后，根目录下输入`hexo g`生成静态网页，然后输入`hexo s`可以本地预览效果，最后输入`hexo d`上传到github上。这时打开你的github.io主页就能看到发布的文章啦。\n\n### 绑定域名\n\n现在默认的域名还是`xxx.github.io`，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。\n\n以我的百度云为例，如下图所示，添加两条解析记录：\n\n![img](hexo-admin-windows-服务器的综合博客平台/v2-e11377329d5cef129c0aefd10eaa1607_hd.jpg)\n\n\n\n然后打开你的github博客项目，点击`settings`，拉到下面`Custom domain`处，填上你自己的域名，保存：\n\n![img](hexo-admin-windows-服务器的综合博客平台/v2-8125794bbf0055917b820178489c7b0f_hd.jpg)\n\n\n\n这时候你的项目根目录应该会出现一个名为`CNAME`的文件了。如果没有的话，打开你本地博客`/source`目录，我的是`D:\\study\\program\\blog\\source`，新建`CNAME`文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行`hexo g`、`hexo d`上传到github。\n\n### 备份博客源文件\n\n有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。\n\n* **我的备份方法**\n\n  > 随便找个文件夹，右键打开git bash，依次执行以下命令\n  >\n  > ```\n  > git clone 你的博客仓库地址\n  > git checkout -b backup\n  > ```\n  >\n  > 然后删除你拉下来的所有东西文件夹，如果你开了隐藏文件夹也可见的话别把`.git`文件夹删除了，如果没开就放心删除所有文件吧（看见`.git`别动就对了）\n  >\n  > 然后把你你的整个博客文件夹移动到这里，并删除你博客文件下里面所有叫`.gitignore`的文件，通常来说，博客源码根目录有一个，主题文件夹里面都有\n  >\n  > > `.gitignore`文件是用来说明那些东西不被git push的，具体请自行百度\n  >\n  > 然后继续依次执行以下命令\n  >\n  > ```\n  > git add .\n  > git commit -s -m \"backup\"\n  > git push\n  > ```\n  >\n  > 等待完成就可以在任何地方直接拉下来使用了，在其他地方使用有以下几个要注意的：\n  >\n  > * 环境必须安装这个没得说\n  >\n  > * 如果你是使用shh来部署的项目需要把这台设备的生成的ssh添加到你的github账号里\n  >\n  >   > 指的是你前面属性`repo : `是用的https的还是ssh的\n\n* 其他备份方法(该内容是粘贴复制)\n\n  > 首先在github博客仓库下新建一个分支`hexo`，然后`git clone`到本地，把`.git`文件夹拿出来，放在博客根目录下。\n  >\n  > 然后`git branch -b hexo`切换到`hexo`分支，然后`git add .`，然后`git commit -m \"xxx\"`，最后`git push origin hexo`提交就行了。\n\n### 博客源代码下载\n\n### 个性化设置（matery主题）\n\n### 常见问题及解答（FAQ）\n\n## 个性化设置|更换主题|\n\n### 效果图\n\n![TIM截图20191003184704](hexo-admin-windows-服务器的综合博客平台/TIM截图20191003184704.png)\n\n[我的博客地址](https://treeeeeeee.github.io)有什么问题可以在文章下评论留言\n\n### inside主题\n\n* 直接下载源码放到你的博客源码目录的themes目录里面，并修改`_config.yml`文件中`theme: `属性，然后执行：\n\n  ```bash\n  hexo g\n  hexo s\n  ```\n\n  浏览器访问：localhost:4000 就能直接看到效果了\n\n* 具体配置我就不详细说明了可以去看主题制作者的博客：[链接](https://blog.oniuo.com/theme-inside)\n\n\n\n\n\n","slug":"hexo-admin-windows-服务器的综合博客平台","published":1,"updated":"2019-12-30T02:52:59.424Z","comments":1,"layout":"post","photos":[],"link":"2019/10/03/hexo-admin-windows-服务器的综合博客平台","_id":"ck8jl8qie000iw0w07fea5wuf","content":"<h1 id=\"windows下的hexogithub博客搭建\">windows下的hexo+github博客搭建<a href=\"#windows下的hexogithub博客搭建\" title=\"windows下的hexo+github博客搭建\"></a></h1><h2 id=\"博客搭建\">博客搭建<a href=\"#博客搭建\" title=\"博客搭建\"></a></h2><p>不多说这里放上<a href=\"https://zhuanlan.zhihu.com/p/35668237\" target=\"_blank\">大神的知乎</a>，点击自己按照流程来做就好了，下面我做一个归纳整理，也留作备份。</p>\n<h3 id=\"安装nodejs\">安装Node.js<a href=\"#安装nodejs\" title=\"安装Node.js\"></a></h3><blockquote>\n<ul><li><p><a href=\"https://nodejs.org/dist/v12.14.0/node-v12.14.0-x64.msi\" target=\"_blank\">windows下载链接</a></p></li><li><p>下载之后一路next就好，环境变量默认会把帮你配好</p></li><li><p>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p></li><li><p>也有没有自动配的情况，可以手动配一下。</p></li></ul></blockquote>\n<h3 id=\"添加国内镜像源\">添加国内镜像源<a href=\"#添加国内镜像源\" title=\"添加国内镜像源\"></a></h3><blockquote>\n<p>如果没有K X S W(这是啥大家都明白吧)的话，可以使用阿里的国内镜像进行加速。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></blockquote>\n<h3 id=\"安装git\">安装Git<a href=\"#安装git\" title=\"安装Git\"></a></h3><blockquote>\n<ul><li><a href=\"https://git-scm.com/download/win\" target=\"_blank\">Git的下载链接</a></li><li>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</li><li>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</li><li>同样如果没有找到版本号需要手动配置</li></ul></blockquote>\n<h3 id=\"注册github账号\">注册Github账号<a href=\"#注册github账号\" title=\"注册Github账号\"></a></h3><blockquote>\n<ul><li><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/\" target=\"_blank\">注册地址</a></p></li><li><p>注册完成之后进入主页</p></li><li><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/Screenshot.png\" alt=\"Screenshot\"></p><p>点击新建项目</p></li><li><p>项目名称是你的github用户名加.github.io</p><blockquote><p>例如: <code>XXXXX.github.io</code></p><p>同时也可以勾选一下Redme.md</p></blockquote><p>![new p](C:\\data\\Treeeeeeee.github.io\\blog\\source_posts\\hexo-admin-windows-服务器的综合博客平台\\new p.png)</p></li><li><p>然后按照下面的流程你就可以获得一个最简单的博客</p><ul><li><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/m.png\" alt=\"m\"></p></li><li><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/2.png\" alt=\"2\"></p></li><li><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/3.png\" alt=\"3\"></p></li><li><p>进去之后随便选一个</p></li></ul></li></ul></blockquote>\n<h3 id=\"安装hexo\">安装Hexo<a href=\"#安装hexo\" title=\"安装Hexo\"></a></h3><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在<code>D:\\study\\program\\blog</code>目录下。</p>\n<p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p>\n<p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p>\n<p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p>\n<p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p>\n<p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href=\"https://link.zhihu.com/?target=http%3A//localhost%3A4000/\" target=\"_blank\">http://localhost:4000/</a>，就可以看到我们的博客啦，效果如下：</p>\n<p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM图片20191003174050.png\" class=\"φcy\" alt=\"TIM图片20191003174050\"></p>\n<p>按<code>ctrl+c</code>关闭本地服务器。</p>\n<h3 id=\"连接github与本地\">连接Github与本地<a href=\"#连接github与本地\" title=\"连接Github与本地\"></a></h3><p>首先右键打开git bash，然后输入下面命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">\"godweiyang\"</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">\"792321264@qq.com\"</span></span><br></pre></td></tr></table></figure><p>用户名和邮箱根据你注册github的信息自行修改。</p>\n<p>然后生成密钥SSH key：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">\"792321264@qq.com\"</span></span><br></pre></td></tr></table></figure><p>打开<a href=\"https://link.zhihu.com/?target=http%3A//github.com/\" target=\"_blank\">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p>\n<p>git bash中输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>将输出的内容复制到框中，点击确定保存。</p>\n<p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p>\n<p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p>\n<p>修改最后一行的配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: </span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure><p>repository或者repo修改为你自己的github项目地址</p>\n<blockquote>\n<p>我这里默认的是使用<code>ssh</code>，如果想使用<code>https</code>点击更换就好了</p>\n<ul><li>我推荐使用ssh，毕竟你已经在你的github中添加了你本机的ssh，免得再输密码</li><li>如果不懂ssh可以先使用https，后面我们做服务器的自动git用ssh会更好，如果不需要，而且是在windows下使用的话那就<code>https</code>的吧，没啥关系，windows有记住密码的功能</li></ul></blockquote>\n<p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM截图20191003175326.png\" class=\"φcy\" alt=\"TIM截图20191003175326\"></p>\n<h3 id=\"写文章、发布文章\">写文章、发布文章<a href=\"#写文章、发布文章\" title=\"写文章、发布文章\"></a></h3><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p>\n<p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p>\n<blockquote>\n<p>article title 替换成你要写的文章的名字，需要注意一下：</p>\n<ul><li><p>最好使用英文，使用中文的话博客的url会非常长</p></li><li><p>如果想插入图片的话，打开你的博客目录里面的<code>_config.yml</code>找到<code>post_asset_folder:</code>属性，并复制未<code>true</code>，这样生成一篇新文章时，会在</p><p>目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等。这样在文章中插入图片使用相对路径就可以即在本地书写的时候看到图片，又在生成的博客中看到，例如：</p><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM截图20191003180656.png\" alt=\"TIM截图20191003180656\"></p><p>在文章中直接这样插入，就可以完美插入图片。详细可以借鉴我<a href=\"https://treeeeeeee.github.io/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87\" target=\"_blank\">另外一篇博客</a></p><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM截图20191003180755.png\" alt=\"TIM截图20191003180755\"></p></li><li><p>这里推荐一个超好用加方便的markdown编辑软件<code>Typora</code>，而且恰好支持这种图片资源文件，设置一下可以把任意来源图片直接弄到对应文件夹</p><blockquote><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM截图20191003183937.png\" alt=\"TIM截图20191003183937\" style=\"zoom:67%\"><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM截图20191003184214.png\" alt=\"TIM截图20191003184214\"></p><p><strong>这样设置以后你不管是从网络上来的图片还是任意地方拖动的进来的图片都会自动给你放到这个文件夹</strong></p></blockquote></li></ul></blockquote>\n<p>然后打开<code>D:\\study\\program\\blog\\source\\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p>\n<p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>\n<h3 id=\"绑定域名\">绑定域名<a href=\"#绑定域名\" title=\"绑定域名\"></a></h3><p>现在默认的域名还是<code>xxx.github.io</code>，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。</p>\n<p>以我的百度云为例，如下图所示，添加两条解析记录：</p>\n<p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/v2-e11377329d5cef129c0aefd10eaa1607_hd.jpg\" class=\"φcy\" alt=\"img\"></p>\n<p>然后打开你的github博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存：</p>\n<p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/v2-8125794bbf0055917b820178489c7b0f_hd.jpg\" class=\"φcy\" alt=\"img\"></p>\n<p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\\study\\program\\blog\\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到github。</p>\n<h3 id=\"备份博客源文件\">备份博客源文件<a href=\"#备份博客源文件\" title=\"备份博客源文件\"></a></h3><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p>\n<ul><li><p><strong>我的备份方法</strong></p><blockquote><p>随便找个文件夹，右键打开git bash，依次执行以下命令</p><p>然后删除你拉下来的所有东西文件夹，如果你开了隐藏文件夹也可见的话别把<code>.git</code>文件夹删除了，如果没开就放心删除所有文件吧（看见<code>.git</code>别动就对了）</p><p>然后把你你的整个博客文件夹移动到这里，并删除你博客文件下里面所有叫<code>.gitignore</code>的文件，通常来说，博客源码根目录有一个，主题文件夹里面都有</p><blockquote><p><code>.gitignore</code>文件是用来说明那些东西不被git push的，具体请自行百度</p></blockquote><p>然后继续依次执行以下命令</p><p>等待完成就可以在任何地方直接拉下来使用了，在其他地方使用有以下几个要注意的：</p><ul><li><p>环境必须安装这个没得说</p></li><li><p>如果你是使用shh来部署的项目需要把这台设备的生成的ssh添加到你的github账号里</p><blockquote><p>指的是你前面属性<code>repo :</code>是用的https的还是ssh的</p></blockquote></li></ul></blockquote></li><li><p>其他备份方法(该内容是粘贴复制)</p><blockquote><p>首先在github博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git branch -b hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo</code>提交就行了。</p></blockquote></li></ul><h3 id=\"博客源代码下载\">博客源代码下载<a href=\"#博客源代码下载\" title=\"博客源代码下载\"></a></h3><h3 id=\"个性化设置（matery主题）\">个性化设置（matery主题）<a href=\"#个性化设置（matery主题）\" title=\"个性化设置（matery主题）\"></a></h3><h3 id=\"常见问题及解答（faq）\">常见问题及解答（FAQ）<a href=\"#常见问题及解答（faq）\" title=\"常见问题及解答（FAQ）\"></a></h3><h2 id=\"个性化设置更换主题\">个性化设置|更换主题|<a href=\"#个性化设置更换主题\" title=\"个性化设置|更换主题|\"></a></h2><h3 id=\"效果图\">效果图<a href=\"#效果图\" title=\"效果图\"></a></h3><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM截图20191003184704.png\" class=\"φcy\" alt=\"TIM截图20191003184704\"></p>\n<p><a href=\"https://treeeeeeee.github.io\" target=\"_blank\">我的博客地址</a>有什么问题可以在文章下评论留言</p>\n<h3 id=\"inside主题\">inside主题<a href=\"#inside主题\" title=\"inside主题\"></a></h3><ul><li><p>直接下载源码放到你的博客源码目录的themes目录里面，并修改<code>_config.yml</code>文件中<code>theme:</code>属性，然后执行：</p><p>浏览器访问：localhost:4000 就能直接看到效果了</p></li><li><p>具体配置我就不详细说明了可以去看主题制作者的博客：<a href=\"https://blog.oniuo.com/theme-inside\" target=\"_blank\">链接</a></p></li></ul>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"windows下的hexogithub博客搭建\">windows下的hexo+github博客搭建<a href=\"#windows下的hexogithub博客搭建\" title=\"windows下的hexo+github博客搭建\"></a></h1><h2 id=\"博客搭建\">博客搭建<a href=\"#博客搭建\" title=\"博客搭建\"></a></h2><p>不多说这里放上<a href=\"https://zhuanlan.zhihu.com/p/35668237\" target=\"_blank\">大神的知乎</a>，点击自己按照流程来做就好了，下面我做一个归纳整理，也留作备份。</p>\n<h3 id=\"安装nodejs\">安装Node.js<a href=\"#安装nodejs\" title=\"安装Node.js\"></a></h3><blockquote>\n<ul><li><p><a href=\"https://nodejs.org/dist/v12.14.0/node-v12.14.0-x64.msi\" target=\"_blank\">windows下载链接</a></p></li><li><p>下载之后一路next就好，环境变量默认会把帮你配好</p></li><li><p>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p></li><li><p>也有没有自动配的情况，可以手动配一下。</p></li></ul></blockquote>\n<h3 id=\"添加国内镜像源\">添加国内镜像源<a href=\"#添加国内镜像源\" title=\"添加国内镜像源\"></a></h3><blockquote>\n<p>如果没有K X S W(这是啥大家都明白吧)的话，可以使用阿里的国内镜像进行加速。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></blockquote>\n<h3 id=\"安装git\">安装Git<a href=\"#安装git\" title=\"安装Git\"></a></h3><blockquote>\n<ul><li><a href=\"https://git-scm.com/download/win\" target=\"_blank\">Git的下载链接</a></li><li>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</li><li>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</li><li>同样如果没有找到版本号需要手动配置</li></ul></blockquote>\n<h3 id=\"注册github账号\">注册Github账号<a href=\"#注册github账号\" title=\"注册Github账号\"></a></h3><blockquote>\n<ul><li><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/\" target=\"_blank\">注册地址</a></p></li><li><p>注册完成之后进入主页</p></li><li><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/Screenshot.png\" alt=\"Screenshot\"></p><p>点击新建项目</p></li><li><p>项目名称是你的github用户名加.github.io</p><blockquote><p>例如: <code>XXXXX.github.io</code></p><p>同时也可以勾选一下Redme.md</p></blockquote><p>![new p](C:\\data\\Treeeeeeee.github.io\\blog\\source_posts\\hexo-admin-windows-服务器的综合博客平台\\new p.png)</p></li><li><p>然后按照下面的流程你就可以获得一个最简单的博客</p><ul><li><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/m.png\" alt=\"m\"></p></li><li><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/2.png\" alt=\"2\"></p></li><li><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/3.png\" alt=\"3\"></p></li><li><p>进去之后随便选一个</p></li></ul></li></ul></blockquote>\n<h3 id=\"安装hexo\">安装Hexo<a href=\"#安装hexo\" title=\"安装Hexo\"></a></h3><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在<code>D:\\study\\program\\blog</code>目录下。</p>\n<p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p>\n<p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p>\n<p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p>\n<p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p>\n<p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href=\"https://link.zhihu.com/?target=http%3A//localhost%3A4000/\" target=\"_blank\">http://localhost:4000/</a>，就可以看到我们的博客啦，效果如下：</p>\n<p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM图片20191003174050.png\" class=\"φcy\" alt=\"TIM图片20191003174050\"></p>\n<p>按<code>ctrl+c</code>关闭本地服务器。</p>\n<h3 id=\"连接github与本地\">连接Github与本地<a href=\"#连接github与本地\" title=\"连接Github与本地\"></a></h3><p>首先右键打开git bash，然后输入下面命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">\"godweiyang\"</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">\"792321264@qq.com\"</span></span><br></pre></td></tr></table></figure><p>用户名和邮箱根据你注册github的信息自行修改。</p>\n<p>然后生成密钥SSH key：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">\"792321264@qq.com\"</span></span><br></pre></td></tr></table></figure><p>打开<a href=\"https://link.zhihu.com/?target=http%3A//github.com/\" target=\"_blank\">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p>\n<p>git bash中输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>将输出的内容复制到框中，点击确定保存。</p>\n<p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p>\n<p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p>\n<p>修改最后一行的配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: </span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure><p>repository或者repo修改为你自己的github项目地址</p>\n<blockquote>\n<p>我这里默认的是使用<code>ssh</code>，如果想使用<code>https</code>点击更换就好了</p>\n<ul><li>我推荐使用ssh，毕竟你已经在你的github中添加了你本机的ssh，免得再输密码</li><li>如果不懂ssh可以先使用https，后面我们做服务器的自动git用ssh会更好，如果不需要，而且是在windows下使用的话那就<code>https</code>的吧，没啥关系，windows有记住密码的功能</li></ul></blockquote>\n<p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM截图20191003175326.png\" class=\"φcy\" alt=\"TIM截图20191003175326\"></p>\n<h3 id=\"写文章、发布文章\">写文章、发布文章<a href=\"#写文章、发布文章\" title=\"写文章、发布文章\"></a></h3><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p>\n<p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p>\n<blockquote>\n<p>article title 替换成你要写的文章的名字，需要注意一下：</p>\n<ul><li><p>最好使用英文，使用中文的话博客的url会非常长</p></li><li><p>如果想插入图片的话，打开你的博客目录里面的<code>_config.yml</code>找到<code>post_asset_folder:</code>属性，并复制未<code>true</code>，这样生成一篇新文章时，会在</p><p>目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等。这样在文章中插入图片使用相对路径就可以即在本地书写的时候看到图片，又在生成的博客中看到，例如：</p><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM截图20191003180656.png\" alt=\"TIM截图20191003180656\"></p><p>在文章中直接这样插入，就可以完美插入图片。详细可以借鉴我<a href=\"https://treeeeeeee.github.io/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87\" target=\"_blank\">另外一篇博客</a></p><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM截图20191003180755.png\" alt=\"TIM截图20191003180755\"></p></li><li><p>这里推荐一个超好用加方便的markdown编辑软件<code>Typora</code>，而且恰好支持这种图片资源文件，设置一下可以把任意来源图片直接弄到对应文件夹</p><blockquote><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM截图20191003183937.png\" alt=\"TIM截图20191003183937\" style=\"zoom:67%\"><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM截图20191003184214.png\" alt=\"TIM截图20191003184214\"></p><p><strong>这样设置以后你不管是从网络上来的图片还是任意地方拖动的进来的图片都会自动给你放到这个文件夹</strong></p></blockquote></li></ul></blockquote>\n<p>然后打开<code>D:\\study\\program\\blog\\source\\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p>\n<p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>\n<h3 id=\"绑定域名\">绑定域名<a href=\"#绑定域名\" title=\"绑定域名\"></a></h3><p>现在默认的域名还是<code>xxx.github.io</code>，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。</p>\n<p>以我的百度云为例，如下图所示，添加两条解析记录：</p>\n<p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/v2-e11377329d5cef129c0aefd10eaa1607_hd.jpg\" class=\"φcy\" alt=\"img\"></p>\n<p>然后打开你的github博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存：</p>\n<p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/v2-8125794bbf0055917b820178489c7b0f_hd.jpg\" class=\"φcy\" alt=\"img\"></p>\n<p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\\study\\program\\blog\\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到github。</p>\n<h3 id=\"备份博客源文件\">备份博客源文件<a href=\"#备份博客源文件\" title=\"备份博客源文件\"></a></h3><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p>\n<ul><li><p><strong>我的备份方法</strong></p><blockquote><p>随便找个文件夹，右键打开git bash，依次执行以下命令</p><p>然后删除你拉下来的所有东西文件夹，如果你开了隐藏文件夹也可见的话别把<code>.git</code>文件夹删除了，如果没开就放心删除所有文件吧（看见<code>.git</code>别动就对了）</p><p>然后把你你的整个博客文件夹移动到这里，并删除你博客文件下里面所有叫<code>.gitignore</code>的文件，通常来说，博客源码根目录有一个，主题文件夹里面都有</p><blockquote><p><code>.gitignore</code>文件是用来说明那些东西不被git push的，具体请自行百度</p></blockquote><p>然后继续依次执行以下命令</p><p>等待完成就可以在任何地方直接拉下来使用了，在其他地方使用有以下几个要注意的：</p><ul><li><p>环境必须安装这个没得说</p></li><li><p>如果你是使用shh来部署的项目需要把这台设备的生成的ssh添加到你的github账号里</p><blockquote><p>指的是你前面属性<code>repo :</code>是用的https的还是ssh的</p></blockquote></li></ul></blockquote></li><li><p>其他备份方法(该内容是粘贴复制)</p><blockquote><p>首先在github博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git branch -b hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo</code>提交就行了。</p></blockquote></li></ul><h3 id=\"博客源代码下载\">博客源代码下载<a href=\"#博客源代码下载\" title=\"博客源代码下载\"></a></h3><h3 id=\"个性化设置（matery主题）\">个性化设置（matery主题）<a href=\"#个性化设置（matery主题）\" title=\"个性化设置（matery主题）\"></a></h3><h3 id=\"常见问题及解答（faq）\">常见问题及解答（FAQ）<a href=\"#常见问题及解答（faq）\" title=\"常见问题及解答（FAQ）\"></a></h3><h2 id=\"个性化设置更换主题\">个性化设置|更换主题|<a href=\"#个性化设置更换主题\" title=\"个性化设置|更换主题|\"></a></h2><h3 id=\"效果图\">效果图<a href=\"#效果图\" title=\"效果图\"></a></h3><p><img src=\"/2019/10/03/hexo-admin-windows-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%BC%E5%90%88%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/TIM截图20191003184704.png\" class=\"φcy\" alt=\"TIM截图20191003184704\"></p>\n<p><a href=\"https://treeeeeeee.github.io\" target=\"_blank\">我的博客地址</a>有什么问题可以在文章下评论留言</p>\n<h3 id=\"inside主题\">inside主题<a href=\"#inside主题\" title=\"inside主题\"></a></h3><ul><li><p>直接下载源码放到你的博客源码目录的themes目录里面，并修改<code>_config.yml</code>文件中<code>theme:</code>属性，然后执行：</p><p>浏览器访问：localhost:4000 就能直接看到效果了</p></li><li><p>具体配置我就不详细说明了可以去看主题制作者的博客：<a href=\"https://blog.oniuo.com/theme-inside\" target=\"_blank\">链接</a></p></li></ul>","date_formatted":{"ll":"Oct 3, 2019","L":"10/03/2019","MM-DD":"10-03"},"plink":"https://treeeeeeee.github.io/2019/10/03/hexo-admin-windows-服务器的综合博客平台/","type":"post","toc":[{"id":"windows下的hexogithub博客搭建","title":"windows下的hexo+github博客搭建","index":"1","children":[{"id":"博客搭建","title":"博客搭建","index":"1.1","children":[{"id":"安装nodejs","title":"安装Node.js","index":"1.1.1"},{"id":"添加国内镜像源","title":"添加国内镜像源","index":"1.1.2"},{"id":"安装git","title":"安装Git","index":"1.1.3"},{"id":"注册github账号","title":"注册Github账号","index":"1.1.4"},{"id":"安装hexo","title":"安装Hexo","index":"1.1.5"},{"id":"连接github与本地","title":"连接Github与本地","index":"1.1.6"},{"id":"写文章、发布文章","title":"写文章、发布文章","index":"1.1.7"},{"id":"绑定域名","title":"绑定域名","index":"1.1.8"},{"id":"备份博客源文件","title":"备份博客源文件","index":"1.1.9"},{"id":"博客源代码下载","title":"博客源代码下载","index":"1.1.10"},{"id":"个性化设置（matery主题）","title":"个性化设置（matery主题）","index":"1.1.11"},{"id":"常见问题及解答（faq）","title":"常见问题及解答（FAQ）","index":"1.1.12"}]},{"id":"个性化设置更换主题","title":"个性化设置|更换主题|","index":"1.2","children":[{"id":"效果图","title":"效果图","index":"1.2.1"},{"id":"inside主题","title":"inside主题","index":"1.2.2"}]}]}]},{"title":"完美的hexo中插入图片的解决方案","date":"2019-10-01T15:13:00.000Z","_content":"\n# 完美的hexo中插入图片的解决方案\n\n以下内容来自ETRD的[《hexo中完美插入本地图片》]([http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/](http://etrd.org/2017/01/23/hexo中完美插入本地图片/))，摘录整理关键部分，留作备份。\n\n### Markdown编辑器\n\n  * **Typora**\n\n    > 不需要关注太多markdown语法就能写出比较好看的markdown，支持实时转换\n\n### Hexo配置文件的设置\n\n 确保你的Hexo的配置文件_config.yml里面有个这个选项配置，并将其置为true\n\n```\npost_asset_folder: true\n```\n\n 这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用\n\n```\nhexo new\n```\n\n生成一篇新文章时，会在\n\n```\n\\source\\_posts\n```\n\n目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等\n\n[![QQ截图20170123112354](http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/QQ%E6%88%AA%E5%9B%BE20170123112354.png)](http://etrd.org/2017/01/23/hexo中完美插入本地图片/QQ截图20170123112354.png)\n\n实际上我通常喜欢自己右键手动去建立一个md文件来写博客，而不使用hexo new命令，此时要达到同样的效果，我同样也需要手动去建立一个同名的文件夹去存放资源，我试过这样做是可行的，并且这样做虽然有点麻烦，但我似乎发现了它的一个优点，那就是当我的文章中没有图片时，我并不需要这个空的资源文件夹。\n\n有了上面的配置，Hexo在public文件下生成html文件时，会在相应的目录中把那文章对应的资源文件夹中的图片等附件复制过去，例如，这是我生成的一个例子：\n\n### 安装hexo-asset-image插件\n\n你需要安装一个图片路径转换的插件，这个插件名字是**hexo-asset-image**，我目前安装的是最新的0.03版本，使用如下命令安装插件\n\n```\nnpm install https://github.com/CodeFalling/hexo-asset-image --save\n```\n\n插件安装完以后，实际上是存放在下面的目录文件夹下\n\n```\n\\blog\\node_modules\\hexo-asset-image\n```\n\n想要卸载这个插件怎么处理，我听说直接删掉这个文件夹，反正我这么试过了。\n\n### md文件的时间标签\n\nhexo-asset-image的原理应该是根据Hexo生成html后以时间的为目录的规则，将我们图片的相对地址转换成了生成后与时间对应目录的绝对地址，因此我认为md文件中应该要有时间标签，一来是为了让Hexo根据md的时间标签来确定文章的新旧排序，如果没有时间标签，Hexo会把md文件的修改时间作为发布时间，这显然是不合理的，再者这个时间标签，我想hexo-asset-image也会引用到，在一篇实际的博文中，我的md文件完整的开头是这样的：\n\n```\ntitle: hexo中完美插入本地图片\ndate: 2017-01-23 11:00:55\ncategories: hexo使用\ntags: \n- hexo\n- 本地图片\n- hexo-asset-image\n```\n\n### 插入图片\n\n由于每个md文件都有对应的一个资源文件夹，因此，你首先要把需要插入的图片放到这个资源文件夹下，然后进行路径引用，这是上面插入图片时的实际引用代码\n\n```\n![QQ截图20170123114005](/hexo中完美插入本地图片/QQ截图20170123114005.png)\n```\n\n使用Typora又有一个十分方便的地方在于，只需要将图片往这里一拖就插入了，但其实际拖入图片后的插入代码是绝对路径的引用，是这样的\n\n```\n![QQ截图20170123114005](K:\\FangCloudSync\\Github博客源码\\blog\\source\\_posts\\hexo中完美插入本地图片\\QQ截图20170123114005.png)\n```\n\n对比上面的两个代码，我只需要将前面的那段绝对路径删掉~~K:\\FangCloudSync\\Github博客源码\\blog\\source_posts~~ ，然后再将剩余的**两个\\分别换成/** 就可以了\n\n当然你要是觉得还是麻烦，可以直接打开typora的偏好设置\n\n![TIM截图20191230113452](hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/TIM%E6%88%AA%E5%9B%BE20191230113452.png)\n\n进行如上设置，就不用手动编辑成相对路径了\n\n这样子，Typora编辑时同时能够看到插入的图片。","source":"_posts/hexo下完美插入图片.md","raw":"title: 完美的hexo中插入图片的解决方案\ntags:\n  - hexo配置\ncategories: 兴趣\ndate: 2019-10-01 23:13:00\n---\n\n# 完美的hexo中插入图片的解决方案\n\n以下内容来自ETRD的[《hexo中完美插入本地图片》]([http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/](http://etrd.org/2017/01/23/hexo中完美插入本地图片/))，摘录整理关键部分，留作备份。\n\n### Markdown编辑器\n\n  * **Typora**\n\n    > 不需要关注太多markdown语法就能写出比较好看的markdown，支持实时转换\n\n### Hexo配置文件的设置\n\n 确保你的Hexo的配置文件_config.yml里面有个这个选项配置，并将其置为true\n\n```\npost_asset_folder: true\n```\n\n 这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用\n\n```\nhexo new\n```\n\n生成一篇新文章时，会在\n\n```\n\\source\\_posts\n```\n\n目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等\n\n[![QQ截图20170123112354](http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/QQ%E6%88%AA%E5%9B%BE20170123112354.png)](http://etrd.org/2017/01/23/hexo中完美插入本地图片/QQ截图20170123112354.png)\n\n实际上我通常喜欢自己右键手动去建立一个md文件来写博客，而不使用hexo new命令，此时要达到同样的效果，我同样也需要手动去建立一个同名的文件夹去存放资源，我试过这样做是可行的，并且这样做虽然有点麻烦，但我似乎发现了它的一个优点，那就是当我的文章中没有图片时，我并不需要这个空的资源文件夹。\n\n有了上面的配置，Hexo在public文件下生成html文件时，会在相应的目录中把那文章对应的资源文件夹中的图片等附件复制过去，例如，这是我生成的一个例子：\n\n### 安装hexo-asset-image插件\n\n你需要安装一个图片路径转换的插件，这个插件名字是**hexo-asset-image**，我目前安装的是最新的0.03版本，使用如下命令安装插件\n\n```\nnpm install https://github.com/CodeFalling/hexo-asset-image --save\n```\n\n插件安装完以后，实际上是存放在下面的目录文件夹下\n\n```\n\\blog\\node_modules\\hexo-asset-image\n```\n\n想要卸载这个插件怎么处理，我听说直接删掉这个文件夹，反正我这么试过了。\n\n### md文件的时间标签\n\nhexo-asset-image的原理应该是根据Hexo生成html后以时间的为目录的规则，将我们图片的相对地址转换成了生成后与时间对应目录的绝对地址，因此我认为md文件中应该要有时间标签，一来是为了让Hexo根据md的时间标签来确定文章的新旧排序，如果没有时间标签，Hexo会把md文件的修改时间作为发布时间，这显然是不合理的，再者这个时间标签，我想hexo-asset-image也会引用到，在一篇实际的博文中，我的md文件完整的开头是这样的：\n\n```\ntitle: hexo中完美插入本地图片\ndate: 2017-01-23 11:00:55\ncategories: hexo使用\ntags: \n- hexo\n- 本地图片\n- hexo-asset-image\n```\n\n### 插入图片\n\n由于每个md文件都有对应的一个资源文件夹，因此，你首先要把需要插入的图片放到这个资源文件夹下，然后进行路径引用，这是上面插入图片时的实际引用代码\n\n```\n![QQ截图20170123114005](/hexo中完美插入本地图片/QQ截图20170123114005.png)\n```\n\n使用Typora又有一个十分方便的地方在于，只需要将图片往这里一拖就插入了，但其实际拖入图片后的插入代码是绝对路径的引用，是这样的\n\n```\n![QQ截图20170123114005](K:\\FangCloudSync\\Github博客源码\\blog\\source\\_posts\\hexo中完美插入本地图片\\QQ截图20170123114005.png)\n```\n\n对比上面的两个代码，我只需要将前面的那段绝对路径删掉~~K:\\FangCloudSync\\Github博客源码\\blog\\source_posts~~ ，然后再将剩余的**两个\\分别换成/** 就可以了\n\n当然你要是觉得还是麻烦，可以直接打开typora的偏好设置\n\n![TIM截图20191230113452](hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/TIM%E6%88%AA%E5%9B%BE20191230113452.png)\n\n进行如上设置，就不用手动编辑成相对路径了\n\n这样子，Typora编辑时同时能够看到插入的图片。","slug":"hexo下完美插入图片","published":1,"updated":"2019-12-30T03:38:54.488Z","comments":1,"layout":"post","photos":[],"link":"2019/10/01/hexo下完美插入图片","_id":"ck8jl8qii000mw0w04dtucawd","content":"<h1 id=\"完美的hexo中插入图片的解决方案\">完美的hexo中插入图片的解决方案<a href=\"#完美的hexo中插入图片的解决方案\" title=\"完美的hexo中插入图片的解决方案\"></a></h1><p>以下内容来自ETRD的<a href=\"[http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/](http://etrd.org/2017/01/23/hexo中完美插入本地图片/)\">《hexo中完美插入本地图片》</a>，摘录整理关键部分，留作备份。</p>\n<h3 id=\"markdown编辑器\">Markdown编辑器<a href=\"#markdown编辑器\" title=\"Markdown编辑器\"></a></h3><ul><li><p><strong>Typora</strong></p><blockquote><p>不需要关注太多markdown语法就能写出比较好看的markdown，支持实时转换</p></blockquote></li></ul><h3 id=\"hexo配置文件的设置\">Hexo配置文件的设置<a href=\"#hexo配置文件的设置\" title=\"Hexo配置文件的设置\"></a></h3><p> 确保你的Hexo的配置文件_config.yml里面有个这个选项配置，并将其置为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_asset_folder: true</span><br></pre></td></tr></table></figure><p> 这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new</span><br></pre></td></tr></table></figure><p>生成一篇新文章时，会在</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\source\\_posts</span><br></pre></td></tr></table></figure><p>目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等</p>\n<p><a href=\"http://etrd.org/2017/01/23/hexo中完美插入本地图片/QQ截图20170123112354.png\" target=\"_blank\"><img src=\"http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/QQ%E6%88%AA%E5%9B%BE20170123112354.png\" alt=\"QQ截图20170123112354\"></a></p>\n<p>实际上我通常喜欢自己右键手动去建立一个md文件来写博客，而不使用hexo new命令，此时要达到同样的效果，我同样也需要手动去建立一个同名的文件夹去存放资源，我试过这样做是可行的，并且这样做虽然有点麻烦，但我似乎发现了它的一个优点，那就是当我的文章中没有图片时，我并不需要这个空的资源文件夹。</p>\n<p>有了上面的配置，Hexo在public文件下生成html文件时，会在相应的目录中把那文章对应的资源文件夹中的图片等附件复制过去，例如，这是我生成的一个例子：</p>\n<h3 id=\"安装hexo-asset-image插件\">安装hexo-asset-image插件<a href=\"#安装hexo-asset-image插件\" title=\"安装hexo-asset-image插件\"></a></h3><p>你需要安装一个图片路径转换的插件，这个插件名字是<strong>hexo-asset-image</strong>，我目前安装的是最新的0.03版本，使用如下命令安装插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>插件安装完以后，实际上是存放在下面的目录文件夹下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\blog\\node_modules\\hexo-asset-image</span><br></pre></td></tr></table></figure><p>想要卸载这个插件怎么处理，我听说直接删掉这个文件夹，反正我这么试过了。</p>\n<h3 id=\"md文件的时间标签\">md文件的时间标签<a href=\"#md文件的时间标签\" title=\"md文件的时间标签\"></a></h3><p>hexo-asset-image的原理应该是根据Hexo生成html后以时间的为目录的规则，将我们图片的相对地址转换成了生成后与时间对应目录的绝对地址，因此我认为md文件中应该要有时间标签，一来是为了让Hexo根据md的时间标签来确定文章的新旧排序，如果没有时间标签，Hexo会把md文件的修改时间作为发布时间，这显然是不合理的，再者这个时间标签，我想hexo-asset-image也会引用到，在一篇实际的博文中，我的md文件完整的开头是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: hexo中完美插入本地图片</span><br><span class=\"line\">date: 2017-01-23 11:00:55</span><br><span class=\"line\">categories: hexo使用</span><br><span class=\"line\">tags: </span><br><span class=\"line\">- hexo</span><br><span class=\"line\">- 本地图片</span><br><span class=\"line\">- hexo-asset-image</span><br></pre></td></tr></table></figure><h3 id=\"插入图片\">插入图片<a href=\"#插入图片\" title=\"插入图片\"></a></h3><p>由于每个md文件都有对应的一个资源文件夹，因此，你首先要把需要插入的图片放到这个资源文件夹下，然后进行路径引用，这是上面插入图片时的实际引用代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![QQ截图20170123114005](&#x2F;hexo中完美插入本地图片&#x2F;QQ截图20170123114005.png)</span><br></pre></td></tr></table></figure><p>使用Typora又有一个十分方便的地方在于，只需要将图片往这里一拖就插入了，但其实际拖入图片后的插入代码是绝对路径的引用，是这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![QQ截图20170123114005](K:\\FangCloudSync\\Github博客源码\\blog\\source\\_posts\\hexo中完美插入本地图片\\QQ截图20170123114005.png)</span><br></pre></td></tr></table></figure><p>对比上面的两个代码，我只需要将前面的那段绝对路径删掉<del>K:\\FangCloudSync\\Github博客源码\\blog\\source_posts</del> ，然后再将剩余的<strong>两个\\分别换成/</strong> 就可以了</p>\n<p>当然你要是觉得还是麻烦，可以直接打开typora的偏好设置</p>\n<p><img src=\"/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/TIM%E6%88%AA%E5%9B%BE20191230113452.png\" class=\"φcy\" alt=\"TIM截图20191230113452\"></p>\n<p>进行如上设置，就不用手动编辑成相对路径了</p>\n<p>这样子，Typora编辑时同时能够看到插入的图片。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"完美的hexo中插入图片的解决方案\">完美的hexo中插入图片的解决方案<a href=\"#完美的hexo中插入图片的解决方案\" title=\"完美的hexo中插入图片的解决方案\"></a></h1><p>以下内容来自ETRD的<a href=\"[http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/](http://etrd.org/2017/01/23/hexo中完美插入本地图片/)\">《hexo中完美插入本地图片》</a>，摘录整理关键部分，留作备份。</p>\n<h3 id=\"markdown编辑器\">Markdown编辑器<a href=\"#markdown编辑器\" title=\"Markdown编辑器\"></a></h3><ul><li><p><strong>Typora</strong></p><blockquote><p>不需要关注太多markdown语法就能写出比较好看的markdown，支持实时转换</p></blockquote></li></ul><h3 id=\"hexo配置文件的设置\">Hexo配置文件的设置<a href=\"#hexo配置文件的设置\" title=\"Hexo配置文件的设置\"></a></h3><p> 确保你的Hexo的配置文件_config.yml里面有个这个选项配置，并将其置为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_asset_folder: true</span><br></pre></td></tr></table></figure><p> 这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new</span><br></pre></td></tr></table></figure><p>生成一篇新文章时，会在</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\source\\_posts</span><br></pre></td></tr></table></figure><p>目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等</p>\n<p><a href=\"http://etrd.org/2017/01/23/hexo中完美插入本地图片/QQ截图20170123112354.png\" target=\"_blank\"><img src=\"http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/QQ%E6%88%AA%E5%9B%BE20170123112354.png\" alt=\"QQ截图20170123112354\"></a></p>\n<p>实际上我通常喜欢自己右键手动去建立一个md文件来写博客，而不使用hexo new命令，此时要达到同样的效果，我同样也需要手动去建立一个同名的文件夹去存放资源，我试过这样做是可行的，并且这样做虽然有点麻烦，但我似乎发现了它的一个优点，那就是当我的文章中没有图片时，我并不需要这个空的资源文件夹。</p>\n<p>有了上面的配置，Hexo在public文件下生成html文件时，会在相应的目录中把那文章对应的资源文件夹中的图片等附件复制过去，例如，这是我生成的一个例子：</p>\n<h3 id=\"安装hexo-asset-image插件\">安装hexo-asset-image插件<a href=\"#安装hexo-asset-image插件\" title=\"安装hexo-asset-image插件\"></a></h3><p>你需要安装一个图片路径转换的插件，这个插件名字是<strong>hexo-asset-image</strong>，我目前安装的是最新的0.03版本，使用如下命令安装插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>插件安装完以后，实际上是存放在下面的目录文件夹下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\blog\\node_modules\\hexo-asset-image</span><br></pre></td></tr></table></figure><p>想要卸载这个插件怎么处理，我听说直接删掉这个文件夹，反正我这么试过了。</p>\n<h3 id=\"md文件的时间标签\">md文件的时间标签<a href=\"#md文件的时间标签\" title=\"md文件的时间标签\"></a></h3><p>hexo-asset-image的原理应该是根据Hexo生成html后以时间的为目录的规则，将我们图片的相对地址转换成了生成后与时间对应目录的绝对地址，因此我认为md文件中应该要有时间标签，一来是为了让Hexo根据md的时间标签来确定文章的新旧排序，如果没有时间标签，Hexo会把md文件的修改时间作为发布时间，这显然是不合理的，再者这个时间标签，我想hexo-asset-image也会引用到，在一篇实际的博文中，我的md文件完整的开头是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: hexo中完美插入本地图片</span><br><span class=\"line\">date: 2017-01-23 11:00:55</span><br><span class=\"line\">categories: hexo使用</span><br><span class=\"line\">tags: </span><br><span class=\"line\">- hexo</span><br><span class=\"line\">- 本地图片</span><br><span class=\"line\">- hexo-asset-image</span><br></pre></td></tr></table></figure><h3 id=\"插入图片\">插入图片<a href=\"#插入图片\" title=\"插入图片\"></a></h3><p>由于每个md文件都有对应的一个资源文件夹，因此，你首先要把需要插入的图片放到这个资源文件夹下，然后进行路径引用，这是上面插入图片时的实际引用代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![QQ截图20170123114005](&#x2F;hexo中完美插入本地图片&#x2F;QQ截图20170123114005.png)</span><br></pre></td></tr></table></figure><p>使用Typora又有一个十分方便的地方在于，只需要将图片往这里一拖就插入了，但其实际拖入图片后的插入代码是绝对路径的引用，是这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![QQ截图20170123114005](K:\\FangCloudSync\\Github博客源码\\blog\\source\\_posts\\hexo中完美插入本地图片\\QQ截图20170123114005.png)</span><br></pre></td></tr></table></figure><p>对比上面的两个代码，我只需要将前面的那段绝对路径删掉<del>K:\\FangCloudSync\\Github博客源码\\blog\\source_posts</del> ，然后再将剩余的<strong>两个\\分别换成/</strong> 就可以了</p>\n<p>当然你要是觉得还是麻烦，可以直接打开typora的偏好设置</p>\n<p><img src=\"/2019/10/01/hexo%E4%B8%8B%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/TIM%E6%88%AA%E5%9B%BE20191230113452.png\" class=\"φcy\" alt=\"TIM截图20191230113452\"></p>\n<p>进行如上设置，就不用手动编辑成相对路径了</p>\n<p>这样子，Typora编辑时同时能够看到插入的图片。</p>\n","date_formatted":{"ll":"Oct 1, 2019","L":"10/01/2019","MM-DD":"10-01"},"plink":"https://treeeeeeee.github.io/2019/10/01/hexo下完美插入图片/","type":"post","toc":[{"id":"完美的hexo中插入图片的解决方案","title":"完美的hexo中插入图片的解决方案","index":"1","children":[{"id":"markdown编辑器","title":"Markdown编辑器","index":"1.1"},{"id":"hexo配置文件的设置","title":"Hexo配置文件的设置","index":"1.2"},{"id":"安装hexo-asset-image插件","title":"安装hexo-asset-image插件","index":"1.3"},{"id":"md文件的时间标签","title":"md文件的时间标签","index":"1.4"},{"id":"插入图片","title":"插入图片","index":"1.5"}]}]},{"title":"idea条件断点","author":"Jon","date":"2019-11-06T16:22:00.000Z","_content":"# idea的条件断点\n\n超简单的使用方法，右键点击你的短点，即可出现条件短点设置，其中`condition`就是超好用的条件短点的判断语句，语句需要返回结果是bool类型的，可以使用：\n\n* ||\n* &&\n* |\n* &\n\n来链接多个语句，并且可以访问断点**所在的作用域里所有可用的变量或者方法。**\n\n![image-20191107003330787](idea%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9/image-20191107003330787.png)","source":"_posts/idea条件断点.md","raw":"title: idea条件断点\nauthor: Jon\ntags:\n  - 开发工具探索\ncategories:\n  - 开发工具\ndate: 2019-11-07 00:22:00\n---\n# idea的条件断点\n\n超简单的使用方法，右键点击你的短点，即可出现条件短点设置，其中`condition`就是超好用的条件短点的判断语句，语句需要返回结果是bool类型的，可以使用：\n\n* ||\n* &&\n* |\n* &\n\n来链接多个语句，并且可以访问断点**所在的作用域里所有可用的变量或者方法。**\n\n![image-20191107003330787](idea%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9/image-20191107003330787.png)","slug":"idea条件断点","published":1,"updated":"2019-12-30T02:50:50.780Z","comments":1,"layout":"post","photos":[],"link":"2019/11/07/idea条件断点","_id":"ck8jl8qij000ow0w058ulge4l","content":"<h1 id=\"idea的条件断点\">idea的条件断点<a href=\"#idea的条件断点\" title=\"idea的条件断点\"></a></h1><p>超简单的使用方法，右键点击你的短点，即可出现条件短点设置，其中<code>condition</code>就是超好用的条件短点的判断语句，语句需要返回结果是bool类型的，可以使用：</p>\n<ul><li>||</li><li>&amp;&amp;</li><li>|</li><li>&amp;</li></ul><p>来链接多个语句，并且可以访问断点<strong>所在的作用域里所有可用的变量或者方法。</strong></p>\n<p><img src=\"/2019/11/07/idea%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9/image-20191107003330787.png\" class=\"φcy\" alt=\"image-20191107003330787\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"idea的条件断点\">idea的条件断点<a href=\"#idea的条件断点\" title=\"idea的条件断点\"></a></h1><p>超简单的使用方法，右键点击你的短点，即可出现条件短点设置，其中<code>condition</code>就是超好用的条件短点的判断语句，语句需要返回结果是bool类型的，可以使用：</p>\n<ul><li>||</li><li>&amp;&amp;</li><li>|</li><li>&amp;</li></ul><p>来链接多个语句，并且可以访问断点<strong>所在的作用域里所有可用的变量或者方法。</strong></p>\n<p><img src=\"/2019/11/07/idea%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9/image-20191107003330787.png\" class=\"φcy\" alt=\"image-20191107003330787\"></p>\n","date_formatted":{"ll":"Nov 7, 2019","L":"11/07/2019","MM-DD":"11-07"},"plink":"https://treeeeeeee.github.io/2019/11/07/idea条件断点/","type":"post","toc":[{"id":"idea的条件断点","title":"idea的条件断点","index":"1"}]},{"_content":"title: java编译运行过程详解\ntags:\n  - 课件附页\ncategories:\n  - java\n  - 课件附页\nauthor: Jon\ndate: 2019-10-23 00:40:00\n\n参考[原文链接](https://blog.csdn.net/super_YC/article/details/71439786)，以下做自己的整理备份\n\n**java整个编译以及运行的过程相当繁琐，我就举一个简单的例子说明：**\n\nJava程序从源文件创建到程序运行要经过两大步骤：\n\n1. 源文件由编译器编译成字节码（ByteCode）； \n\n2. 字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言\n\n（ \"semi-interpreted\" language）\n\n```java\nclass Animal {\n    private String name;\n\n    public Animal(String name) {\n        super();\n        this.name = name;\n    }\n\n    public void printName() {\n        System.out.println(\"Animal = \" + this.name);\n    }\n}\n \npublic class Main {\n\n    public static void main(String[] args) {\n        Animal animal = new Animal(\"super_yc\");\n        animal.printName();\n    }\n\n}\n```\n\n**第一步（编译）：**\n\n创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，如果这个类所依赖的类还没有被编译，\n\n编译器会自动的先编译这个所依赖的类，然后引用。如果java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报\n\n\"Cant found sysbol\"的异常错误。\n\n编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、\n\n方法引用，成员变量引用等）；方法字节码中放的是各个方法的字节码。\n\n\n\n**第二步（运行）：**\n\njava类运行的过程大概分为两个步骤：（1）类的加载 （2）类的执行。需要说明的一点的是：JVM主要在程序第一次运行时主动使用类的\n\n时候，才会立即去加载。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到，不得不加载的时候，才加载进来，而且只加载一次！\n\n\n\n**根据上面的程序，详解该程序运行的详细步骤：**\n\n1. 在类路径下找到编译好的 java 程序中得到 Test.class 字节码文件后，在命令行上敲 java Test，系统就会启动一个 JVM 进程，JVM进程从classpath路径下找到一个名为Test.class的二进制文件，将Test.class文件中的类信息加载到运行时数据区的方法区中，这一过程叫做类的加载。（只有类信息在方法区中，才能创建对象，使用类中的成员变量）\n\n   \n\n2. JVM 找到main方法的主函数入口， 持有一个指向当前类(Test)常量池的指针，而常量池中的第一项是发现是一个对Animal对象的符号引用，并且main方法中第一条指令是Animal animal = new Animal(\"super_yc\")，就是让JVM创建一个Animal对象，但是方法区中还没有Animal类的类信息，于是JVM就要马上的加载Animal类，将Animal类信息放入到方法区中，于是JVM 以一个直接指向方法区 Animal类的指针替换了常量池中第一项的符号引用。\n\n   \n\n3. 加载完Animal类的信息以后，JVM虚拟机就会在堆内存中为一个Animal类实例分配内存，然后调用其构造函数初始化Animal实例，这个实例持有指向方法区的Animal类的类型信息（其中包含有方发表，java动态绑定的底层实现）的引用。（animal指向了Animal对象的引用会自动的放在栈中，字符串常量\"super_yc\"会自动的放在方法区的常量池中，对象会自动的放入堆区）\n\n   \n\n4. 当使用 animal.pringName()的时候，JVM根据栈中animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型\n\n   \n\n信息方法表，获得pringName()函数的字节码地址，然后开始运行函数。\n","source":"_posts/java编译运行过程详解.md","raw":"title: java编译运行过程详解\ntags:\n  - 课件附页\ncategories:\n  - java\n  - 课件附页\nauthor: Jon\ndate: 2019-10-23 00:40:00\n\n参考[原文链接](https://blog.csdn.net/super_YC/article/details/71439786)，以下做自己的整理备份\n\n**java整个编译以及运行的过程相当繁琐，我就举一个简单的例子说明：**\n\nJava程序从源文件创建到程序运行要经过两大步骤：\n\n1. 源文件由编译器编译成字节码（ByteCode）； \n\n2. 字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言\n\n（ \"semi-interpreted\" language）\n\n```java\nclass Animal {\n    private String name;\n\n    public Animal(String name) {\n        super();\n        this.name = name;\n    }\n\n    public void printName() {\n        System.out.println(\"Animal = \" + this.name);\n    }\n}\n \npublic class Main {\n\n    public static void main(String[] args) {\n        Animal animal = new Animal(\"super_yc\");\n        animal.printName();\n    }\n\n}\n```\n\n**第一步（编译）：**\n\n创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，如果这个类所依赖的类还没有被编译，\n\n编译器会自动的先编译这个所依赖的类，然后引用。如果java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报\n\n\"Cant found sysbol\"的异常错误。\n\n编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、\n\n方法引用，成员变量引用等）；方法字节码中放的是各个方法的字节码。\n\n\n\n**第二步（运行）：**\n\njava类运行的过程大概分为两个步骤：（1）类的加载 （2）类的执行。需要说明的一点的是：JVM主要在程序第一次运行时主动使用类的\n\n时候，才会立即去加载。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到，不得不加载的时候，才加载进来，而且只加载一次！\n\n\n\n**根据上面的程序，详解该程序运行的详细步骤：**\n\n1. 在类路径下找到编译好的 java 程序中得到 Test.class 字节码文件后，在命令行上敲 java Test，系统就会启动一个 JVM 进程，JVM进程从classpath路径下找到一个名为Test.class的二进制文件，将Test.class文件中的类信息加载到运行时数据区的方法区中，这一过程叫做类的加载。（只有类信息在方法区中，才能创建对象，使用类中的成员变量）\n\n   \n\n2. JVM 找到main方法的主函数入口， 持有一个指向当前类(Test)常量池的指针，而常量池中的第一项是发现是一个对Animal对象的符号引用，并且main方法中第一条指令是Animal animal = new Animal(\"super_yc\")，就是让JVM创建一个Animal对象，但是方法区中还没有Animal类的类信息，于是JVM就要马上的加载Animal类，将Animal类信息放入到方法区中，于是JVM 以一个直接指向方法区 Animal类的指针替换了常量池中第一项的符号引用。\n\n   \n\n3. 加载完Animal类的信息以后，JVM虚拟机就会在堆内存中为一个Animal类实例分配内存，然后调用其构造函数初始化Animal实例，这个实例持有指向方法区的Animal类的类型信息（其中包含有方发表，java动态绑定的底层实现）的引用。（animal指向了Animal对象的引用会自动的放在栈中，字符串常量\"super_yc\"会自动的放在方法区的常量池中，对象会自动的放入堆区）\n\n   \n\n4. 当使用 animal.pringName()的时候，JVM根据栈中animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型\n\n   \n\n信息方法表，获得pringName()函数的字节码地址，然后开始运行函数。\n","slug":"java编译运行过程详解","published":1,"date":"2019-12-30T02:50:50.785Z","updated":"2020-04-02T19:50:25.592Z","title":"java编译运行过程详解","_id":"ck8jl8qio000sw0w02ltf35hl","comments":1,"layout":"post","photos":[],"link":"2019/12/30/java编译运行过程详解","content":"<p>title: java编译运行过程详解<br>tags:</p>\n<ul><li>课件附页<br>categories:</li><li>java</li><li>课件附页<br>author: Jon<br>date: 2019-10-23 00:40:00</li></ul><p>参考<a href=\"https://blog.csdn.net/super_YC/article/details/71439786\" target=\"_blank\">原文链接</a>，以下做自己的整理备份</p>\n<p><strong>java整个编译以及运行的过程相当繁琐，我就举一个简单的例子说明：</strong></p>\n<p>Java程序从源文件创建到程序运行要经过两大步骤：</p>\n<ol><li><p>源文件由编译器编译成字节码（ByteCode）；</p></li><li><p>字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言</p></li></ol><p>（ “semi-interpreted” language）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Animal</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Animal = \"</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Animal animal = <span class=\"keyword\">new</span> Animal(<span class=\"string\">\"super_yc\"</span>);</span><br><span class=\"line\">        animal.printName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一步（编译）：</strong></p>\n<p>创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，如果这个类所依赖的类还没有被编译，</p>\n<p>编译器会自动的先编译这个所依赖的类，然后引用。如果java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报</p>\n<p>“Cant found sysbol”的异常错误。</p>\n<p>编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、</p>\n<p>方法引用，成员变量引用等）；方法字节码中放的是各个方法的字节码。</p>\n<p><strong>第二步（运行）：</strong></p>\n<p>java类运行的过程大概分为两个步骤：（1）类的加载 （2）类的执行。需要说明的一点的是：JVM主要在程序第一次运行时主动使用类的</p>\n<p>时候，才会立即去加载。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到，不得不加载的时候，才加载进来，而且只加载一次！</p>\n<p><strong>根据上面的程序，详解该程序运行的详细步骤：</strong></p>\n<ol><li>在类路径下找到编译好的 java 程序中得到 Test.class 字节码文件后，在命令行上敲 java Test，系统就会启动一个 JVM 进程，JVM进程从classpath路径下找到一个名为Test.class的二进制文件，将Test.class文件中的类信息加载到运行时数据区的方法区中，这一过程叫做类的加载。（只有类信息在方法区中，才能创建对象，使用类中的成员变量）</li></ol><ol><li>JVM 找到main方法的主函数入口， 持有一个指向当前类(Test)常量池的指针，而常量池中的第一项是发现是一个对Animal对象的符号引用，并且main方法中第一条指令是Animal animal = new Animal(“super_yc”)，就是让JVM创建一个Animal对象，但是方法区中还没有Animal类的类信息，于是JVM就要马上的加载Animal类，将Animal类信息放入到方法区中，于是JVM 以一个直接指向方法区 Animal类的指针替换了常量池中第一项的符号引用。</li></ol><ol><li>加载完Animal类的信息以后，JVM虚拟机就会在堆内存中为一个Animal类实例分配内存，然后调用其构造函数初始化Animal实例，这个实例持有指向方法区的Animal类的类型信息（其中包含有方发表，java动态绑定的底层实现）的引用。（animal指向了Animal对象的引用会自动的放在栈中，字符串常量”super_yc”会自动的放在方法区的常量池中，对象会自动的放入堆区）</li></ol><ol><li>当使用 animal.pringName()的时候，JVM根据栈中animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型</li></ol><p>信息方法表，获得pringName()函数的字节码地址，然后开始运行函数。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>title: java编译运行过程详解<br>tags:</p>\n<ul><li>课件附页<br>categories:</li><li>java</li><li>课件附页<br>author: Jon<br>date: 2019-10-23 00:40:00</li></ul><p>参考<a href=\"https://blog.csdn.net/super_YC/article/details/71439786\" target=\"_blank\">原文链接</a>，以下做自己的整理备份</p>\n<p><strong>java整个编译以及运行的过程相当繁琐，我就举一个简单的例子说明：</strong></p>\n<p>Java程序从源文件创建到程序运行要经过两大步骤：</p>\n<ol><li><p>源文件由编译器编译成字节码（ByteCode）；</p></li><li><p>字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言</p></li></ol><p>（ “semi-interpreted” language）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Animal</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Animal = \"</span> + <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Animal animal = <span class=\"keyword\">new</span> Animal(<span class=\"string\">\"super_yc\"</span>);</span><br><span class=\"line\">        animal.printName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一步（编译）：</strong></p>\n<p>创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，如果这个类所依赖的类还没有被编译，</p>\n<p>编译器会自动的先编译这个所依赖的类，然后引用。如果java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报</p>\n<p>“Cant found sysbol”的异常错误。</p>\n<p>编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、</p>\n<p>方法引用，成员变量引用等）；方法字节码中放的是各个方法的字节码。</p>\n<p><strong>第二步（运行）：</strong></p>\n<p>java类运行的过程大概分为两个步骤：（1）类的加载 （2）类的执行。需要说明的一点的是：JVM主要在程序第一次运行时主动使用类的</p>\n<p>时候，才会立即去加载。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到，不得不加载的时候，才加载进来，而且只加载一次！</p>\n<p><strong>根据上面的程序，详解该程序运行的详细步骤：</strong></p>\n<ol><li>在类路径下找到编译好的 java 程序中得到 Test.class 字节码文件后，在命令行上敲 java Test，系统就会启动一个 JVM 进程，JVM进程从classpath路径下找到一个名为Test.class的二进制文件，将Test.class文件中的类信息加载到运行时数据区的方法区中，这一过程叫做类的加载。（只有类信息在方法区中，才能创建对象，使用类中的成员变量）</li></ol><ol><li>JVM 找到main方法的主函数入口， 持有一个指向当前类(Test)常量池的指针，而常量池中的第一项是发现是一个对Animal对象的符号引用，并且main方法中第一条指令是Animal animal = new Animal(“super_yc”)，就是让JVM创建一个Animal对象，但是方法区中还没有Animal类的类信息，于是JVM就要马上的加载Animal类，将Animal类信息放入到方法区中，于是JVM 以一个直接指向方法区 Animal类的指针替换了常量池中第一项的符号引用。</li></ol><ol><li>加载完Animal类的信息以后，JVM虚拟机就会在堆内存中为一个Animal类实例分配内存，然后调用其构造函数初始化Animal实例，这个实例持有指向方法区的Animal类的类型信息（其中包含有方发表，java动态绑定的底层实现）的引用。（animal指向了Animal对象的引用会自动的放在栈中，字符串常量”super_yc”会自动的放在方法区的常量池中，对象会自动的放入堆区）</li></ol><ol><li>当使用 animal.pringName()的时候，JVM根据栈中animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型</li></ol><p>信息方法表，获得pringName()函数的字节码地址，然后开始运行函数。</p>\n","date_formatted":{"ll":"Dec 30, 2019","L":"12/30/2019","MM-DD":"12-30"},"plink":"https://treeeeeeee.github.io/2019/12/30/java编译运行过程详解/","type":"post"},{"title":"java面向对象-接口和其他的类","author":"Jon","date":"2019-10-12T06:34:00.000Z","_content":"\n# 前言：\n\n**听我讲课也就图一乐，要想真学到东西还是得自己看书。**\n\n**大学学习最重要的莫过于是自学能力，我归纳的东西也许细节上有可能和书上有差异，因为我毕竟不是专业的，要想深究还是得对照书去看，我这只是对你们的一个引导**。\n\n\n\n**万物皆可为对象那么对象与对象之间肯定不是独立的，上节课谢磊学长讲了类的继承，那是一种最广泛的关系。今天我们了解一点更加抽象一点的东西，但是只要大家认真听我想还是会有所明白。**\n\n\n\n# 先来吹吹概念 \n\n**小恐龙镇压，让学习不再困难：**\n\n<img src=\"java面向对象-接口和其他的类/v2-db4581e2b067caef5a9586f7eebdf201_hd-1571838820692.jpg\" alt=\"img\" style=\"zoom: 50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-8a2e689837fdbbbf4b1ab294f9b8dd1e_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-61c75070123da9b76126716abb4c0dc0_hd-1571843419436.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-c73dbda0a22ac613aa85548743e89311_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-52943cfec07e50eccbe2b6f6e4c7afcb_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-621e04e365e7d4a385575811df365d92_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-71abcc971fa6b70a60fed90756317c19_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-aafe63145f01d7c98b9ca567484a2dea_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-a67b056f65147bc9971073f6b23d2aa3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-d238eb952899a0a26dd5b66a36f76c56_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-fdddf30851f4370410c068f923e0c405_hd-1571843588629.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-ea2fa82794080c01e783ce025c450116_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-c4f54c756177054f05115c55be8058d7_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-cf3a3ed1086e56442c381a3ee8a1fee9_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-1a566b02828b4759584f5a5e6fee2903_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-bffbbe33c937ceb498d0882bf21a651c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-75af770ceb10d0dcfbf702142f5c625b_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-325a1104a87fafd601284c628fa6aea9_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-23b4f1f3873f02b9e9abd2d1ab30a73f_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-ec6f0e0dfb5dc6805387101614784dcf_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-99e68ddacf27251a57bfffc82a43a2a0_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-7e64adbe12f97ac1fb00fc17d7d72f28_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-7a637419db11fb84c062b0361a4045db_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-bdb493d4a6d79ffa93fe78c71a2fd1a8_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-8312b637ba6407992515ffa42b56391d_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-bc2e4a10498c1b64a01628d0df373856_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-81940f37a0165b0459cb03241922e3ee_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-639605533bdb1ecf1c6562677a430554_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-45a9abdf48e6be17cb8d9e31b53578f9_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-02ffe126c98c17d03a83adad5f65938b_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-24c27adb48dfeffc6de36260df10bad5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-e608e1d4f94a6d0c06f9e9b78d5458b5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-05aa749d19004c9fea98e84fcea3307f_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-4d0519e265a57a53b7f92599fce86a9c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />  <img src=\"java面向对象-接口和其他的类/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-0bc6bbbfcf6d855c832b055aae892f1a_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-a959fa53966fc0b6400f88c50b8b95e3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-afd6a92d4313b460829bf99b7ef3759e_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-8d05da004dc65b91ffa63dcc213b7714_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-45b057e23dd633692fb0154f4a09ca49_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-53ac2d7b9f62a8ff17b795cc73570734_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-8c6c3bde98e8cf206839bf57085af02e_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-87072b9873cd5e8703a473b191e17042_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-f50699afeec4929bdc58d56db811bc47_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-e015f2d920aa5e00fa4b25d3b6a79bac_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-13d572e979351e77f984cd5b38a019b3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-cb5372ddead7e3c2bfcbc8e50e5e941f_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-e36c4694236b67a6e655c77d0e5336cf_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> ！\n\n## 接口\n\n> 接口最通俗的来讲就是一种统一的规范或者叫做协议，接口这个名称有点晦涩难懂，但是其实接口就是一个基于双方或者多方的协议\n>\n> 下面举几个例子：\n>\n> * 你们用的插座的插孔可以被叫做接口（协议），因为这个规范存在，在中国无论你是什么充电器，只要是这个充电口，那么我就会给你输出电流，至于你充什么，干什么我都不管。\n> * 你去面试，他说你必须有本科及以上的文凭且必须过了四级才能有面试资格，这也算事接口（协议），因为如果你没有这些东西，就不能去面试，至于你是怎么努力学习拿到本科文凭和怎么努力拿到四级证书的，一律不管。\n> * 我今天布置了作业，我要收的是我布置的这些作业，至于你们每个人怎么去做出来我是不管的，那我布置的作业就是接口（协议），你们按照题目实现相应的功能就好，最后验收我也只会根据我布置的作业的应该输出的结果来看你是不是完成作业。（当然，当然我在作业文件中指出你不能用啥，我还是会看的具体细节的）\n>\n> 现在，接口你们应该都应该大致明白是什么了吧。\n\n### 接口有什么作用？或者接口存在的必要性？\n\n> 还是上一节的例子，如果国家没有规定这个插座的标准，那每个厂家的有自己的一套，你买公牛的插座就得买支持公牛插座的电器。出去在中国其他地方旅游你就只有背着各式各样的转接头。嗯，锻炼身体也是好事嘛。\n>\n> 所以国家就制定了标准。\n>\n> 编程中接口也差不多，所以重要性也就凸显出来了\n\n### 编程中的接口？\n\n> **场景案例**：\n>\n> 现在开始你就是bat当中的员工之一，你的上级太多了，都要吩咐你做事：\n>\n> * 大boss想要员工会帮他给买部手机\n> * 二boss想要员工会销售一套房子\n> * 三boss想要员工会帮忙搭讪小姐姐\n> * 四boss想要员工会跟他一起打游戏\n> * ..............\n>\n> 一共有不知道多少个boss，总之你是底层员工嘛。\n>\n> 那么问题来了，这个员工类究竟得怎么设计呢，真是一个难题，而且老板们想要叫这个员工去做事的时候怎么知道这个员工会呢？\n>\n> 答案：\n>\n> 其实很简单，把这些行为统统抽象成接口。\n>\n> 例如：\n>\n> 定义下面一些接口：\n>\n> ```java\n> public interface BuyCellPhone {\n>     public void buycellphone();\n> }\n> ```\n>\n> ```java\n> public interface BuyHouse {\n>     public void buyHouse();\n> }\n> ```\n>\n> ```java\n> public interface TrickGirl {\n>     public void trickGirl();\n> }\n> ```\n>\n> ```java\n> public interface PlayingGamesTogether {\n>     public void playingGameTogether();\n> }\n> ```\n>\n> ...............................................................(此处还有无数个接口)\n>\n> 那么这些接口有什么用呢？\n>\n> 对应的老板只需要认识熟悉的接口就好（意思是只认你是否实现了这个接口），在需要的时候调用方法就好了，而不需要去了解认识每一个人。下面以大老板为例：\n>\n> 首先必须的有一个实现了这个\n>\n> ```java\n> /**\n>  * 实现了买手机这个功能接口的员工\n>  */\n> public class Staff implements BuyCellPhone {\n> \n>     private String name;\n>     private String sex;\n> \n>     public Staff(String name, String sex) {\n>         this.name = name;\n>         this.sex = sex;\n>     }\n> \n>     @Override\n>     public void buycellphone() {\n>         System.out.println(\"屁颠屁颠帮老板去买手机\");\n>     }\n> }\n> ```\n>\n> 此时身为老板的只需要只需要这样一个方法，就可以找个员工帮他买手机了，并且他可以完全不用了解这个员工谁，到底是干啥的，但是至少这人是实现了这个接口，就说明是有这个能力的\n>\n> ```java\n> public void lookingForSomeoneToBuyAMobilePhone(BuyCellPhone buyCellPhone) {\n>     buyCellPhone.buycellphone();\n> }\n> ```\n\n## 抽象类\n\n**<img src=\"java面向对象-接口和其他的类/164336559DA3C001F7D365CBC0A67998.jpg\" alt=\"164336559DA3C001F7D365CBC0A67998\" style=\"zoom:18%;\" />我都叫抽象类了，你说我抽象不抽象，我觉得我比上面那玩意儿抽象，你说呢？**\n\n###  黄坤坤告诉你到底有多抽象？\n\n**抽象？我叫抽象类我就抽象啦？那hljj是jj吗？**\n\n- **听听抽象类的自白**\n\n  **（抽象类独白）**：\n\n  ​\t\t天生就是用来被别人来继承的，简而言之，只有当爸爸的命，从不当儿子。可能有些事，必须得儿子去做，别直接叫我去做事。\n\n- ”**只当爸爸**“\n\n  说明被继承是绝对需要，大部分抽象类都是没有完整实现类功能的类，等待子类继承去实现，所以它是不可以被实例化成对像的。\n\n- “**有些事必须得儿子去做**”\n\n  说明它可能存在方法是抽象的，必须得子类去具体实现。\n\n- “**别直接叫我做事**”  \n\n  说明它是不可以直接示例化的。\n\n  \n\n### 好了，说完上面牵强的解释，现在我们来看看例子：\n\n  \n\n  \n\n![爸爸在呢 有事快说 - 和爸爸斗图 斗图+表情_爸爸_斗图表情](java面向对象-接口和其他的类/ceeb653ejw1fai8r9ct23j205c05q3yn.jpg)\n\n\n\n# 好了，开始开飞机了\n\n# 接口\n\n## 基本概念\n\n 接口，英文称作**interface**，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对**行为**的抽象。在Java中，定一个接口的形式如下： \n\n```java\npublic interface InterfaceName {\n\n}\n```\n\n需要注意的是:\n\n*  接口中的变量会被隐式地指定为public static final变量 \n\n  > 用其他关键词修饰会报错，例如：\n  >\n  > *  `public static final`，`private`\n\n*  方法会被隐式地指定为public abstract方法且只能是public abstract方法 \n\n  > 用其他关键词会报错，例如：\n  >\n  > *  `private`、`protected`、`static`、 `final`\n\n 接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。 \n\n 可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。 \n\n## 回调\n\n可能初识这个名词觉得高大上和陌生，下面我仔细的讲解一下回调到底是什么呢？\n\n**我在知乎上看到一个高赞回答：**\n\n> 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。\n\n这个回答在我学习接口时就看到了，但是当时还是一知半解，下面我们用代码来解释一下。\n\n首先我们定义一个接口`Notify`，通知接口\n\n```java\npublic interface Notify {\n    public void call();\n}\n```\n\n我们定义一个`Shop`类\n\n```java\npublic class Shop {\n\n    private Notify notify;\n\n    public void registrationNoticeMethod(Notify notify) {\n        this.notify = notify;\n    }\n\n    public void tellCustomerOutOfStock() {\n        System.out.println(\"对不起，我们这没有货了\");\n    }\n\n    public void arrivalNotice() {\n        if (notify != null) {\n            notify.call();\n        }\n    }\n}\n```\n\n定义一个顾客类`Customer`，并且让顾客类实现`Notify`这个接口\n\n```java\npublic class Customer implements Notify {\n    long phoneNum = 1234567;\n    \n    @Override\n    public void call() {\n        System.out.println(\"打电话给\" + phoneNum + \"通知到货了\");\n    }\n\n    public void goShopping() {\n        System.out.println(\"出门购物\");\n    }\n}\n```\n\n主程序：\n\n```java\n /**\n  * 主函数\n  */\npublic class Main {\n    public static void main(String[] args) {\n        //实例化对象\n        Customer customer = new Customer();\n        Shop shop = new Shop();\n\n        //顾客出门购物\n        customer.goShopping();\n        pause();\n        shop.tellCustomerOutOfStock();\n        pause();\n        shop.registrationNoticeMethod(customer);\n        //第二天到货了\n        System.out.println(\"第二天\");\n\n        shop.arrivalNotice();\n    }\n\n    /**\n     * 这个函数不用在意，只是为了演示效果，增加暂停\n     */\n    private static void pause() {\n        new Scanner(System.in).nextLine();\n    }\n}\n\n```\n\n输出：\n\n![TIM截图20191022120614](java面向对象-接口和其他的类/TIM截图20191022120614.png)\n\n[代码中的@Override注解说明](#这里其中有个注解)点击进入\n\n## 特殊的接口\n\n函数式接口\n\n简单来说，就是只有一个方法的接口。\n\n## 接口继承接口以及java8之后的接口多继承问题\n\n[详细解释链接](https://colobu.com/2014/11/04/Java-8-default-method-and-multiple-inheritance/)可能失效，我这里简述一下。\n\n#### java中不是没有多继承吗？\n\n**java8之前**\n\n是的，的确java中没有多继承，但是在java中接口是个例外，接口可以多继承，因为接口没有方法体，所以不论实现哪个父接口的中的方法都是没有关系的。\n\n**java8之后**\n\njava8之后出现了接口的默认实现，就像以下的模式：\n\n```java\npublic interface A {\n    default void hhh() {\n        System.out.println(\"我是B\");\n    }\n}\n```\n\n```java\npublic interface B {\n    default void hhh() {\n        System.out.println(\"我是C\");\n    }\n}\n```\n\n如果有个接口继承前两个接口，就必须把冲突的方法重写\n\n```java\npublic interface C extends A, B {\n   \n    @Override\n    default void hhh() {\n        \n    }\n}\n```\n\n如果有个类同时实现这两个接口也需要实现冲突默认方法\n\n```java\npublic class Test implements B, A {\n    @Override\n    public void hhh() {\n\n    }\n}\n```\n\n# 抽象类\n\n## 定义\n\n- 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。\n- 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。\n- 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。\n- 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。\n- 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n## 怎么使用\n\n#### 抽象类声明\n\n```java\n/**\n * 普通的类\n */\npublic class Test{\n    \n}\n\n/**\n * 抽象类\n */\npublic abstract class Test {\n\n}\n```\n\n声明一个java抽象类只需要在正常的类的class之前加上`abstract`\n\n#### 抽象方法声明\n\n```java\nabstract class A {\n    public abstract void a();\n}\n```\n\n## 使用时需要注意的：\n\n- 抽象类**不能被实例化**，实例化的工作应该交**由它的子类来完成**，它**只需要有一个引用即可**。\n\n  > ```java\n  > /**\n  >  * 生物抽象类（因为没有一个具体的实体可以是生物，所以应该被抽象为更高的抽象类）\n  >  */\n  > public abstract class Biological {\n  >     public void alive() {\n  > \n  >     }\n  > \n  >     public void death() {\n  > \n  >     }\n  > }\n  > ```\n  >\n  > ```java\n  > /**\n  >  * 人类，继承生物，可以没有自己的方法，全部是从抽象类继承的非抽象方法（注意：抽象类中有抽象方法子类必须实现）\n  >  */\n  > public class Person extends Biological {\n  > \n  > }\n  > ```\n  >\n  > 最重要的主程序来了，仔细看注释介绍\n  >\n  > ```java\n  > /**\n  >  * 主程序，以下只是演示，注释最重要\n  >  */\n  > public class Main {\n  >     public static void main(String[] args) {\n  >         Biological biological = new Person();//初始化时将人类的对象赋值给生物的引用时可以的\n  >         Person person = new Person();//生成一个人类的对象\n  >         biological = person;//将人类的对象复制给生物的引用也是没问题\n  >     }\n  > }\n  > ```\n\n- **抽象方法**必须**由子类来进行重写**。\n\n  > **抽象类**\n  >\n  > ```java\n  > /**\n  >  * 生物类\n  >  */\n  > public abstract class Biological {\n  > \n  >     public abstract void getEnergy();//增加了获取能量这个抽象方法\n  > \n  >     public void alive() {\n  > \n  >     }\n  > \n  >     public void death() {\n  > \n  >     }\n  > }\n  > ```\n  >\n  > 人类\n  >\n  > ```java\n  > /**\n  >  * 人类，继承生物，继承了两个非抽象方法，并实现了抽象方法\n  >  */\n  > public class Person extends Biological {\n  > \n  >     @Override\n  >     public void getEnergy() {//实现的抽象抽象方法\n  > \n  >     }\n  > }\n  > ```\n\n- 只要**包含一个抽象方法的抽象类**，该方法**必须要定义成抽象类**，不管是否还包含有其他方法。\n\n- 抽象类中**可以包含具体的方法**，当然**也可以不包含抽象方法**。\n\n  ```java\n  /**\n   * 有抽象方法的抽象类\n   */\n  public abstract class A {\n      public abstract void a();\n  }\n  ```\n\n  ```java\n  /**\n   * 没有抽象方法的抽象类\n   */\n  public abstract class B {\n      public void a() {\n  \n      }\n  }\n  ```\n\n- 子类中的抽象方法**不能**与父类的抽象方法**同名**。\n\n- `abstract`不能与`final`并列修饰同一个类。\n\n  > 这个显而易见，既然是抽象的，就必须需要时需要被子类实现的，所以不可能时final\n\n- `abstract` 不能与`private`、`static`、`final`或并列修饰同一个方法。\n\n  > `private`:抽象方法，必须是需要被继承的实现的，所以不可以用私有修饰符修饰\n  >\n  > `static`：同样，抽象方法是需要被实现的，但是静态方法是不可以被重写\n  >\n  > final：同上\n\n# 抽象类和接口的区别\n\n##  语法层面上的区别 \n\n- **抽象类**可以提供**成员方法的实现细节**，而**接口**中只能存在**public abstract 方法（在java8的之后接口）**；\n- **抽象类**中的成员变量可以是**各种类型**的，而**接口**中的成员变量只能是**public static final类型**的；\n- **接口**中**不能含有静态代码块**以及**静态方法**，而**抽象类**可以有**静态代码块**和**静态方法**；\n- 一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n## 设计层面上的区别\n\n- 抽象类是对一种**事物的抽象**，即**对类抽象**，而接口是**对行为的抽象**。\n\n- 抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n\n- 举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，**继承**是一个 \"**是不是**\"的关系，而 **接口** 实现则是 \"**有没有**\"的关系。\n\n- 如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而**接口实现则是有没有**、**具备不具备的关系**，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。\n\n- 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？ ？\n\n  >  最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。\n\n## 实际的例子\n\n下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n\n```java\n/**\n * 门的抽象类\n */\npublic abstract class DoorAbstract {\n\n    public abstract void open();\n\n    public abstract void close();\n}\n```\n\n　　或者：\n\n```java\n/**\n * 门的接口\n */\npublic interface DoorInterface {\n\n    public void open();\n\n    public void close();\n}\n```\n\n但是现在如果我们需要门具有**报警alarm( )**的功能，那么该如何实现？下面提供两种思路：\n\n- 将这三个功能都放在抽象类里面，但是这样一来**所有继承于这个抽象类的子类都具备了报警功能**，但是有的门并不一定具备报警功能；\n- 将这三个功能都放在接口里面，需要用到**报警功能的类就需要实现这个接口中的open( )和close( )**，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。\n\n很明显这个属性放到以上任何一个的当中都是不合适的，但是报警又是一个比较广泛的属性，java不支持多继承，所以最好将这个方法抽象到一个接口里面，这就是所谓的对行为抽象：\n\n```java\n/**\n * 报警的接口，所有实现了这个接口的类都是有报警这个功能\n */\npublic interface Alarm {\n    public void alarm();\n}\n```\n\n然后在对这个可以报警的门进行封装：\n\n```java\n/**\n * 可以报警的门\n */\npublic class AlarmDoor extends DoorAbstract implements Alarm {\n\n    @Override\n    public void alarm() {\n\n    }\n\n    @Override\n    public void open() {\n\n    }\n\n    @Override\n    public void close() {\n\n    }\n}\n```\n\n#### 这里其中有个注解\n\n@Override我简单说明一下（至于注解是啥，不详细的讲解了下节课会讲到）：\n\n`@Override`是伪代码,表示重写可以不写，不过写上有如下好处: \n\n- 可以当注释用,方便阅读，可以很明显的看到哪些方法是重写的方法；\n- 编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了，这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)。\n\n对于这里而言第二个作用是没有作用的，因为如果继承了抽象类，如果抽象类中含有抽象方法，必须实现这个方法不然编译器也会报错，接口也是同样的，前面说到接口中的方法默认是`public abstract`。\n\n# 内部类\n\n 顾名思义：可以将一个类的定义放在另一个类的定义内部，这就是内部类。 <img src=\"java面向对象-接口和其他的类/v2-2b4d1f67bd8f8aaecb32920c58cd687c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n## 怎么用？\n\n```java\n/**\n * 类中定义类\n */\npublic  class A {\n    \n    \n    class B {\n        \n    }\n}\n```\n\n\n\n好了，你现在已经会了内部类了，你看多简单呐     <img src=\"java面向对象-接口和其他的类/v2-8da4b48b8262d2786486cb942571be4c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n好了开玩笑的啦。<img src=\"java面向对象-接口和其他的类/v2-db4581e2b067caef5a9586f7eebdf201_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n## 内部类小飞机\n\n## 为什么要使用内部类？\n\n​\t\t在《Think in java》也就是《java编程思想》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 \n\n​\t\t在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。\n\n<img src=\"java面向对象-接口和其他的类/v2-acb2c980db4a235ed0538f34d9c2918d_hd-1571748707404.jpg\" alt=\"img\" style=\"zoom: 33%;\" />  完了上面这么简单的描述还听不懂 ，听不懂没关系，这样说我也不懂，来慢慢分析。\n\n```java\npublic interface Father {\n\n}\n```\n\n```java\npublic interface Mother {\n\n}\n```\n\n接下来骚操作来了：\n\n你可以这样子\n\n```java\npublic class Son implements Father, Mother {\n\n}\n```\n\n也可以这样子\n\n```java\npublic class Daughter implements Father{\n\n    class Mother implements Mother{\n        \n    }\n}\n```\n\n但是，不是一个类可以实现多个接口嘛，第二种实现还有什么意义呢。\n\n那么问题来了，如果爸爸妈妈他们不是接口而是一个抽象类或者类呢？现在应该理解更为深刻了。\n\n\n\n## 内部类基础\n\n`.this`和`.new`语法\n\n 当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。 \n\n**内部类如何访问外围类的东西呢？**\n\n> 当然直接用变量名就可以访问啦\n>\n> 原因？（凡事要解释得通才行嘛）\n>\n> > 其实在内部类对象中保存了一个对外部类对象的引用，当在内部类的成员方法中访问某一变量时，如果在该方法和内部类中都没有定义过这个变量，（如果有这个变量的话，或者外部类的某个成员变量与内部类的成员变量相同eg:在内部类中定义 **private String name;** 那么访问的则是内部类的这个变量）调用就会被传递给内部类中的那个对外部类对象的引用，通过这个引用去调用这个变量。在内部类调用外部类的方法也是同样的一个道理（还是这个内部类对象保存了一个对外部类的引用）。 \n\n**内部类如何获取外围类的对象呢？（.this）**\n\n> 这样子：\n>\n> ```java\n> /**\n>  * 内部类示例\n>  */\n> public  class A {\n>     String s = \"\";\n> \n>     class B {\n>         public void lala() {\n>             A a = A.this;  //关键的地方\n>         }\n>     }\n> }\n> ```\n\n**如何创建内部类的对象呢？**\n\n> **在外围类内**\n>\n> ```java\n> /**\n>  * 内部类示例\n>  */\n> public  class A {\n>     String s = \"\";\n> \n>     public void lala() {\n>         B b = new B();  //关键的地方\n>     }\n> \n>     class B {\n> \n>     }\n> }\n> ```\n>\n> **在外围类外（也就是在其他地方）：**（.new）\n>\n> ```java\n> A a = new A();\n> A.B b = a.new B();\n> ```\n\n 到这里了我们需要明确一点，**内部类是个编译时的概念**，一旦编译成功后，它就与外围类**属于两个完全不同的类**（当然他们之间还是有联系的）。对于一个名为A的外围类和一个名为B的内部类，在编译成功后，会出现这样两个class文件：**OuterClass.class和OuterClass$InnerClass.class。** \n\n关于java编译运行有兴趣了解[自己了解](http://jontree.github.io/2019/10/23/java%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3)（之前不是很多同学用命令行javac  和 java命令嘛）\n\n## 内部类的分类\n\n### 成员内部类\n\n-  成员内部类中不能存在任何static的变量和方法；\n- 成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。 \n\n例子：\n\n```java\n/**\n * 类中定义类\n */\npublic  class A {\n    \n    \n    class B {\n        \n    }\n}\n```\n\n对就是这种最简单的内部类\n\n### 局部内部类\n\n* 嵌套在方法或者作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题\n\n  >嵌套在方法中很简单，直接在方法里面写类嘛，到那时嵌套在作用域里面怎么回事，这说明直接随便在一个类中随便找个位置，写个大括号，大括号中中也是可以写局部内部类的\n  >\n  >例如：（这个简单例子可能有点绕）\n  >\n  >```java\n  >/**\n  > * 含有局部内部类的类B\n  > */\n  >class B{\n  >    \t{\t\t\t\t\t\t//这是一个静态代码块\n  >       \t\t class C{\t\t\t//这是一个局部内部类，作用域就在静态代码块中\n  >            \n  >       \t\t }\n  >    \t}\n  >}\n  >```\n  >\n  >\n\n* 通常是想创建一个类来辅助我们的解决方案，但那时又不希望这个类是公共可用的，所以就产生了局部内部类\n\n* 局部内部类和成员内部类一样被编译，只是它的作用域发生了改变\n\n* 它只能在该方法和属性中被使用，出了该方法和属性就会失效 \n\n  首先为了方便，我门先定义一个接口：\n\n  ```java\n  /**\n   * 口接口A\n   */\n  interface A{\n      \n  }\n  ```\n\n  下面开始正式的例子：\n\n  可以返回局部内部类实例化对象的函数（下面有个类B，里面有个方法返回A的引用，并且函数体里面有个实现了接口A的局部内部类C）\n\n  ```java\n  /**\n   * 含有局部内部类的类B\n   */\n  class B{\n      public A lala() {\n          class C implements A{\n  \n          }\n          return new C();\n      }\n  }\n  ```\n\n  你可以直接这样子定义然后在方法中使用（作用域在方法内）\n\n  ```java\n  /**\n   * 含有局部内部类的类B\n   */\n  class B{\n      public void lala() {\n          class C {\n              \n          }\n          C c = new C();\n          \n      }\n  }\n  ```\n\n\n### 匿名内部类\n\n#### 咋写？\n\n首先定义一个接口，一个抽象类，和一个简单的类\n\n```java\n/**\n * 我是一个冷漠无情的简单接口A\n */\npublic interface A {\n    public void a();\n}\n```\n\n```java\n/**\n * 我是一个冷漠无情的简单抽象类B\n */\npublic abstract class B {\n    public abstract void b();\n}\n```\n\n```java\n/**\n * 我是一个冷漠无情的超简单普通类\n */\npublic class C {\n    public void c() {\n\n    }\n}\n```\n\n好了，有了上面的基础，我们就来演示一下匿名内部类：\n\n```java\npublic class D {\n    public static void main(String[] args) {\n        new A() {//继承接口A的匿名内部类\n            @Override\n            public void a() {\n\n            }\n        \n        };\n\n        new B() {//继承抽象类B的内部类\n            @Override\n            public void b() {\n\n            }\n        };\n\n        new C() {//继承普通类C的匿名内部类\n\n        };\n    }\n}\n```\n\n#### 内部类的注意事项\n\n-  匿名内部类是没有访问修饰符的。\n\n- new 匿名内部类，这个类首先是要存在的。如果我们将接口注释掉，就会出现编译出错。\n\n  > 例子同上第二个，如果不用B这个现有的接口的话例如这样子写，是会报错的：\n  >\n  > ```java\n  >   new () {\n  >             @Override\n  >             public void b() {\t\t\t\t//超级错误的写法，谁这样写谁要被打手板\n  > \n  >             }\n  >         };\n  > ```\n  >\n  > \n\n- java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final\n\n  > <img src=\"java面向对象-接口和其他的类/v2-32db3eeb7c9cb282553504e2c1108130_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />你是啥意思呀，完全不懂你说的啥啊，这又是啥狗屁啊，小丁学长你在开啥飞机。\n  >\n  > emmmmmmm，好的，那我们来举例子    <img src=\"java面向对象-接口和其他的类/ceeb653ejw1faoq48816nj208z0buaan.jpg\" alt=\"举个栗子 - 后退，我要开始装逼了_表情头牌_蘑菇头_搞笑对话表情\" style=\"zoom:10%;\" />\n  >\n  > 首先我们定义一个接口，做准备。\n  >\n  > ```java\n  > /**\n  >  * 我是一个冷漠无情的简单接口A\n  > */\n  > public interface A {\n  > public void a();\n  > }\n  > ```\n  >\n  > 然后我门再写一个普通类B，后面修改B来挨个测试\n  >\n  > ```java\n  > /**\n  >  * 我是一个冷漠无情的简单类B\n  > */\n  > public  class B {\n  > int a = 0;\n  > public void b() {\n  >   int b = 0;\n  >   new A() {\n  >       @Override\n  >       public void a() {\n  > \n  >       }\n  >   };\n  >   \n  > }\n  > }\n  > ```\n  >\n  > **首先我们测试在方法里面的内部类，这个也是我们最常用的。我们在内部类实现的方法里面直接输出b看并且不把变量b设置为final**\n  >\n  > ```java\n  > /**\n  >  * 冷漠无情的简单类B我又来了\n  > */\n  > public  class B {\n  > int a = 0;\n  > public void b() {\n  >   int b = 0;\n  >   new A() {\n  >       @Override\n  >       public void a() {\n  >           System.out.println(b);//编译是能通过的，不会报错的\n  >       }\n  >   };\n  > \n  > }\n  > }\n  > ```\n  >\n  > <img src=\"java面向对象-接口和其他的类/v2-72c27a074e1feb699849c4d9d8c2614c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> 是不是讲错了，咋不需要变量b咋不需要final就能通过，翻车了。\n  >\n  > 百度谷歌一番，我找到这样一句话。\n  >\n  > ![TIM截图20191024013553](java面向对象-接口和其他的类/TIM截图20191024013553.png)\n  >\n  > emmm，那究竟是不是这样子呢？再来康康？我们这次在上面那个内部类直接修改变量b的值。看可不可以呢。\n  >\n  > ```java\n  > /**\n  >  * 我是一个冷漠无情的简单类B\n  > */\n  > public  class B {\n  > int a = 0;\n  > public void b() {\n  >   int b = 0;\n  >   new A() {\n  >       @Override\n  >       public void a() {\n  >           b = 99;\t\t\t\t\t//关键部位（也是报错部位）\n  >       }\n  >   };\n  > \n  > }\n  > }\n  > ```\n  >\n  > 编译之后，果然报错了，错误如下：\n  >\n  > ![TIM截图20191024014025](java面向对象-接口和其他的类/TIM截图20191024014025.png)\n  >\n  > 安心了，我们继续开飞机：\n  >\n  >\n  > 下面这两个用法，我估计你今后写10万行代码都遇不上一次这样写的，但是为了验证以上话是正确的，我们得试试。\n  >\n  > **第二项测试，在匿名内部类中类的静态代码块使用外部作用域里面的变量（因为是java有自动final修饰我们下面几次测试都使用直接更改外部作用域变量来测试【即：直接更改变量b的值】）**\n  >\n  > ```java\n  > /**\n  >  * 我是一个冷漠无情的简单类B,我又出现了\n  > */\n  > public  class B {\n  > int a = 0;\n  > public void b() {\n  >   int b = 0;\n  >   new A() {\n  >       {\n  >           b = 99;\t\t\t//关键部分\n  >       }\n  >       @Override\n  >       public void a() {\n  >           \n  >       }\n  >   };\n  > \n  > }\n  > }\n  > ```\n  >\n  > 好的我来编译一下\n  >\n  > ![TIM截图20191024014025](java面向对象-接口和其他的类/TIM截图20191024014025.png)\n  >\n  > 好的继续报错，而且还是这个错，nice说明，那句话更加正确了，`java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final`\n  >\n  > \n  >\n  > **那么接下来我们来测试最后一项测试，我们在匿名内部类中访问外围类中的属性，看能不能修改**\n  >\n  > ```java\n  > /**\n  >  * 我是一个冷漠无情的简单类B,我又出现了\n  > */\n  > public  class B {\n  > int a = 0;\n  > public void b() {\n  >   int b = 0;\n  >   new A() {\n  >       @Override\n  >       public void a() {\n  >           a = 99;\t\t\t\t//关键部分（没报错）\n  >       }\n  >   };\n  > \n  > }\n  > }\n  > ```\n  >\n  > 编译一下，没错？运行一下，没有报错？woc，emmmmmm，<img src=\"java面向对象-接口和其他的类/v2-72c27a074e1feb699849c4d9d8c2614c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n  >\n  > 找找原因，于是我们在再在B类中添加一个普通内部类，如下：\n  >\n  > ```java\n  > /**\n  >  * 我是一个的简单类B,这次我可不简单了\n  > */\n  > public  class B {\n  > int a = 0;\n  > public void b() {\n  >   int b = 0;\n  >   new A() {\t\t\t//匿名内部类\n  >       @Override\n  >       public void a() {\n  >           a = 99;\n  >       }\n  >   };\n  > }\n  > \n  > class C {\t\t\t\t//简单内部类C\n  >   public void c() {\n  > \n  >   }\n  > }\n  > }\n  > ```\n  >\n  > 前面我们说了，\n  > 找找原因，为啥没有报错，前面我们说内部类基础得时候，我们说是内部类是持有外围类得引用的，所以会智能的可以直接使用外围类的成员属性。\n  >\n  >\n  > 我们编译B类，然后出现了如下文件：\n  >\n  > ![TIM截图20191024021220](java面向对象-接口和其他的类/TIM截图20191024021220.png)\n  >\n  > 咦，难道匿名内部类也会储存外围类的引用🐎，是不是我们具体来康康。\n  >\n  > 我们先来看看B类编译之后反编译的代码\n  >\n  > ```java\n  > public class B {\n  > int a = 0;\n  > \n  > public B() {\n  > }\n  > \n  > public void b() {\n  >   int b = false;\n  >   A var10001 = new A() {\n  >       public void a() {\n  >           B.this.a = 99;\n  >       }\n  >   };\n  > }\n  > \n  > class C {\n  >   C() {\n  >   }\n  > \n  >   public void c() {\n  >   }\n  > }\n  > }\n  > ```\n  >\n  > 没有太大的区别，唯一的区别就是变量b，原本的0的值变成了布尔类型，这是为啥呢？\n  >\n  > \n  >\n  > 还问为啥？是要我开火箭嘛，这篇课件不是因为“为啥”会有13000+的字嘛？？你仔细想想，写个程序要那么多为什么吗？？您好要的。最简单的来说这是编译器的一个优化，你这个值没有使用，为啥要给你要存一个整形，整形相对于布尔类型还是蛮大的，自己康康，整整四倍呢。。。。。。\n  >\n  > | 类型    | 存储需求 | bit 数 | 取值范围               | 备注                                                         |\n  > | ------- | -------- | ------ | ---------------------- | ------------------------------------------------------------ |\n  > | int     | 4字节    | 4*8    | -2147483648~2147483647 | 即 (-2)的31次方 ~ (2的31次方) - 1                            |\n  > | short   | 2字节    | 2*8    | -32768~32767           | 即 (-2)的15次方 ~ (2的15次方) - 1                            |\n  > | long    | 8字节    | 8*8    |                        | 即 (-2)的63次方 ~ (2的63次方) - 1                            |\n  > | byte    | 1字节    | 1*8    | -128~127               | 即 (-2)的7次方 ~ (2的7次方) - 1                              |\n  > | float   | 4字节    | 4*8    |                        | float 类型的数值有一个后缀 F（例如：3.14F）                  |\n  > | double  | 8字节    | 8*8    |                        | 没有后缀 F 的浮点数值（例如：3.14）默认为 double             |\n  > | boolean | 1字节    | 1*8    | true、false            |                                                              |\n  > | char    | 2字节    | 2*8    |                        | Java中，只要是字符，不管是数字还是英文还是汉字，都占两个字节。 |\n  >\n  > **再来看看B$C.class，验证是否持有外围类的引用**\n  >\n  > ```java\n  > class B$C {\n  > B$C(B this$0) {\n  >   this.this$0 = this$0;\n  > }\n  > \n  > public void c() {\n  > }\n  > }\n  > ```\n  >\n  > 嗯，作为内部类，持有外围类的应用，**正解**。这里只能看到外围类的引用传进来了，那系统是怎么使用的呢？<img src=\"java面向对象-接口和其他的类/006APoFYjw1fbw78x1kr4g308c08caa2-1571887367591.gif\" alt=\"兔子摔地上 - 吐血表情包_动图_吐血表情\" style=\"zoom:15%;\" />  保存和使用是jvm级别的事，这里就详细讲了，我还没怎么看呢。\n  >\n  > \n  >\n  > **好的关键部分了，我们再来看看B$1.class反编译的结果**\n  >\n  > ```java\n  > class B$1 implements A {\n  >  B$1(B this$0) {\n  >      this.this$0 = this$0;\n  >  }\n  > \n  >  public void a() {\n  >      this.this$0.a = 99;\n  >  }\n  > }\n  > ```\n  >\n  > <img src=\"java面向对象-接口和其他的类/9150e4e5gy1g6o895cawsj20sg0sg76j.jpg\" alt=\"原来是这么回事！这下谜解开了（哆啦A梦表情包）_这么回事_这下_解开_原来表情\" style=\"zoom:18%;\" />  看到没有，匿名内部类也是会保存外围类的引用的\n  >\n  > \n  >\n  >\n  > 好了这下说明我上面那句话是对的，nice，那么问题又来了。\n  >\n  > \n  >\n  > **为什么一定要是final<img src=\"java面向对象-接口和其他的类/v2-114ee3caaad0d612d39818c9f3f81201_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />？？？**<img src=\"java面向对象-接口和其他的类/006APoFYjw1fbw78x1kr4g308c08caa2-1571887367591.gif\" alt=\"兔子摔地上 - 吐血表情包_动图_吐血表情\" style=\"zoom:15%;\" />**你们吐血没？？反正我吐了**\n  >\n  > 好的，我们来讲\n  >\n  > 那么又来了一个名词，“**闭包**”\n  >\n  > 闭包是什么呢？来听听大牛的说的他认为最通俗易懂的答案：\n  >\n  > 1. 一个依赖于外部环境自由变量的函数\n  > 2. 这个函数能够访问外部环境里的自由变量\n  >\n  > 哦豁，<img src=\"java面向对象-接口和其他的类/v2-746b68b4c2149a0faef9f4ec9a4e8e92_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> 还是不明白，好的，那么你继续听我慢慢分析\n  >\n  > 首先我们定义一个接口，做准备准备工作。\n  >\n  > \n  >\n  > `不准备了，不准备了，自己百度看教程吧，再准备这课件起码到20000字了。`\n  >\n  > \n  >\n  > 这里附两个[java中的final讲解](https://blog.csdn.net/jiao_zg/article/details/78911469)   [闭包讲解](https://www.zhihu.com/question/24084277/answer/110176733)其实分为java8之前之后\n  >\n\n- 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。\n\n  > 咦，上面不是反编译之后有构造方法吗？\n  >\n  > 不对不对，我这说的是使用内部类的时候，不能有构造方法，你都直接，反编译时出现的构造方法是系统在你生成匿名内部类对象时默认调用的构造方法，因为再怎么它也是个类嘛，还是有类的尊严的。\n  >\n  >\n  > 【内部类自白】：怎么人家成为你对象也是条件的嘛<img src=\"java面向对象-接口和其他的类/6af89bc8gw1f8tzg6lig0g209m073x6p.gif\" alt=\"二次元妹子害羞了（亲亲）_二次元_亲亲_害羞表情\" style=\"zoom: 25%;\" />，没有构造方法怎么行\n\n### 静态内部类\n\n*  非静态内部类在编译完成之后会隐含地保存着一个引用 \n\n*  它的创建是不需要依赖于外围类的\n*  它不能使用任何外围类的非static成员变量和方法。 \n\n\n","source":"_posts/java面向对象-接口和其他的类.md","raw":"title: java面向对象-接口和其他的类\ntags:\n\n  - java\n  - 课件\ncategories:\n  - java\nauthor: Jon\ndate: 2019-10-12 14:34:00\n\n---\n\n# 前言：\n\n**听我讲课也就图一乐，要想真学到东西还是得自己看书。**\n\n**大学学习最重要的莫过于是自学能力，我归纳的东西也许细节上有可能和书上有差异，因为我毕竟不是专业的，要想深究还是得对照书去看，我这只是对你们的一个引导**。\n\n\n\n**万物皆可为对象那么对象与对象之间肯定不是独立的，上节课谢磊学长讲了类的继承，那是一种最广泛的关系。今天我们了解一点更加抽象一点的东西，但是只要大家认真听我想还是会有所明白。**\n\n\n\n# 先来吹吹概念 \n\n**小恐龙镇压，让学习不再困难：**\n\n<img src=\"java面向对象-接口和其他的类/v2-db4581e2b067caef5a9586f7eebdf201_hd-1571838820692.jpg\" alt=\"img\" style=\"zoom: 50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-8a2e689837fdbbbf4b1ab294f9b8dd1e_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-61c75070123da9b76126716abb4c0dc0_hd-1571843419436.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-c73dbda0a22ac613aa85548743e89311_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-52943cfec07e50eccbe2b6f6e4c7afcb_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-621e04e365e7d4a385575811df365d92_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-71abcc971fa6b70a60fed90756317c19_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-aafe63145f01d7c98b9ca567484a2dea_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-a67b056f65147bc9971073f6b23d2aa3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-d238eb952899a0a26dd5b66a36f76c56_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-fdddf30851f4370410c068f923e0c405_hd-1571843588629.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-ea2fa82794080c01e783ce025c450116_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-c4f54c756177054f05115c55be8058d7_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-cf3a3ed1086e56442c381a3ee8a1fee9_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-1a566b02828b4759584f5a5e6fee2903_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-bffbbe33c937ceb498d0882bf21a651c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-75af770ceb10d0dcfbf702142f5c625b_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-325a1104a87fafd601284c628fa6aea9_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-23b4f1f3873f02b9e9abd2d1ab30a73f_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-ec6f0e0dfb5dc6805387101614784dcf_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-99e68ddacf27251a57bfffc82a43a2a0_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-7e64adbe12f97ac1fb00fc17d7d72f28_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-7a637419db11fb84c062b0361a4045db_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-bdb493d4a6d79ffa93fe78c71a2fd1a8_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-8312b637ba6407992515ffa42b56391d_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-bc2e4a10498c1b64a01628d0df373856_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-81940f37a0165b0459cb03241922e3ee_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-639605533bdb1ecf1c6562677a430554_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-45a9abdf48e6be17cb8d9e31b53578f9_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-02ffe126c98c17d03a83adad5f65938b_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-24c27adb48dfeffc6de36260df10bad5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-e608e1d4f94a6d0c06f9e9b78d5458b5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-05aa749d19004c9fea98e84fcea3307f_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-4d0519e265a57a53b7f92599fce86a9c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />  <img src=\"java面向对象-接口和其他的类/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-0bc6bbbfcf6d855c832b055aae892f1a_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-a959fa53966fc0b6400f88c50b8b95e3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-afd6a92d4313b460829bf99b7ef3759e_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-8d05da004dc65b91ffa63dcc213b7714_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-45b057e23dd633692fb0154f4a09ca49_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-53ac2d7b9f62a8ff17b795cc73570734_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-8c6c3bde98e8cf206839bf57085af02e_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-87072b9873cd5e8703a473b191e17042_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-f50699afeec4929bdc58d56db811bc47_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-e015f2d920aa5e00fa4b25d3b6a79bac_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-13d572e979351e77f984cd5b38a019b3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-cb5372ddead7e3c2bfcbc8e50e5e941f_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> <img src=\"java面向对象-接口和其他的类/v2-e36c4694236b67a6e655c77d0e5336cf_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> ！\n\n## 接口\n\n> 接口最通俗的来讲就是一种统一的规范或者叫做协议，接口这个名称有点晦涩难懂，但是其实接口就是一个基于双方或者多方的协议\n>\n> 下面举几个例子：\n>\n> * 你们用的插座的插孔可以被叫做接口（协议），因为这个规范存在，在中国无论你是什么充电器，只要是这个充电口，那么我就会给你输出电流，至于你充什么，干什么我都不管。\n> * 你去面试，他说你必须有本科及以上的文凭且必须过了四级才能有面试资格，这也算事接口（协议），因为如果你没有这些东西，就不能去面试，至于你是怎么努力学习拿到本科文凭和怎么努力拿到四级证书的，一律不管。\n> * 我今天布置了作业，我要收的是我布置的这些作业，至于你们每个人怎么去做出来我是不管的，那我布置的作业就是接口（协议），你们按照题目实现相应的功能就好，最后验收我也只会根据我布置的作业的应该输出的结果来看你是不是完成作业。（当然，当然我在作业文件中指出你不能用啥，我还是会看的具体细节的）\n>\n> 现在，接口你们应该都应该大致明白是什么了吧。\n\n### 接口有什么作用？或者接口存在的必要性？\n\n> 还是上一节的例子，如果国家没有规定这个插座的标准，那每个厂家的有自己的一套，你买公牛的插座就得买支持公牛插座的电器。出去在中国其他地方旅游你就只有背着各式各样的转接头。嗯，锻炼身体也是好事嘛。\n>\n> 所以国家就制定了标准。\n>\n> 编程中接口也差不多，所以重要性也就凸显出来了\n\n### 编程中的接口？\n\n> **场景案例**：\n>\n> 现在开始你就是bat当中的员工之一，你的上级太多了，都要吩咐你做事：\n>\n> * 大boss想要员工会帮他给买部手机\n> * 二boss想要员工会销售一套房子\n> * 三boss想要员工会帮忙搭讪小姐姐\n> * 四boss想要员工会跟他一起打游戏\n> * ..............\n>\n> 一共有不知道多少个boss，总之你是底层员工嘛。\n>\n> 那么问题来了，这个员工类究竟得怎么设计呢，真是一个难题，而且老板们想要叫这个员工去做事的时候怎么知道这个员工会呢？\n>\n> 答案：\n>\n> 其实很简单，把这些行为统统抽象成接口。\n>\n> 例如：\n>\n> 定义下面一些接口：\n>\n> ```java\n> public interface BuyCellPhone {\n>     public void buycellphone();\n> }\n> ```\n>\n> ```java\n> public interface BuyHouse {\n>     public void buyHouse();\n> }\n> ```\n>\n> ```java\n> public interface TrickGirl {\n>     public void trickGirl();\n> }\n> ```\n>\n> ```java\n> public interface PlayingGamesTogether {\n>     public void playingGameTogether();\n> }\n> ```\n>\n> ...............................................................(此处还有无数个接口)\n>\n> 那么这些接口有什么用呢？\n>\n> 对应的老板只需要认识熟悉的接口就好（意思是只认你是否实现了这个接口），在需要的时候调用方法就好了，而不需要去了解认识每一个人。下面以大老板为例：\n>\n> 首先必须的有一个实现了这个\n>\n> ```java\n> /**\n>  * 实现了买手机这个功能接口的员工\n>  */\n> public class Staff implements BuyCellPhone {\n> \n>     private String name;\n>     private String sex;\n> \n>     public Staff(String name, String sex) {\n>         this.name = name;\n>         this.sex = sex;\n>     }\n> \n>     @Override\n>     public void buycellphone() {\n>         System.out.println(\"屁颠屁颠帮老板去买手机\");\n>     }\n> }\n> ```\n>\n> 此时身为老板的只需要只需要这样一个方法，就可以找个员工帮他买手机了，并且他可以完全不用了解这个员工谁，到底是干啥的，但是至少这人是实现了这个接口，就说明是有这个能力的\n>\n> ```java\n> public void lookingForSomeoneToBuyAMobilePhone(BuyCellPhone buyCellPhone) {\n>     buyCellPhone.buycellphone();\n> }\n> ```\n\n## 抽象类\n\n**<img src=\"java面向对象-接口和其他的类/164336559DA3C001F7D365CBC0A67998.jpg\" alt=\"164336559DA3C001F7D365CBC0A67998\" style=\"zoom:18%;\" />我都叫抽象类了，你说我抽象不抽象，我觉得我比上面那玩意儿抽象，你说呢？**\n\n###  黄坤坤告诉你到底有多抽象？\n\n**抽象？我叫抽象类我就抽象啦？那hljj是jj吗？**\n\n- **听听抽象类的自白**\n\n  **（抽象类独白）**：\n\n  ​\t\t天生就是用来被别人来继承的，简而言之，只有当爸爸的命，从不当儿子。可能有些事，必须得儿子去做，别直接叫我去做事。\n\n- ”**只当爸爸**“\n\n  说明被继承是绝对需要，大部分抽象类都是没有完整实现类功能的类，等待子类继承去实现，所以它是不可以被实例化成对像的。\n\n- “**有些事必须得儿子去做**”\n\n  说明它可能存在方法是抽象的，必须得子类去具体实现。\n\n- “**别直接叫我做事**”  \n\n  说明它是不可以直接示例化的。\n\n  \n\n### 好了，说完上面牵强的解释，现在我们来看看例子：\n\n  \n\n  \n\n![爸爸在呢 有事快说 - 和爸爸斗图 斗图+表情_爸爸_斗图表情](java面向对象-接口和其他的类/ceeb653ejw1fai8r9ct23j205c05q3yn.jpg)\n\n\n\n# 好了，开始开飞机了\n\n# 接口\n\n## 基本概念\n\n 接口，英文称作**interface**，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对**行为**的抽象。在Java中，定一个接口的形式如下： \n\n```java\npublic interface InterfaceName {\n\n}\n```\n\n需要注意的是:\n\n*  接口中的变量会被隐式地指定为public static final变量 \n\n  > 用其他关键词修饰会报错，例如：\n  >\n  > *  `public static final`，`private`\n\n*  方法会被隐式地指定为public abstract方法且只能是public abstract方法 \n\n  > 用其他关键词会报错，例如：\n  >\n  > *  `private`、`protected`、`static`、 `final`\n\n 接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。 \n\n 可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。 \n\n## 回调\n\n可能初识这个名词觉得高大上和陌生，下面我仔细的讲解一下回调到底是什么呢？\n\n**我在知乎上看到一个高赞回答：**\n\n> 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。\n\n这个回答在我学习接口时就看到了，但是当时还是一知半解，下面我们用代码来解释一下。\n\n首先我们定义一个接口`Notify`，通知接口\n\n```java\npublic interface Notify {\n    public void call();\n}\n```\n\n我们定义一个`Shop`类\n\n```java\npublic class Shop {\n\n    private Notify notify;\n\n    public void registrationNoticeMethod(Notify notify) {\n        this.notify = notify;\n    }\n\n    public void tellCustomerOutOfStock() {\n        System.out.println(\"对不起，我们这没有货了\");\n    }\n\n    public void arrivalNotice() {\n        if (notify != null) {\n            notify.call();\n        }\n    }\n}\n```\n\n定义一个顾客类`Customer`，并且让顾客类实现`Notify`这个接口\n\n```java\npublic class Customer implements Notify {\n    long phoneNum = 1234567;\n    \n    @Override\n    public void call() {\n        System.out.println(\"打电话给\" + phoneNum + \"通知到货了\");\n    }\n\n    public void goShopping() {\n        System.out.println(\"出门购物\");\n    }\n}\n```\n\n主程序：\n\n```java\n /**\n  * 主函数\n  */\npublic class Main {\n    public static void main(String[] args) {\n        //实例化对象\n        Customer customer = new Customer();\n        Shop shop = new Shop();\n\n        //顾客出门购物\n        customer.goShopping();\n        pause();\n        shop.tellCustomerOutOfStock();\n        pause();\n        shop.registrationNoticeMethod(customer);\n        //第二天到货了\n        System.out.println(\"第二天\");\n\n        shop.arrivalNotice();\n    }\n\n    /**\n     * 这个函数不用在意，只是为了演示效果，增加暂停\n     */\n    private static void pause() {\n        new Scanner(System.in).nextLine();\n    }\n}\n\n```\n\n输出：\n\n![TIM截图20191022120614](java面向对象-接口和其他的类/TIM截图20191022120614.png)\n\n[代码中的@Override注解说明](#这里其中有个注解)点击进入\n\n## 特殊的接口\n\n函数式接口\n\n简单来说，就是只有一个方法的接口。\n\n## 接口继承接口以及java8之后的接口多继承问题\n\n[详细解释链接](https://colobu.com/2014/11/04/Java-8-default-method-and-multiple-inheritance/)可能失效，我这里简述一下。\n\n#### java中不是没有多继承吗？\n\n**java8之前**\n\n是的，的确java中没有多继承，但是在java中接口是个例外，接口可以多继承，因为接口没有方法体，所以不论实现哪个父接口的中的方法都是没有关系的。\n\n**java8之后**\n\njava8之后出现了接口的默认实现，就像以下的模式：\n\n```java\npublic interface A {\n    default void hhh() {\n        System.out.println(\"我是B\");\n    }\n}\n```\n\n```java\npublic interface B {\n    default void hhh() {\n        System.out.println(\"我是C\");\n    }\n}\n```\n\n如果有个接口继承前两个接口，就必须把冲突的方法重写\n\n```java\npublic interface C extends A, B {\n   \n    @Override\n    default void hhh() {\n        \n    }\n}\n```\n\n如果有个类同时实现这两个接口也需要实现冲突默认方法\n\n```java\npublic class Test implements B, A {\n    @Override\n    public void hhh() {\n\n    }\n}\n```\n\n# 抽象类\n\n## 定义\n\n- 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。\n- 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。\n- 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。\n- 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。\n- 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n## 怎么使用\n\n#### 抽象类声明\n\n```java\n/**\n * 普通的类\n */\npublic class Test{\n    \n}\n\n/**\n * 抽象类\n */\npublic abstract class Test {\n\n}\n```\n\n声明一个java抽象类只需要在正常的类的class之前加上`abstract`\n\n#### 抽象方法声明\n\n```java\nabstract class A {\n    public abstract void a();\n}\n```\n\n## 使用时需要注意的：\n\n- 抽象类**不能被实例化**，实例化的工作应该交**由它的子类来完成**，它**只需要有一个引用即可**。\n\n  > ```java\n  > /**\n  >  * 生物抽象类（因为没有一个具体的实体可以是生物，所以应该被抽象为更高的抽象类）\n  >  */\n  > public abstract class Biological {\n  >     public void alive() {\n  > \n  >     }\n  > \n  >     public void death() {\n  > \n  >     }\n  > }\n  > ```\n  >\n  > ```java\n  > /**\n  >  * 人类，继承生物，可以没有自己的方法，全部是从抽象类继承的非抽象方法（注意：抽象类中有抽象方法子类必须实现）\n  >  */\n  > public class Person extends Biological {\n  > \n  > }\n  > ```\n  >\n  > 最重要的主程序来了，仔细看注释介绍\n  >\n  > ```java\n  > /**\n  >  * 主程序，以下只是演示，注释最重要\n  >  */\n  > public class Main {\n  >     public static void main(String[] args) {\n  >         Biological biological = new Person();//初始化时将人类的对象赋值给生物的引用时可以的\n  >         Person person = new Person();//生成一个人类的对象\n  >         biological = person;//将人类的对象复制给生物的引用也是没问题\n  >     }\n  > }\n  > ```\n\n- **抽象方法**必须**由子类来进行重写**。\n\n  > **抽象类**\n  >\n  > ```java\n  > /**\n  >  * 生物类\n  >  */\n  > public abstract class Biological {\n  > \n  >     public abstract void getEnergy();//增加了获取能量这个抽象方法\n  > \n  >     public void alive() {\n  > \n  >     }\n  > \n  >     public void death() {\n  > \n  >     }\n  > }\n  > ```\n  >\n  > 人类\n  >\n  > ```java\n  > /**\n  >  * 人类，继承生物，继承了两个非抽象方法，并实现了抽象方法\n  >  */\n  > public class Person extends Biological {\n  > \n  >     @Override\n  >     public void getEnergy() {//实现的抽象抽象方法\n  > \n  >     }\n  > }\n  > ```\n\n- 只要**包含一个抽象方法的抽象类**，该方法**必须要定义成抽象类**，不管是否还包含有其他方法。\n\n- 抽象类中**可以包含具体的方法**，当然**也可以不包含抽象方法**。\n\n  ```java\n  /**\n   * 有抽象方法的抽象类\n   */\n  public abstract class A {\n      public abstract void a();\n  }\n  ```\n\n  ```java\n  /**\n   * 没有抽象方法的抽象类\n   */\n  public abstract class B {\n      public void a() {\n  \n      }\n  }\n  ```\n\n- 子类中的抽象方法**不能**与父类的抽象方法**同名**。\n\n- `abstract`不能与`final`并列修饰同一个类。\n\n  > 这个显而易见，既然是抽象的，就必须需要时需要被子类实现的，所以不可能时final\n\n- `abstract` 不能与`private`、`static`、`final`或并列修饰同一个方法。\n\n  > `private`:抽象方法，必须是需要被继承的实现的，所以不可以用私有修饰符修饰\n  >\n  > `static`：同样，抽象方法是需要被实现的，但是静态方法是不可以被重写\n  >\n  > final：同上\n\n# 抽象类和接口的区别\n\n##  语法层面上的区别 \n\n- **抽象类**可以提供**成员方法的实现细节**，而**接口**中只能存在**public abstract 方法（在java8的之后接口）**；\n- **抽象类**中的成员变量可以是**各种类型**的，而**接口**中的成员变量只能是**public static final类型**的；\n- **接口**中**不能含有静态代码块**以及**静态方法**，而**抽象类**可以有**静态代码块**和**静态方法**；\n- 一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n## 设计层面上的区别\n\n- 抽象类是对一种**事物的抽象**，即**对类抽象**，而接口是**对行为的抽象**。\n\n- 抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n\n- 举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，**继承**是一个 \"**是不是**\"的关系，而 **接口** 实现则是 \"**有没有**\"的关系。\n\n- 如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而**接口实现则是有没有**、**具备不具备的关系**，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。\n\n- 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？ ？\n\n  >  最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。\n\n## 实际的例子\n\n下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n\n```java\n/**\n * 门的抽象类\n */\npublic abstract class DoorAbstract {\n\n    public abstract void open();\n\n    public abstract void close();\n}\n```\n\n　　或者：\n\n```java\n/**\n * 门的接口\n */\npublic interface DoorInterface {\n\n    public void open();\n\n    public void close();\n}\n```\n\n但是现在如果我们需要门具有**报警alarm( )**的功能，那么该如何实现？下面提供两种思路：\n\n- 将这三个功能都放在抽象类里面，但是这样一来**所有继承于这个抽象类的子类都具备了报警功能**，但是有的门并不一定具备报警功能；\n- 将这三个功能都放在接口里面，需要用到**报警功能的类就需要实现这个接口中的open( )和close( )**，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。\n\n很明显这个属性放到以上任何一个的当中都是不合适的，但是报警又是一个比较广泛的属性，java不支持多继承，所以最好将这个方法抽象到一个接口里面，这就是所谓的对行为抽象：\n\n```java\n/**\n * 报警的接口，所有实现了这个接口的类都是有报警这个功能\n */\npublic interface Alarm {\n    public void alarm();\n}\n```\n\n然后在对这个可以报警的门进行封装：\n\n```java\n/**\n * 可以报警的门\n */\npublic class AlarmDoor extends DoorAbstract implements Alarm {\n\n    @Override\n    public void alarm() {\n\n    }\n\n    @Override\n    public void open() {\n\n    }\n\n    @Override\n    public void close() {\n\n    }\n}\n```\n\n#### 这里其中有个注解\n\n@Override我简单说明一下（至于注解是啥，不详细的讲解了下节课会讲到）：\n\n`@Override`是伪代码,表示重写可以不写，不过写上有如下好处: \n\n- 可以当注释用,方便阅读，可以很明显的看到哪些方法是重写的方法；\n- 编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了，这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)。\n\n对于这里而言第二个作用是没有作用的，因为如果继承了抽象类，如果抽象类中含有抽象方法，必须实现这个方法不然编译器也会报错，接口也是同样的，前面说到接口中的方法默认是`public abstract`。\n\n# 内部类\n\n 顾名思义：可以将一个类的定义放在另一个类的定义内部，这就是内部类。 <img src=\"java面向对象-接口和其他的类/v2-2b4d1f67bd8f8aaecb32920c58cd687c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n## 怎么用？\n\n```java\n/**\n * 类中定义类\n */\npublic  class A {\n    \n    \n    class B {\n        \n    }\n}\n```\n\n\n\n好了，你现在已经会了内部类了，你看多简单呐     <img src=\"java面向对象-接口和其他的类/v2-8da4b48b8262d2786486cb942571be4c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n好了开玩笑的啦。<img src=\"java面向对象-接口和其他的类/v2-db4581e2b067caef5a9586f7eebdf201_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n## 内部类小飞机\n\n## 为什么要使用内部类？\n\n​\t\t在《Think in java》也就是《java编程思想》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 \n\n​\t\t在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。\n\n<img src=\"java面向对象-接口和其他的类/v2-acb2c980db4a235ed0538f34d9c2918d_hd-1571748707404.jpg\" alt=\"img\" style=\"zoom: 33%;\" />  完了上面这么简单的描述还听不懂 ，听不懂没关系，这样说我也不懂，来慢慢分析。\n\n```java\npublic interface Father {\n\n}\n```\n\n```java\npublic interface Mother {\n\n}\n```\n\n接下来骚操作来了：\n\n你可以这样子\n\n```java\npublic class Son implements Father, Mother {\n\n}\n```\n\n也可以这样子\n\n```java\npublic class Daughter implements Father{\n\n    class Mother implements Mother{\n        \n    }\n}\n```\n\n但是，不是一个类可以实现多个接口嘛，第二种实现还有什么意义呢。\n\n那么问题来了，如果爸爸妈妈他们不是接口而是一个抽象类或者类呢？现在应该理解更为深刻了。\n\n\n\n## 内部类基础\n\n`.this`和`.new`语法\n\n 当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。 \n\n**内部类如何访问外围类的东西呢？**\n\n> 当然直接用变量名就可以访问啦\n>\n> 原因？（凡事要解释得通才行嘛）\n>\n> > 其实在内部类对象中保存了一个对外部类对象的引用，当在内部类的成员方法中访问某一变量时，如果在该方法和内部类中都没有定义过这个变量，（如果有这个变量的话，或者外部类的某个成员变量与内部类的成员变量相同eg:在内部类中定义 **private String name;** 那么访问的则是内部类的这个变量）调用就会被传递给内部类中的那个对外部类对象的引用，通过这个引用去调用这个变量。在内部类调用外部类的方法也是同样的一个道理（还是这个内部类对象保存了一个对外部类的引用）。 \n\n**内部类如何获取外围类的对象呢？（.this）**\n\n> 这样子：\n>\n> ```java\n> /**\n>  * 内部类示例\n>  */\n> public  class A {\n>     String s = \"\";\n> \n>     class B {\n>         public void lala() {\n>             A a = A.this;  //关键的地方\n>         }\n>     }\n> }\n> ```\n\n**如何创建内部类的对象呢？**\n\n> **在外围类内**\n>\n> ```java\n> /**\n>  * 内部类示例\n>  */\n> public  class A {\n>     String s = \"\";\n> \n>     public void lala() {\n>         B b = new B();  //关键的地方\n>     }\n> \n>     class B {\n> \n>     }\n> }\n> ```\n>\n> **在外围类外（也就是在其他地方）：**（.new）\n>\n> ```java\n> A a = new A();\n> A.B b = a.new B();\n> ```\n\n 到这里了我们需要明确一点，**内部类是个编译时的概念**，一旦编译成功后，它就与外围类**属于两个完全不同的类**（当然他们之间还是有联系的）。对于一个名为A的外围类和一个名为B的内部类，在编译成功后，会出现这样两个class文件：**OuterClass.class和OuterClass$InnerClass.class。** \n\n关于java编译运行有兴趣了解[自己了解](http://jontree.github.io/2019/10/23/java%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3)（之前不是很多同学用命令行javac  和 java命令嘛）\n\n## 内部类的分类\n\n### 成员内部类\n\n-  成员内部类中不能存在任何static的变量和方法；\n- 成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。 \n\n例子：\n\n```java\n/**\n * 类中定义类\n */\npublic  class A {\n    \n    \n    class B {\n        \n    }\n}\n```\n\n对就是这种最简单的内部类\n\n### 局部内部类\n\n* 嵌套在方法或者作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题\n\n  >嵌套在方法中很简单，直接在方法里面写类嘛，到那时嵌套在作用域里面怎么回事，这说明直接随便在一个类中随便找个位置，写个大括号，大括号中中也是可以写局部内部类的\n  >\n  >例如：（这个简单例子可能有点绕）\n  >\n  >```java\n  >/**\n  > * 含有局部内部类的类B\n  > */\n  >class B{\n  >    \t{\t\t\t\t\t\t//这是一个静态代码块\n  >       \t\t class C{\t\t\t//这是一个局部内部类，作用域就在静态代码块中\n  >            \n  >       \t\t }\n  >    \t}\n  >}\n  >```\n  >\n  >\n\n* 通常是想创建一个类来辅助我们的解决方案，但那时又不希望这个类是公共可用的，所以就产生了局部内部类\n\n* 局部内部类和成员内部类一样被编译，只是它的作用域发生了改变\n\n* 它只能在该方法和属性中被使用，出了该方法和属性就会失效 \n\n  首先为了方便，我门先定义一个接口：\n\n  ```java\n  /**\n   * 口接口A\n   */\n  interface A{\n      \n  }\n  ```\n\n  下面开始正式的例子：\n\n  可以返回局部内部类实例化对象的函数（下面有个类B，里面有个方法返回A的引用，并且函数体里面有个实现了接口A的局部内部类C）\n\n  ```java\n  /**\n   * 含有局部内部类的类B\n   */\n  class B{\n      public A lala() {\n          class C implements A{\n  \n          }\n          return new C();\n      }\n  }\n  ```\n\n  你可以直接这样子定义然后在方法中使用（作用域在方法内）\n\n  ```java\n  /**\n   * 含有局部内部类的类B\n   */\n  class B{\n      public void lala() {\n          class C {\n              \n          }\n          C c = new C();\n          \n      }\n  }\n  ```\n\n\n### 匿名内部类\n\n#### 咋写？\n\n首先定义一个接口，一个抽象类，和一个简单的类\n\n```java\n/**\n * 我是一个冷漠无情的简单接口A\n */\npublic interface A {\n    public void a();\n}\n```\n\n```java\n/**\n * 我是一个冷漠无情的简单抽象类B\n */\npublic abstract class B {\n    public abstract void b();\n}\n```\n\n```java\n/**\n * 我是一个冷漠无情的超简单普通类\n */\npublic class C {\n    public void c() {\n\n    }\n}\n```\n\n好了，有了上面的基础，我们就来演示一下匿名内部类：\n\n```java\npublic class D {\n    public static void main(String[] args) {\n        new A() {//继承接口A的匿名内部类\n            @Override\n            public void a() {\n\n            }\n        \n        };\n\n        new B() {//继承抽象类B的内部类\n            @Override\n            public void b() {\n\n            }\n        };\n\n        new C() {//继承普通类C的匿名内部类\n\n        };\n    }\n}\n```\n\n#### 内部类的注意事项\n\n-  匿名内部类是没有访问修饰符的。\n\n- new 匿名内部类，这个类首先是要存在的。如果我们将接口注释掉，就会出现编译出错。\n\n  > 例子同上第二个，如果不用B这个现有的接口的话例如这样子写，是会报错的：\n  >\n  > ```java\n  >   new () {\n  >             @Override\n  >             public void b() {\t\t\t\t//超级错误的写法，谁这样写谁要被打手板\n  > \n  >             }\n  >         };\n  > ```\n  >\n  > \n\n- java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final\n\n  > <img src=\"java面向对象-接口和其他的类/v2-32db3eeb7c9cb282553504e2c1108130_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />你是啥意思呀，完全不懂你说的啥啊，这又是啥狗屁啊，小丁学长你在开啥飞机。\n  >\n  > emmmmmmm，好的，那我们来举例子    <img src=\"java面向对象-接口和其他的类/ceeb653ejw1faoq48816nj208z0buaan.jpg\" alt=\"举个栗子 - 后退，我要开始装逼了_表情头牌_蘑菇头_搞笑对话表情\" style=\"zoom:10%;\" />\n  >\n  > 首先我们定义一个接口，做准备。\n  >\n  > ```java\n  > /**\n  >  * 我是一个冷漠无情的简单接口A\n  > */\n  > public interface A {\n  > public void a();\n  > }\n  > ```\n  >\n  > 然后我门再写一个普通类B，后面修改B来挨个测试\n  >\n  > ```java\n  > /**\n  >  * 我是一个冷漠无情的简单类B\n  > */\n  > public  class B {\n  > int a = 0;\n  > public void b() {\n  >   int b = 0;\n  >   new A() {\n  >       @Override\n  >       public void a() {\n  > \n  >       }\n  >   };\n  >   \n  > }\n  > }\n  > ```\n  >\n  > **首先我们测试在方法里面的内部类，这个也是我们最常用的。我们在内部类实现的方法里面直接输出b看并且不把变量b设置为final**\n  >\n  > ```java\n  > /**\n  >  * 冷漠无情的简单类B我又来了\n  > */\n  > public  class B {\n  > int a = 0;\n  > public void b() {\n  >   int b = 0;\n  >   new A() {\n  >       @Override\n  >       public void a() {\n  >           System.out.println(b);//编译是能通过的，不会报错的\n  >       }\n  >   };\n  > \n  > }\n  > }\n  > ```\n  >\n  > <img src=\"java面向对象-接口和其他的类/v2-72c27a074e1feb699849c4d9d8c2614c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> 是不是讲错了，咋不需要变量b咋不需要final就能通过，翻车了。\n  >\n  > 百度谷歌一番，我找到这样一句话。\n  >\n  > ![TIM截图20191024013553](java面向对象-接口和其他的类/TIM截图20191024013553.png)\n  >\n  > emmm，那究竟是不是这样子呢？再来康康？我们这次在上面那个内部类直接修改变量b的值。看可不可以呢。\n  >\n  > ```java\n  > /**\n  >  * 我是一个冷漠无情的简单类B\n  > */\n  > public  class B {\n  > int a = 0;\n  > public void b() {\n  >   int b = 0;\n  >   new A() {\n  >       @Override\n  >       public void a() {\n  >           b = 99;\t\t\t\t\t//关键部位（也是报错部位）\n  >       }\n  >   };\n  > \n  > }\n  > }\n  > ```\n  >\n  > 编译之后，果然报错了，错误如下：\n  >\n  > ![TIM截图20191024014025](java面向对象-接口和其他的类/TIM截图20191024014025.png)\n  >\n  > 安心了，我们继续开飞机：\n  >\n  >\n  > 下面这两个用法，我估计你今后写10万行代码都遇不上一次这样写的，但是为了验证以上话是正确的，我们得试试。\n  >\n  > **第二项测试，在匿名内部类中类的静态代码块使用外部作用域里面的变量（因为是java有自动final修饰我们下面几次测试都使用直接更改外部作用域变量来测试【即：直接更改变量b的值】）**\n  >\n  > ```java\n  > /**\n  >  * 我是一个冷漠无情的简单类B,我又出现了\n  > */\n  > public  class B {\n  > int a = 0;\n  > public void b() {\n  >   int b = 0;\n  >   new A() {\n  >       {\n  >           b = 99;\t\t\t//关键部分\n  >       }\n  >       @Override\n  >       public void a() {\n  >           \n  >       }\n  >   };\n  > \n  > }\n  > }\n  > ```\n  >\n  > 好的我来编译一下\n  >\n  > ![TIM截图20191024014025](java面向对象-接口和其他的类/TIM截图20191024014025.png)\n  >\n  > 好的继续报错，而且还是这个错，nice说明，那句话更加正确了，`java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final`\n  >\n  > \n  >\n  > **那么接下来我们来测试最后一项测试，我们在匿名内部类中访问外围类中的属性，看能不能修改**\n  >\n  > ```java\n  > /**\n  >  * 我是一个冷漠无情的简单类B,我又出现了\n  > */\n  > public  class B {\n  > int a = 0;\n  > public void b() {\n  >   int b = 0;\n  >   new A() {\n  >       @Override\n  >       public void a() {\n  >           a = 99;\t\t\t\t//关键部分（没报错）\n  >       }\n  >   };\n  > \n  > }\n  > }\n  > ```\n  >\n  > 编译一下，没错？运行一下，没有报错？woc，emmmmmm，<img src=\"java面向对象-接口和其他的类/v2-72c27a074e1feb699849c4d9d8c2614c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n  >\n  > 找找原因，于是我们在再在B类中添加一个普通内部类，如下：\n  >\n  > ```java\n  > /**\n  >  * 我是一个的简单类B,这次我可不简单了\n  > */\n  > public  class B {\n  > int a = 0;\n  > public void b() {\n  >   int b = 0;\n  >   new A() {\t\t\t//匿名内部类\n  >       @Override\n  >       public void a() {\n  >           a = 99;\n  >       }\n  >   };\n  > }\n  > \n  > class C {\t\t\t\t//简单内部类C\n  >   public void c() {\n  > \n  >   }\n  > }\n  > }\n  > ```\n  >\n  > 前面我们说了，\n  > 找找原因，为啥没有报错，前面我们说内部类基础得时候，我们说是内部类是持有外围类得引用的，所以会智能的可以直接使用外围类的成员属性。\n  >\n  >\n  > 我们编译B类，然后出现了如下文件：\n  >\n  > ![TIM截图20191024021220](java面向对象-接口和其他的类/TIM截图20191024021220.png)\n  >\n  > 咦，难道匿名内部类也会储存外围类的引用🐎，是不是我们具体来康康。\n  >\n  > 我们先来看看B类编译之后反编译的代码\n  >\n  > ```java\n  > public class B {\n  > int a = 0;\n  > \n  > public B() {\n  > }\n  > \n  > public void b() {\n  >   int b = false;\n  >   A var10001 = new A() {\n  >       public void a() {\n  >           B.this.a = 99;\n  >       }\n  >   };\n  > }\n  > \n  > class C {\n  >   C() {\n  >   }\n  > \n  >   public void c() {\n  >   }\n  > }\n  > }\n  > ```\n  >\n  > 没有太大的区别，唯一的区别就是变量b，原本的0的值变成了布尔类型，这是为啥呢？\n  >\n  > \n  >\n  > 还问为啥？是要我开火箭嘛，这篇课件不是因为“为啥”会有13000+的字嘛？？你仔细想想，写个程序要那么多为什么吗？？您好要的。最简单的来说这是编译器的一个优化，你这个值没有使用，为啥要给你要存一个整形，整形相对于布尔类型还是蛮大的，自己康康，整整四倍呢。。。。。。\n  >\n  > | 类型    | 存储需求 | bit 数 | 取值范围               | 备注                                                         |\n  > | ------- | -------- | ------ | ---------------------- | ------------------------------------------------------------ |\n  > | int     | 4字节    | 4*8    | -2147483648~2147483647 | 即 (-2)的31次方 ~ (2的31次方) - 1                            |\n  > | short   | 2字节    | 2*8    | -32768~32767           | 即 (-2)的15次方 ~ (2的15次方) - 1                            |\n  > | long    | 8字节    | 8*8    |                        | 即 (-2)的63次方 ~ (2的63次方) - 1                            |\n  > | byte    | 1字节    | 1*8    | -128~127               | 即 (-2)的7次方 ~ (2的7次方) - 1                              |\n  > | float   | 4字节    | 4*8    |                        | float 类型的数值有一个后缀 F（例如：3.14F）                  |\n  > | double  | 8字节    | 8*8    |                        | 没有后缀 F 的浮点数值（例如：3.14）默认为 double             |\n  > | boolean | 1字节    | 1*8    | true、false            |                                                              |\n  > | char    | 2字节    | 2*8    |                        | Java中，只要是字符，不管是数字还是英文还是汉字，都占两个字节。 |\n  >\n  > **再来看看B$C.class，验证是否持有外围类的引用**\n  >\n  > ```java\n  > class B$C {\n  > B$C(B this$0) {\n  >   this.this$0 = this$0;\n  > }\n  > \n  > public void c() {\n  > }\n  > }\n  > ```\n  >\n  > 嗯，作为内部类，持有外围类的应用，**正解**。这里只能看到外围类的引用传进来了，那系统是怎么使用的呢？<img src=\"java面向对象-接口和其他的类/006APoFYjw1fbw78x1kr4g308c08caa2-1571887367591.gif\" alt=\"兔子摔地上 - 吐血表情包_动图_吐血表情\" style=\"zoom:15%;\" />  保存和使用是jvm级别的事，这里就详细讲了，我还没怎么看呢。\n  >\n  > \n  >\n  > **好的关键部分了，我们再来看看B$1.class反编译的结果**\n  >\n  > ```java\n  > class B$1 implements A {\n  >  B$1(B this$0) {\n  >      this.this$0 = this$0;\n  >  }\n  > \n  >  public void a() {\n  >      this.this$0.a = 99;\n  >  }\n  > }\n  > ```\n  >\n  > <img src=\"java面向对象-接口和其他的类/9150e4e5gy1g6o895cawsj20sg0sg76j.jpg\" alt=\"原来是这么回事！这下谜解开了（哆啦A梦表情包）_这么回事_这下_解开_原来表情\" style=\"zoom:18%;\" />  看到没有，匿名内部类也是会保存外围类的引用的\n  >\n  > \n  >\n  >\n  > 好了这下说明我上面那句话是对的，nice，那么问题又来了。\n  >\n  > \n  >\n  > **为什么一定要是final<img src=\"java面向对象-接口和其他的类/v2-114ee3caaad0d612d39818c9f3f81201_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />？？？**<img src=\"java面向对象-接口和其他的类/006APoFYjw1fbw78x1kr4g308c08caa2-1571887367591.gif\" alt=\"兔子摔地上 - 吐血表情包_动图_吐血表情\" style=\"zoom:15%;\" />**你们吐血没？？反正我吐了**\n  >\n  > 好的，我们来讲\n  >\n  > 那么又来了一个名词，“**闭包**”\n  >\n  > 闭包是什么呢？来听听大牛的说的他认为最通俗易懂的答案：\n  >\n  > 1. 一个依赖于外部环境自由变量的函数\n  > 2. 这个函数能够访问外部环境里的自由变量\n  >\n  > 哦豁，<img src=\"java面向对象-接口和其他的类/v2-746b68b4c2149a0faef9f4ec9a4e8e92_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" /> 还是不明白，好的，那么你继续听我慢慢分析\n  >\n  > 首先我们定义一个接口，做准备准备工作。\n  >\n  > \n  >\n  > `不准备了，不准备了，自己百度看教程吧，再准备这课件起码到20000字了。`\n  >\n  > \n  >\n  > 这里附两个[java中的final讲解](https://blog.csdn.net/jiao_zg/article/details/78911469)   [闭包讲解](https://www.zhihu.com/question/24084277/answer/110176733)其实分为java8之前之后\n  >\n\n- 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。\n\n  > 咦，上面不是反编译之后有构造方法吗？\n  >\n  > 不对不对，我这说的是使用内部类的时候，不能有构造方法，你都直接，反编译时出现的构造方法是系统在你生成匿名内部类对象时默认调用的构造方法，因为再怎么它也是个类嘛，还是有类的尊严的。\n  >\n  >\n  > 【内部类自白】：怎么人家成为你对象也是条件的嘛<img src=\"java面向对象-接口和其他的类/6af89bc8gw1f8tzg6lig0g209m073x6p.gif\" alt=\"二次元妹子害羞了（亲亲）_二次元_亲亲_害羞表情\" style=\"zoom: 25%;\" />，没有构造方法怎么行\n\n### 静态内部类\n\n*  非静态内部类在编译完成之后会隐含地保存着一个引用 \n\n*  它的创建是不需要依赖于外围类的\n*  它不能使用任何外围类的非static成员变量和方法。 \n\n\n","slug":"java面向对象-接口和其他的类","published":1,"updated":"2019-12-30T03:24:12.068Z","comments":1,"layout":"post","photos":[],"link":"2019/10/12/java面向对象-接口和其他的类","_id":"ck8jl8qiq000uw0w04u06a8ib","content":"<h1 id=\"前言：\">前言：<a href=\"#前言：\" title=\"前言：\"></a></h1><p><strong>听我讲课也就图一乐，要想真学到东西还是得自己看书。</strong></p>\n<p><strong>大学学习最重要的莫过于是自学能力，我归纳的东西也许细节上有可能和书上有差异，因为我毕竟不是专业的，要想深究还是得对照书去看，我这只是对你们的一个引导</strong>。</p>\n<p><strong>万物皆可为对象那么对象与对象之间肯定不是独立的，上节课谢磊学长讲了类的继承，那是一种最广泛的关系。今天我们了解一点更加抽象一点的东西，但是只要大家认真听我想还是会有所明白。</strong></p>\n<h1 id=\"先来吹吹概念\">先来吹吹概念<a href=\"#先来吹吹概念\" title=\"先来吹吹概念\"></a></h1><p><strong>小恐龙镇压，让学习不再困难：</strong></p>\n<p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-db4581e2b067caef5a9586f7eebdf201_hd-1571838820692.jpg\" alt=\"img\" style=\"zoom: 50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-8a2e689837fdbbbf4b1ab294f9b8dd1e_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-61c75070123da9b76126716abb4c0dc0_hd-1571843419436.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-c73dbda0a22ac613aa85548743e89311_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-52943cfec07e50eccbe2b6f6e4c7afcb_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-621e04e365e7d4a385575811df365d92_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-71abcc971fa6b70a60fed90756317c19_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-aafe63145f01d7c98b9ca567484a2dea_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-a67b056f65147bc9971073f6b23d2aa3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-d238eb952899a0a26dd5b66a36f76c56_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-fdddf30851f4370410c068f923e0c405_hd-1571843588629.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-ea2fa82794080c01e783ce025c450116_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-c4f54c756177054f05115c55be8058d7_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-cf3a3ed1086e56442c381a3ee8a1fee9_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-1a566b02828b4759584f5a5e6fee2903_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-bffbbe33c937ceb498d0882bf21a651c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-75af770ceb10d0dcfbf702142f5c625b_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-325a1104a87fafd601284c628fa6aea9_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-23b4f1f3873f02b9e9abd2d1ab30a73f_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-ec6f0e0dfb5dc6805387101614784dcf_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-99e68ddacf27251a57bfffc82a43a2a0_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-7e64adbe12f97ac1fb00fc17d7d72f28_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-7a637419db11fb84c062b0361a4045db_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-bdb493d4a6d79ffa93fe78c71a2fd1a8_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-8312b637ba6407992515ffa42b56391d_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-bc2e4a10498c1b64a01628d0df373856_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-81940f37a0165b0459cb03241922e3ee_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-639605533bdb1ecf1c6562677a430554_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-45a9abdf48e6be17cb8d9e31b53578f9_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-02ffe126c98c17d03a83adad5f65938b_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-24c27adb48dfeffc6de36260df10bad5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-e608e1d4f94a6d0c06f9e9b78d5458b5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-05aa749d19004c9fea98e84fcea3307f_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-4d0519e265a57a53b7f92599fce86a9c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">  <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-0bc6bbbfcf6d855c832b055aae892f1a_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-a959fa53966fc0b6400f88c50b8b95e3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-afd6a92d4313b460829bf99b7ef3759e_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-8d05da004dc65b91ffa63dcc213b7714_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-45b057e23dd633692fb0154f4a09ca49_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-53ac2d7b9f62a8ff17b795cc73570734_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-8c6c3bde98e8cf206839bf57085af02e_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-87072b9873cd5e8703a473b191e17042_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-f50699afeec4929bdc58d56db811bc47_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-e015f2d920aa5e00fa4b25d3b6a79bac_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-13d572e979351e77f984cd5b38a019b3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-cb5372ddead7e3c2bfcbc8e50e5e941f_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-e36c4694236b67a6e655c77d0e5336cf_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> ！</p>\n<h2 id=\"接口\">接口<a href=\"#接口\" title=\"接口\"></a></h2><blockquote>\n<p>接口最通俗的来讲就是一种统一的规范或者叫做协议，接口这个名称有点晦涩难懂，但是其实接口就是一个基于双方或者多方的协议</p>\n<p>下面举几个例子：</p>\n<ul><li>你们用的插座的插孔可以被叫做接口（协议），因为这个规范存在，在中国无论你是什么充电器，只要是这个充电口，那么我就会给你输出电流，至于你充什么，干什么我都不管。</li><li>你去面试，他说你必须有本科及以上的文凭且必须过了四级才能有面试资格，这也算事接口（协议），因为如果你没有这些东西，就不能去面试，至于你是怎么努力学习拿到本科文凭和怎么努力拿到四级证书的，一律不管。</li><li>我今天布置了作业，我要收的是我布置的这些作业，至于你们每个人怎么去做出来我是不管的，那我布置的作业就是接口（协议），你们按照题目实现相应的功能就好，最后验收我也只会根据我布置的作业的应该输出的结果来看你是不是完成作业。（当然，当然我在作业文件中指出你不能用啥，我还是会看的具体细节的）</li></ul><p>现在，接口你们应该都应该大致明白是什么了吧。</p>\n</blockquote>\n<h3 id=\"接口有什么作用？或者接口存在的必要性？\">接口有什么作用？或者接口存在的必要性？<a href=\"#接口有什么作用？或者接口存在的必要性？\" title=\"接口有什么作用？或者接口存在的必要性？\"></a></h3><blockquote>\n<p>还是上一节的例子，如果国家没有规定这个插座的标准，那每个厂家的有自己的一套，你买公牛的插座就得买支持公牛插座的电器。出去在中国其他地方旅游你就只有背着各式各样的转接头。嗯，锻炼身体也是好事嘛。</p>\n<p>所以国家就制定了标准。</p>\n<p>编程中接口也差不多，所以重要性也就凸显出来了</p>\n</blockquote>\n<h3 id=\"编程中的接口？\">编程中的接口？<a href=\"#编程中的接口？\" title=\"编程中的接口？\"></a></h3><blockquote>\n<p><strong>场景案例</strong>：</p>\n<p>现在开始你就是bat当中的员工之一，你的上级太多了，都要吩咐你做事：</p>\n<ul><li>大boss想要员工会帮他给买部手机</li><li>二boss想要员工会销售一套房子</li><li>三boss想要员工会帮忙搭讪小姐姐</li><li>四boss想要员工会跟他一起打游戏</li><li>…………..</li></ul><p>一共有不知道多少个boss，总之你是底层员工嘛。</p>\n<p>那么问题来了，这个员工类究竟得怎么设计呢，真是一个难题，而且老板们想要叫这个员工去做事的时候怎么知道这个员工会呢？</p>\n<p>答案：</p>\n<p>其实很简单，把这些行为统统抽象成接口。</p>\n<p>例如：</p>\n<p>定义下面一些接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BuyCellPhone</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buycellphone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BuyHouse</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buyHouse</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TrickGirl</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trickGirl</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PlayingGamesTogether</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">playingGameTogether</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>………………………………………………………(此处还有无数个接口)</p>\n<p>那么这些接口有什么用呢？</p>\n<p>对应的老板只需要认识熟悉的接口就好（意思是只认你是否实现了这个接口），在需要的时候调用方法就好了，而不需要去了解认识每一个人。下面以大老板为例：</p>\n<p>首先必须的有一个实现了这个</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现了买手机这个功能接口的员工</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Staff</span> <span class=\"keyword\">implements</span> <span class=\"title\">BuyCellPhone</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Staff</span><span class=\"params\">(String name, String sex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sex = sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buycellphone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"屁颠屁颠帮老板去买手机\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>此时身为老板的只需要只需要这样一个方法，就可以找个员工帮他买手机了，并且他可以完全不用了解这个员工谁，到底是干啥的，但是至少这人是实现了这个接口，就说明是有这个能力的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lookingForSomeoneToBuyAMobilePhone</span><span class=\"params\">(BuyCellPhone buyCellPhone)</span> </span>&#123;</span><br><span class=\"line\">    buyCellPhone.buycellphone();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></blockquote>\n<h2 id=\"抽象类\">抽象类<a href=\"#抽象类\" title=\"抽象类\"></a></h2><p><strong><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/164336559DA3C001F7D365CBC0A67998.jpg\" alt=\"164336559DA3C001F7D365CBC0A67998\" style=\"zoom:18%;\">我都叫抽象类了，你说我抽象不抽象，我觉得我比上面那玩意儿抽象，你说呢？</strong></p>\n<h3 id=\"黄坤坤告诉你到底有多抽象？\">黄坤坤告诉你到底有多抽象？<a href=\"#黄坤坤告诉你到底有多抽象？\" title=\"黄坤坤告诉你到底有多抽象？\"></a></h3><p><strong>抽象？我叫抽象类我就抽象啦？那hljj是jj吗？</strong></p>\n<ul><li><p><strong>听听抽象类的自白</strong></p><p><strong>（抽象类独白）</strong>：</p><p>​ 天生就是用来被别人来继承的，简而言之，只有当爸爸的命，从不当儿子。可能有些事，必须得儿子去做，别直接叫我去做事。</p></li><li><p>”<strong>只当爸爸</strong>“</p><p>说明被继承是绝对需要，大部分抽象类都是没有完整实现类功能的类，等待子类继承去实现，所以它是不可以被实例化成对像的。</p></li><li><p>“<strong>有些事必须得儿子去做</strong>”</p><p>说明它可能存在方法是抽象的，必须得子类去具体实现。</p></li><li><p>“<strong>别直接叫我做事</strong>”</p><p>说明它是不可以直接示例化的。</p></li></ul><h3 id=\"好了，说完上面牵强的解释，现在我们来看看例子：\">好了，说完上面牵强的解释，现在我们来看看例子：<a href=\"#好了，说完上面牵强的解释，现在我们来看看例子：\" title=\"好了，说完上面牵强的解释，现在我们来看看例子：\"></a></h3><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/ceeb653ejw1fai8r9ct23j205c05q3yn.jpg\" class=\"φcy\" alt=\"爸爸在呢 有事快说 - 和爸爸斗图 斗图+表情_爸爸_斗图表情\"></p>\n<h1 id=\"好了，开始开飞机了\">好了，开始开飞机了<a href=\"#好了，开始开飞机了\" title=\"好了，开始开飞机了\"></a></h1><h1 id=\"接口-1\">接口<a href=\"#接口-1\" title=\"接口\"></a></h1><h2 id=\"基本概念\">基本概念<a href=\"#基本概念\" title=\"基本概念\"></a></h2><p> 接口，英文称作<strong>interface</strong>，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对<strong>行为</strong>的抽象。在Java中，定一个接口的形式如下： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InterfaceName</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是:</p>\n<ul><li><p>接口中的变量会被隐式地指定为public static final变量</p><blockquote><p>用其他关键词修饰会报错，例如：</p><ul><li><code>public static final</code>，<code>private</code></li></ul></blockquote></li><li><p>方法会被隐式地指定为public abstract方法且只能是public abstract方法</p><blockquote><p>用其他关键词会报错，例如：</p><ul><li><code>private</code>、<code>protected</code>、<code>static</code>、 <code>final</code></li></ul></blockquote><p>接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</p><p>可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p></li></ul><h2 id=\"回调\">回调<a href=\"#回调\" title=\"回调\"></a></h2><p>可能初识这个名词觉得高大上和陌生，下面我仔细的讲解一下回调到底是什么呢？</p>\n<p><strong>我在知乎上看到一个高赞回答：</strong></p>\n<blockquote>\n<p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。</p>\n</blockquote>\n<p>这个回答在我学习接口时就看到了，但是当时还是一知半解，下面我们用代码来解释一下。</p>\n<p>首先我们定义一个接口<code>Notify</code>，通知接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Notify</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个<code>Shop</code>类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shop</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Notify notify;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registrationNoticeMethod</span><span class=\"params\">(Notify notify)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notify = notify;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">tellCustomerOutOfStock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"对不起，我们这没有货了\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">arrivalNotice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (notify != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            notify.call();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>定义一个顾客类<code>Customer</code>，并且让顾客类实现<code>Notify</code>这个接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Notify</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> phoneNum = <span class=\"number\">1234567</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"打电话给\"</span> + phoneNum + <span class=\"string\">\"通知到货了\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">goShopping</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"出门购物\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>主程序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 主函数</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//实例化对象</span></span><br><span class=\"line\">        Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">        Shop shop = <span class=\"keyword\">new</span> Shop();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//顾客出门购物</span></span><br><span class=\"line\">        customer.goShopping();</span><br><span class=\"line\">        pause();</span><br><span class=\"line\">        shop.tellCustomerOutOfStock();</span><br><span class=\"line\">        pause();</span><br><span class=\"line\">        shop.registrationNoticeMethod(customer);</span><br><span class=\"line\">        <span class=\"comment\">//第二天到货了</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"第二天\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        shop.arrivalNotice();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个函数不用在意，只是为了演示效果，增加暂停</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">pause</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Scanner(System.in).nextLine();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p>\n<p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/TIM截图20191022120614.png\" class=\"φcy\" alt=\"TIM截图20191022120614\"></p>\n<p><a href=\"#这里其中有个注解\">代码中的@Override注解说明</a>点击进入</p>\n<h2 id=\"特殊的接口\">特殊的接口<a href=\"#特殊的接口\" title=\"特殊的接口\"></a></h2><p>函数式接口</p>\n<p>简单来说，就是只有一个方法的接口。</p>\n<h2 id=\"接口继承接口以及java8之后的接口多继承问题\">接口继承接口以及java8之后的接口多继承问题<a href=\"#接口继承接口以及java8之后的接口多继承问题\" title=\"接口继承接口以及java8之后的接口多继承问题\"></a></h2><p><a href=\"https://colobu.com/2014/11/04/Java-8-default-method-and-multiple-inheritance/\" target=\"_blank\">详细解释链接</a>可能失效，我这里简述一下。</p>\n<h4 id=\"java中不是没有多继承吗？\">java中不是没有多继承吗？<a href=\"#java中不是没有多继承吗？\" title=\"java中不是没有多继承吗？\"></a></h4><p><strong>java8之前</strong></p>\n<p>是的，的确java中没有多继承，但是在java中接口是个例外，接口可以多继承，因为接口没有方法体，所以不论实现哪个父接口的中的方法都是没有关系的。</p>\n<p><strong>java8之后</strong></p>\n<p>java8之后出现了接口的默认实现，就像以下的模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">hhh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"我是B\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">hhh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"我是C\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>如果有个接口继承前两个接口，就必须把冲突的方法重写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span>, <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">hhh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>如果有个类同时实现这两个接口也需要实现冲突默认方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> <span class=\"keyword\">implements</span> <span class=\"title\">B</span>, <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hhh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h1 id=\"抽象类-1\">抽象类<a href=\"#抽象类-1\" title=\"抽象类\"></a></h1><h2 id=\"定义\">定义<a href=\"#定义\" title=\"定义\"></a></h2><ul><li>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</li><li>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</li><li>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</li><li>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</li><li>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><h2 id=\"怎么使用\">怎么使用<a href=\"#怎么使用\" title=\"怎么使用\"></a></h2><h4 id=\"抽象类声明\">抽象类声明<a href=\"#抽象类声明\" title=\"抽象类声明\"></a></h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 普通的类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 抽象类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>声明一个java抽象类只需要在正常的类的class之前加上<code>abstract</code></p>\n<h4 id=\"抽象方法声明\">抽象方法声明<a href=\"#抽象方法声明\" title=\"抽象方法声明\"></a></h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">a</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"使用时需要注意的：\">使用时需要注意的：<a href=\"#使用时需要注意的：\" title=\"使用时需要注意的：\"></a></h2><ul><li><p>抽象类<strong>不能被实例化</strong>，实例化的工作应该交<strong>由它的子类来完成</strong>，它<strong>只需要有一个引用即可</strong>。</p><blockquote><p>最重要的主程序来了，仔细看注释介绍</p></blockquote></li><li><p><strong>抽象方法</strong>必须<strong>由子类来进行重写</strong>。</p><blockquote><p><strong>抽象类</strong></p><p>人类</p></blockquote></li><li><p>只要<strong>包含一个抽象方法的抽象类</strong>，该方法<strong>必须要定义成抽象类</strong>，不管是否还包含有其他方法。</p></li><li><p>抽象类中<strong>可以包含具体的方法</strong>，当然<strong>也可以不包含抽象方法</strong>。</p></li><li><p>子类中的抽象方法<strong>不能</strong>与父类的抽象方法<strong>同名</strong>。</p></li><li><p><code>abstract</code>不能与<code>final</code>并列修饰同一个类。</p><blockquote><p>这个显而易见，既然是抽象的，就必须需要时需要被子类实现的，所以不可能时final</p></blockquote></li><li><p><code>abstract</code> 不能与<code>private</code>、<code>static</code>、<code>final</code>或并列修饰同一个方法。</p><blockquote><p><code>private</code>:抽象方法，必须是需要被继承的实现的，所以不可以用私有修饰符修饰</p><p><code>static</code>：同样，抽象方法是需要被实现的，但是静态方法是不可以被重写</p><p>final：同上</p></blockquote></li></ul><h1 id=\"抽象类和接口的区别\">抽象类和接口的区别<a href=\"#抽象类和接口的区别\" title=\"抽象类和接口的区别\"></a></h1><h2 id=\"语法层面上的区别\">语法层面上的区别<a href=\"#语法层面上的区别\" title=\"语法层面上的区别\"></a></h2><ul><li><strong>抽象类</strong>可以提供<strong>成员方法的实现细节</strong>，而<strong>接口</strong>中只能存在<strong>public abstract 方法（在java8的之后接口）</strong>；</li><li><strong>抽象类</strong>中的成员变量可以是<strong>各种类型</strong>的，而<strong>接口</strong>中的成员变量只能是<strong>public static final类型</strong>的；</li><li><strong>接口</strong>中<strong>不能含有静态代码块</strong>以及<strong>静态方法</strong>，而<strong>抽象类</strong>可以有<strong>静态代码块</strong>和<strong>静态方法</strong>；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><h2 id=\"设计层面上的区别\">设计层面上的区别<a href=\"#设计层面上的区别\" title=\"设计层面上的区别\"></a></h2><ul><li><p>抽象类是对一种<strong>事物的抽象</strong>，即<strong>对类抽象</strong>，而接口是<strong>对行为的抽象</strong>。</p></li><li><p>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</p></li><li><p>举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，<strong>继承</strong>是一个 “<strong>是不是</strong>“的关系，而 <strong>接口</strong> 实现则是 “<strong>有没有</strong>“的关系。</p></li><li><p>如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而<strong>接口实现则是有没有</strong>、<strong>具备不具备的关系</strong>，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p></li><li><p>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？ ？</p><blockquote><p>最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p></blockquote></li></ul><h2 id=\"实际的例子\">实际的例子<a href=\"#实际的例子\" title=\"实际的例子\"></a></h2><p>下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 门的抽象类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoorAbstract</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>　　或者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 门的接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DoorInterface</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>但是现在如果我们需要门具有<strong>报警alarm( )</strong>的功能，那么该如何实现？下面提供两种思路：</p>\n<ul><li>将这三个功能都放在抽象类里面，但是这样一来<strong>所有继承于这个抽象类的子类都具备了报警功能</strong>，但是有的门并不一定具备报警功能；</li><li>将这三个功能都放在接口里面，需要用到<strong>报警功能的类就需要实现这个接口中的open( )和close( )</strong>，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</li></ul><p>很明显这个属性放到以上任何一个的当中都是不合适的，但是报警又是一个比较广泛的属性，java不支持多继承，所以最好将这个方法抽象到一个接口里面，这就是所谓的对行为抽象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 报警的接口，所有实现了这个接口的类都是有报警这个功能</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alarm</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然后在对这个可以报警的门进行封装：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以报警的门</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">DoorAbstract</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"这里其中有个注解\">这里其中有个注解<a href=\"#这里其中有个注解\" title=\"这里其中有个注解\"></a></h4><p>@Override我简单说明一下（至于注解是啥，不详细的讲解了下节课会讲到）：</p>\n<p><code>@Override</code>是伪代码,表示重写可以不写，不过写上有如下好处: </p>\n<ul><li>可以当注释用,方便阅读，可以很明显的看到哪些方法是重写的方法；</li><li>编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了，这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)。</li></ul><p>对于这里而言第二个作用是没有作用的，因为如果继承了抽象类，如果抽象类中含有抽象方法，必须实现这个方法不然编译器也会报错，接口也是同样的，前面说到接口中的方法默认是<code>public abstract</code>。</p>\n<h1 id=\"内部类\">内部类<a href=\"#内部类\" title=\"内部类\"></a></h1><p> 顾名思义：可以将一个类的定义放在另一个类的定义内部，这就是内部类。 <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-2b4d1f67bd8f8aaecb32920c58cd687c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<h2 id=\"怎么用？\">怎么用？<a href=\"#怎么用？\" title=\"怎么用？\"></a></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 类中定义类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>好了，你现在已经会了内部类了，你看多简单呐     <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-8da4b48b8262d2786486cb942571be4c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<p>好了开玩笑的啦。<img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-db4581e2b067caef5a9586f7eebdf201_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<h2 id=\"内部类小飞机\">内部类小飞机<a href=\"#内部类小飞机\" title=\"内部类小飞机\"></a></h2><h2 id=\"为什么要使用内部类？\">为什么要使用内部类？<a href=\"#为什么要使用内部类？\" title=\"为什么要使用内部类？\"></a></h2><p>​        在《Think in java》也就是《java编程思想》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 </p>\n<p>​        在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>\n<p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-acb2c980db4a235ed0538f34d9c2918d_hd-1571748707404.jpg\" alt=\"img\" style=\"zoom: 33%;\">  完了上面这么简单的描述还听不懂 ，听不懂没关系，这样说我也不懂，来慢慢分析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Mother</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>接下来骚操作来了：</p>\n<p>你可以这样子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">implements</span> <span class=\"title\">Father</span>, <span class=\"title\">Mother</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>也可以这样子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Father</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother</span> <span class=\"keyword\">implements</span> <span class=\"title\">Mother</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>但是，不是一个类可以实现多个接口嘛，第二种实现还有什么意义呢。</p>\n<p>那么问题来了，如果爸爸妈妈他们不是接口而是一个抽象类或者类呢？现在应该理解更为深刻了。</p>\n<h2 id=\"内部类基础\">内部类基础<a href=\"#内部类基础\" title=\"内部类基础\"></a></h2><p><code>.this</code>和<code>.new</code>语法</p>\n<p> 当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。 </p>\n<p><strong>内部类如何访问外围类的东西呢？</strong></p>\n<blockquote>\n<p>当然直接用变量名就可以访问啦</p>\n<p>原因？（凡事要解释得通才行嘛）</p>\n<blockquote>\n<p>其实在内部类对象中保存了一个对外部类对象的引用，当在内部类的成员方法中访问某一变量时，如果在该方法和内部类中都没有定义过这个变量，（如果有这个变量的话，或者外部类的某个成员变量与内部类的成员变量相同eg:在内部类中定义 <strong>private String name;</strong> 那么访问的则是内部类的这个变量）调用就会被传递给内部类中的那个对外部类对象的引用，通过这个引用去调用这个变量。在内部类调用外部类的方法也是同样的一个道理（还是这个内部类对象保存了一个对外部类的引用）。 </p>\n</blockquote>\n</blockquote>\n<p><strong>内部类如何获取外围类的对象呢？（.this）</strong></p>\n<blockquote>\n<p>这样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 内部类示例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    String s = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lala</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            A a = A.<span class=\"keyword\">this</span>;  <span class=\"comment\">//关键的地方</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></blockquote>\n<p><strong>如何创建内部类的对象呢？</strong></p>\n<blockquote>\n<p><strong>在外围类内</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 内部类示例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    String s = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lala</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        B b = <span class=\"keyword\">new</span> B();  <span class=\"comment\">//关键的地方</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>在外围类外（也就是在其他地方）：</strong>（.new）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">A.B b = a.new B();</span><br></pre></td></tr></table></figure></blockquote>\n<p> 到这里了我们需要明确一点，<strong>内部类是个编译时的概念</strong>，一旦编译成功后，它就与外围类<strong>属于两个完全不同的类</strong>（当然他们之间还是有联系的）。对于一个名为A的外围类和一个名为B的内部类，在编译成功后，会出现这样两个class文件：<strong>OuterClass.class和OuterClass$InnerClass.class。</strong> </p>\n<p>关于java编译运行有兴趣了解<a href=\"http://jontree.github.io/2019/10/23/java%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3\" target=\"_blank\">自己了解</a>（之前不是很多同学用命令行javac  和 java命令嘛）</p>\n<h2 id=\"内部类的分类\">内部类的分类<a href=\"#内部类的分类\" title=\"内部类的分类\"></a></h2><h3 id=\"成员内部类\">成员内部类<a href=\"#成员内部类\" title=\"成员内部类\"></a></h3><ul><li>成员内部类中不能存在任何static的变量和方法；</li><li>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。</li></ul><p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 类中定义类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>对就是这种最简单的内部类</p>\n<h3 id=\"局部内部类\">局部内部类<a href=\"#局部内部类\" title=\"局部内部类\"></a></h3><ul><li><p>嵌套在方法或者作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题</p><blockquote><p>嵌套在方法中很简单，直接在方法里面写类嘛，到那时嵌套在作用域里面怎么回事，这说明直接随便在一个类中随便找个位置，写个大括号，大括号中中也是可以写局部内部类的</p><p>例如：（这个简单例子可能有点绕）</p></blockquote></li><li><p>通常是想创建一个类来辅助我们的解决方案，但那时又不希望这个类是公共可用的，所以就产生了局部内部类</p></li><li><p>局部内部类和成员内部类一样被编译，只是它的作用域发生了改变</p></li><li><p>它只能在该方法和属性中被使用，出了该方法和属性就会失效</p><p>首先为了方便，我门先定义一个接口：</p><p>下面开始正式的例子：</p><p>可以返回局部内部类实例化对象的函数（下面有个类B，里面有个方法返回A的引用，并且函数体里面有个实现了接口A的局部内部类C）</p><p>你可以直接这样子定义然后在方法中使用（作用域在方法内）</p></li></ul><h3 id=\"匿名内部类\">匿名内部类<a href=\"#匿名内部类\" title=\"匿名内部类\"></a></h3><h4 id=\"咋写？\">咋写？<a href=\"#咋写？\" title=\"咋写？\"></a></h4><p>首先定义一个接口，一个抽象类，和一个简单的类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 我是一个冷漠无情的简单接口A</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">a</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 我是一个冷漠无情的简单抽象类B</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">b</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 我是一个冷漠无情的超简单普通类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">c</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>好了，有了上面的基础，我们就来演示一下匿名内部类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> A() &#123;<span class=\"comment\">//继承接口A的匿名内部类</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">a</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> B() &#123;<span class=\"comment\">//继承抽象类B的内部类</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">b</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> C() &#123;<span class=\"comment\">//继承普通类C的匿名内部类</span></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"内部类的注意事项\">内部类的注意事项<a href=\"#内部类的注意事项\" title=\"内部类的注意事项\"></a></h4><ul><li><p>匿名内部类是没有访问修饰符的。</p></li><li><p>new 匿名内部类，这个类首先是要存在的。如果我们将接口注释掉，就会出现编译出错。</p><blockquote><p>例子同上第二个，如果不用B这个现有的接口的话例如这样子写，是会报错的：</p></blockquote></li><li><p>java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final</p><blockquote><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-32db3eeb7c9cb282553504e2c1108130_hd.jpg\" alt=\"img\" style=\"zoom:50%\">你是啥意思呀，完全不懂你说的啥啊，这又是啥狗屁啊，小丁学长你在开啥飞机。</p><p>emmmmmmm，好的，那我们来举例子 <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/ceeb653ejw1faoq48816nj208z0buaan.jpg\" alt=\"举个栗子 - 后退，我要开始装逼了_表情头牌_蘑菇头_搞笑对话表情\" style=\"zoom:10%\"></p><p>首先我们定义一个接口，做准备。</p><p>然后我门再写一个普通类B，后面修改B来挨个测试</p><p><strong>首先我们测试在方法里面的内部类，这个也是我们最常用的。我们在内部类实现的方法里面直接输出b看并且不把变量b设置为final</strong></p><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-72c27a074e1feb699849c4d9d8c2614c_hd.jpg\" alt=\"img\" style=\"zoom:50%\"> 是不是讲错了，咋不需要变量b咋不需要final就能通过，翻车了。</p><p>百度谷歌一番，我找到这样一句话。</p><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/TIM截图20191024013553.png\" alt=\"TIM截图20191024013553\"></p><p>emmm，那究竟是不是这样子呢？再来康康？我们这次在上面那个内部类直接修改变量b的值。看可不可以呢。</p><p>编译之后，果然报错了，错误如下：</p><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/TIM截图20191024014025.png\" alt=\"TIM截图20191024014025\"></p><p>安心了，我们继续开飞机：</p><p>下面这两个用法，我估计你今后写10万行代码都遇不上一次这样写的，但是为了验证以上话是正确的，我们得试试。</p><p><strong>第二项测试，在匿名内部类中类的静态代码块使用外部作用域里面的变量（因为是java有自动final修饰我们下面几次测试都使用直接更改外部作用域变量来测试【即：直接更改变量b的值】）</strong></p><p>好的我来编译一下</p><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/TIM截图20191024014025.png\" alt=\"TIM截图20191024014025\"></p><p>好的继续报错，而且还是这个错，nice说明，那句话更加正确了，<code>java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final</code></p><p><strong>那么接下来我们来测试最后一项测试，我们在匿名内部类中访问外围类中的属性，看能不能修改</strong></p><p>编译一下，没错？运行一下，没有报错？woc，emmmmmm，<img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-72c27a074e1feb699849c4d9d8c2614c_hd.jpg\" alt=\"img\" style=\"zoom:50%\"></p><p>找找原因，于是我们在再在B类中添加一个普通内部类，如下：</p><p>前面我们说了，<br>找找原因，为啥没有报错，前面我们说内部类基础得时候，我们说是内部类是持有外围类得引用的，所以会智能的可以直接使用外围类的成员属性。</p><p>我们编译B类，然后出现了如下文件：</p><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/TIM截图20191024021220.png\" alt=\"TIM截图20191024021220\"></p><p>咦，难道匿名内部类也会储存外围类的引用🐎，是不是我们具体来康康。</p><p>我们先来看看B类编译之后反编译的代码</p><p>没有太大的区别，唯一的区别就是变量b，原本的0的值变成了布尔类型，这是为啥呢？</p><p>还问为啥？是要我开火箭嘛，这篇课件不是因为“为啥”会有13000+的字嘛？？你仔细想想，写个程序要那么多为什么吗？？您好要的。最简单的来说这是编译器的一个优化，你这个值没有使用，为啥要给你要存一个整形，整形相对于布尔类型还是蛮大的，自己康康，整整四倍呢。。。。。。</p><div class=\"φcz\"><div class=\"φdb\"><table><thead><tr><th>类型</th><th>存储需求</th><th>bit 数</th><th>取值范围</th><th>备注</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td>4*8</td><td>-2147483648~2147483647</td><td>即 (-2)的31次方 ~ (2的31次方) - 1</td></tr><tr><td>short</td><td>2字节</td><td>2*8</td><td>-32768~32767</td><td>即 (-2)的15次方 ~ (2的15次方) - 1</td></tr><tr><td>long</td><td>8字节</td><td>8*8</td><td></td><td>即 (-2)的63次方 ~ (2的63次方) - 1</td></tr><tr><td>byte</td><td>1字节</td><td>1*8</td><td>-128~127</td><td>即 (-2)的7次方 ~ (2的7次方) - 1</td></tr><tr><td>float</td><td>4字节</td><td>4*8</td><td></td><td>float 类型的数值有一个后缀 F（例如：3.14F）</td></tr><tr><td>double</td><td>8字节</td><td>8*8</td><td></td><td>没有后缀 F 的浮点数值（例如：3.14）默认为 double</td></tr><tr><td>boolean</td><td>1字节</td><td>1*8</td><td>true、false</td><td></td></tr><tr><td>char</td><td>2字节</td><td>2*8</td><td></td><td>Java中，只要是字符，不管是数字还是英文还是汉字，都占两个字节。</td></tr></tbody></table></div></div><p><strong>再来看看B$C.class，验证是否持有外围类的引用</strong></p><p>嗯，作为内部类，持有外围类的应用，<strong>正解</strong>。这里只能看到外围类的引用传进来了，那系统是怎么使用的呢？<img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/006APoFYjw1fbw78x1kr4g308c08caa2-1571887367591.gif\" alt=\"兔子摔地上 - 吐血表情包_动图_吐血表情\" style=\"zoom:15%\"> 保存和使用是jvm级别的事，这里就详细讲了，我还没怎么看呢。</p><p><strong>好的关键部分了，我们再来看看B$1.class反编译的结果</strong></p><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/9150e4e5gy1g6o895cawsj20sg0sg76j.jpg\" alt=\"原来是这么回事！这下谜解开了（哆啦A梦表情包）_这么回事_这下_解开_原来表情\" style=\"zoom:18%\"> 看到没有，匿名内部类也是会保存外围类的引用的</p><p>好了这下说明我上面那句话是对的，nice，那么问题又来了。</p><p><strong>为什么一定要是final<img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-114ee3caaad0d612d39818c9f3f81201_hd.jpg\" alt=\"img\" style=\"zoom:50%\">？？？</strong><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/006APoFYjw1fbw78x1kr4g308c08caa2-1571887367591.gif\" alt=\"兔子摔地上 - 吐血表情包_动图_吐血表情\" style=\"zoom:15%\"><strong>你们吐血没？？反正我吐了</strong></p><p>好的，我们来讲</p><p>那么又来了一个名词，“<strong>闭包</strong>”</p><p>闭包是什么呢？来听听大牛的说的他认为最通俗易懂的答案：</p><ol><li>一个依赖于外部环境自由变量的函数</li><li>这个函数能够访问外部环境里的自由变量</li></ol><p>哦豁，<img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-746b68b4c2149a0faef9f4ec9a4e8e92_hd.jpg\" alt=\"img\" style=\"zoom:50%\"> 还是不明白，好的，那么你继续听我慢慢分析</p><p>首先我们定义一个接口，做准备准备工作。</p><p><code>不准备了，不准备了，自己百度看教程吧，再准备这课件起码到20000字了。</code></p><p>这里附两个<a href=\"https://blog.csdn.net/jiao_zg/article/details/78911469\" target=\"_blank\">java中的final讲解</a> <a href=\"https://www.zhihu.com/question/24084277/answer/110176733\" target=\"_blank\">闭包讲解</a>其实分为java8之前之后</p></blockquote></li><li><p>匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。</p><blockquote><p>咦，上面不是反编译之后有构造方法吗？</p><p>不对不对，我这说的是使用内部类的时候，不能有构造方法，你都直接，反编译时出现的构造方法是系统在你生成匿名内部类对象时默认调用的构造方法，因为再怎么它也是个类嘛，还是有类的尊严的。</p><p>【内部类自白】：怎么人家成为你对象也是条件的嘛<img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/6af89bc8gw1f8tzg6lig0g209m073x6p.gif\" alt=\"二次元妹子害羞了（亲亲）_二次元_亲亲_害羞表情\" style=\"zoom:25%\">，没有构造方法怎么行</p></blockquote></li></ul><h3 id=\"静态内部类\">静态内部类<a href=\"#静态内部类\" title=\"静态内部类\"></a></h3><ul><li><p>非静态内部类在编译完成之后会隐含地保存着一个引用</p></li><li><p>它的创建是不需要依赖于外围类的</p></li><li><p>它不能使用任何外围类的非static成员变量和方法。</p></li></ul>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言：\">前言：<a href=\"#前言：\" title=\"前言：\"></a></h1><p><strong>听我讲课也就图一乐，要想真学到东西还是得自己看书。</strong></p>\n<p><strong>大学学习最重要的莫过于是自学能力，我归纳的东西也许细节上有可能和书上有差异，因为我毕竟不是专业的，要想深究还是得对照书去看，我这只是对你们的一个引导</strong>。</p>\n<p><strong>万物皆可为对象那么对象与对象之间肯定不是独立的，上节课谢磊学长讲了类的继承，那是一种最广泛的关系。今天我们了解一点更加抽象一点的东西，但是只要大家认真听我想还是会有所明白。</strong></p>\n<h1 id=\"先来吹吹概念\">先来吹吹概念<a href=\"#先来吹吹概念\" title=\"先来吹吹概念\"></a></h1><p><strong>小恐龙镇压，让学习不再困难：</strong></p>\n<p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-db4581e2b067caef5a9586f7eebdf201_hd-1571838820692.jpg\" alt=\"img\" style=\"zoom: 50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-8a2e689837fdbbbf4b1ab294f9b8dd1e_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-61c75070123da9b76126716abb4c0dc0_hd-1571843419436.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-c73dbda0a22ac613aa85548743e89311_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-52943cfec07e50eccbe2b6f6e4c7afcb_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-621e04e365e7d4a385575811df365d92_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-71abcc971fa6b70a60fed90756317c19_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-aafe63145f01d7c98b9ca567484a2dea_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-a67b056f65147bc9971073f6b23d2aa3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-d238eb952899a0a26dd5b66a36f76c56_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-fdddf30851f4370410c068f923e0c405_hd-1571843588629.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-ea2fa82794080c01e783ce025c450116_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-c4f54c756177054f05115c55be8058d7_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-cf3a3ed1086e56442c381a3ee8a1fee9_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-1a566b02828b4759584f5a5e6fee2903_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-bffbbe33c937ceb498d0882bf21a651c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-75af770ceb10d0dcfbf702142f5c625b_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-325a1104a87fafd601284c628fa6aea9_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-23b4f1f3873f02b9e9abd2d1ab30a73f_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-ec6f0e0dfb5dc6805387101614784dcf_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-99e68ddacf27251a57bfffc82a43a2a0_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-7e64adbe12f97ac1fb00fc17d7d72f28_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-7a637419db11fb84c062b0361a4045db_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-bdb493d4a6d79ffa93fe78c71a2fd1a8_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-8312b637ba6407992515ffa42b56391d_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-bc2e4a10498c1b64a01628d0df373856_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-81940f37a0165b0459cb03241922e3ee_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-639605533bdb1ecf1c6562677a430554_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-45a9abdf48e6be17cb8d9e31b53578f9_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-02ffe126c98c17d03a83adad5f65938b_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-24c27adb48dfeffc6de36260df10bad5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-e608e1d4f94a6d0c06f9e9b78d5458b5_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-05aa749d19004c9fea98e84fcea3307f_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-4d0519e265a57a53b7f92599fce86a9c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg\" alt=\"img\" style=\"zoom:50%;\">  <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-0bc6bbbfcf6d855c832b055aae892f1a_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-a959fa53966fc0b6400f88c50b8b95e3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-afd6a92d4313b460829bf99b7ef3759e_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-8d05da004dc65b91ffa63dcc213b7714_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-45b057e23dd633692fb0154f4a09ca49_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-53ac2d7b9f62a8ff17b795cc73570734_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-8c6c3bde98e8cf206839bf57085af02e_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-87072b9873cd5e8703a473b191e17042_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-f50699afeec4929bdc58d56db811bc47_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-e015f2d920aa5e00fa4b25d3b6a79bac_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-13d572e979351e77f984cd5b38a019b3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-cb5372ddead7e3c2bfcbc8e50e5e941f_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-e36c4694236b67a6e655c77d0e5336cf_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"> ！</p>\n<h2 id=\"接口\">接口<a href=\"#接口\" title=\"接口\"></a></h2><blockquote>\n<p>接口最通俗的来讲就是一种统一的规范或者叫做协议，接口这个名称有点晦涩难懂，但是其实接口就是一个基于双方或者多方的协议</p>\n<p>下面举几个例子：</p>\n<ul><li>你们用的插座的插孔可以被叫做接口（协议），因为这个规范存在，在中国无论你是什么充电器，只要是这个充电口，那么我就会给你输出电流，至于你充什么，干什么我都不管。</li><li>你去面试，他说你必须有本科及以上的文凭且必须过了四级才能有面试资格，这也算事接口（协议），因为如果你没有这些东西，就不能去面试，至于你是怎么努力学习拿到本科文凭和怎么努力拿到四级证书的，一律不管。</li><li>我今天布置了作业，我要收的是我布置的这些作业，至于你们每个人怎么去做出来我是不管的，那我布置的作业就是接口（协议），你们按照题目实现相应的功能就好，最后验收我也只会根据我布置的作业的应该输出的结果来看你是不是完成作业。（当然，当然我在作业文件中指出你不能用啥，我还是会看的具体细节的）</li></ul><p>现在，接口你们应该都应该大致明白是什么了吧。</p>\n</blockquote>\n<h3 id=\"接口有什么作用？或者接口存在的必要性？\">接口有什么作用？或者接口存在的必要性？<a href=\"#接口有什么作用？或者接口存在的必要性？\" title=\"接口有什么作用？或者接口存在的必要性？\"></a></h3><blockquote>\n<p>还是上一节的例子，如果国家没有规定这个插座的标准，那每个厂家的有自己的一套，你买公牛的插座就得买支持公牛插座的电器。出去在中国其他地方旅游你就只有背着各式各样的转接头。嗯，锻炼身体也是好事嘛。</p>\n<p>所以国家就制定了标准。</p>\n<p>编程中接口也差不多，所以重要性也就凸显出来了</p>\n</blockquote>\n<h3 id=\"编程中的接口？\">编程中的接口？<a href=\"#编程中的接口？\" title=\"编程中的接口？\"></a></h3><blockquote>\n<p><strong>场景案例</strong>：</p>\n<p>现在开始你就是bat当中的员工之一，你的上级太多了，都要吩咐你做事：</p>\n<ul><li>大boss想要员工会帮他给买部手机</li><li>二boss想要员工会销售一套房子</li><li>三boss想要员工会帮忙搭讪小姐姐</li><li>四boss想要员工会跟他一起打游戏</li><li>…………..</li></ul><p>一共有不知道多少个boss，总之你是底层员工嘛。</p>\n<p>那么问题来了，这个员工类究竟得怎么设计呢，真是一个难题，而且老板们想要叫这个员工去做事的时候怎么知道这个员工会呢？</p>\n<p>答案：</p>\n<p>其实很简单，把这些行为统统抽象成接口。</p>\n<p>例如：</p>\n<p>定义下面一些接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BuyCellPhone</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buycellphone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BuyHouse</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buyHouse</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TrickGirl</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trickGirl</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PlayingGamesTogether</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">playingGameTogether</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>………………………………………………………(此处还有无数个接口)</p>\n<p>那么这些接口有什么用呢？</p>\n<p>对应的老板只需要认识熟悉的接口就好（意思是只认你是否实现了这个接口），在需要的时候调用方法就好了，而不需要去了解认识每一个人。下面以大老板为例：</p>\n<p>首先必须的有一个实现了这个</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现了买手机这个功能接口的员工</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Staff</span> <span class=\"keyword\">implements</span> <span class=\"title\">BuyCellPhone</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Staff</span><span class=\"params\">(String name, String sex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sex = sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buycellphone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"屁颠屁颠帮老板去买手机\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>此时身为老板的只需要只需要这样一个方法，就可以找个员工帮他买手机了，并且他可以完全不用了解这个员工谁，到底是干啥的，但是至少这人是实现了这个接口，就说明是有这个能力的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lookingForSomeoneToBuyAMobilePhone</span><span class=\"params\">(BuyCellPhone buyCellPhone)</span> </span>&#123;</span><br><span class=\"line\">    buyCellPhone.buycellphone();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></blockquote>\n<h2 id=\"抽象类\">抽象类<a href=\"#抽象类\" title=\"抽象类\"></a></h2><p><strong><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/164336559DA3C001F7D365CBC0A67998.jpg\" alt=\"164336559DA3C001F7D365CBC0A67998\" style=\"zoom:18%;\">我都叫抽象类了，你说我抽象不抽象，我觉得我比上面那玩意儿抽象，你说呢？</strong></p>\n<h3 id=\"黄坤坤告诉你到底有多抽象？\">黄坤坤告诉你到底有多抽象？<a href=\"#黄坤坤告诉你到底有多抽象？\" title=\"黄坤坤告诉你到底有多抽象？\"></a></h3><p><strong>抽象？我叫抽象类我就抽象啦？那hljj是jj吗？</strong></p>\n<ul><li><p><strong>听听抽象类的自白</strong></p><p><strong>（抽象类独白）</strong>：</p><p>​ 天生就是用来被别人来继承的，简而言之，只有当爸爸的命，从不当儿子。可能有些事，必须得儿子去做，别直接叫我去做事。</p></li><li><p>”<strong>只当爸爸</strong>“</p><p>说明被继承是绝对需要，大部分抽象类都是没有完整实现类功能的类，等待子类继承去实现，所以它是不可以被实例化成对像的。</p></li><li><p>“<strong>有些事必须得儿子去做</strong>”</p><p>说明它可能存在方法是抽象的，必须得子类去具体实现。</p></li><li><p>“<strong>别直接叫我做事</strong>”</p><p>说明它是不可以直接示例化的。</p></li></ul><h3 id=\"好了，说完上面牵强的解释，现在我们来看看例子：\">好了，说完上面牵强的解释，现在我们来看看例子：<a href=\"#好了，说完上面牵强的解释，现在我们来看看例子：\" title=\"好了，说完上面牵强的解释，现在我们来看看例子：\"></a></h3><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/ceeb653ejw1fai8r9ct23j205c05q3yn.jpg\" class=\"φcy\" alt=\"爸爸在呢 有事快说 - 和爸爸斗图 斗图+表情_爸爸_斗图表情\"></p>\n<h1 id=\"好了，开始开飞机了\">好了，开始开飞机了<a href=\"#好了，开始开飞机了\" title=\"好了，开始开飞机了\"></a></h1><h1 id=\"接口-1\">接口<a href=\"#接口-1\" title=\"接口\"></a></h1><h2 id=\"基本概念\">基本概念<a href=\"#基本概念\" title=\"基本概念\"></a></h2><p> 接口，英文称作<strong>interface</strong>，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对<strong>行为</strong>的抽象。在Java中，定一个接口的形式如下： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InterfaceName</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是:</p>\n<ul><li><p>接口中的变量会被隐式地指定为public static final变量</p><blockquote><p>用其他关键词修饰会报错，例如：</p><ul><li><code>public static final</code>，<code>private</code></li></ul></blockquote></li><li><p>方法会被隐式地指定为public abstract方法且只能是public abstract方法</p><blockquote><p>用其他关键词会报错，例如：</p><ul><li><code>private</code>、<code>protected</code>、<code>static</code>、 <code>final</code></li></ul></blockquote><p>接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</p><p>可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p></li></ul><h2 id=\"回调\">回调<a href=\"#回调\" title=\"回调\"></a></h2><p>可能初识这个名词觉得高大上和陌生，下面我仔细的讲解一下回调到底是什么呢？</p>\n<p><strong>我在知乎上看到一个高赞回答：</strong></p>\n<blockquote>\n<p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。</p>\n</blockquote>\n<p>这个回答在我学习接口时就看到了，但是当时还是一知半解，下面我们用代码来解释一下。</p>\n<p>首先我们定义一个接口<code>Notify</code>，通知接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Notify</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个<code>Shop</code>类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shop</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Notify notify;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registrationNoticeMethod</span><span class=\"params\">(Notify notify)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notify = notify;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">tellCustomerOutOfStock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"对不起，我们这没有货了\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">arrivalNotice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (notify != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            notify.call();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>定义一个顾客类<code>Customer</code>，并且让顾客类实现<code>Notify</code>这个接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Notify</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> phoneNum = <span class=\"number\">1234567</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"打电话给\"</span> + phoneNum + <span class=\"string\">\"通知到货了\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">goShopping</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"出门购物\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>主程序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 主函数</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//实例化对象</span></span><br><span class=\"line\">        Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">        Shop shop = <span class=\"keyword\">new</span> Shop();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//顾客出门购物</span></span><br><span class=\"line\">        customer.goShopping();</span><br><span class=\"line\">        pause();</span><br><span class=\"line\">        shop.tellCustomerOutOfStock();</span><br><span class=\"line\">        pause();</span><br><span class=\"line\">        shop.registrationNoticeMethod(customer);</span><br><span class=\"line\">        <span class=\"comment\">//第二天到货了</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"第二天\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        shop.arrivalNotice();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个函数不用在意，只是为了演示效果，增加暂停</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">pause</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Scanner(System.in).nextLine();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p>\n<p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/TIM截图20191022120614.png\" class=\"φcy\" alt=\"TIM截图20191022120614\"></p>\n<p><a href=\"#这里其中有个注解\">代码中的@Override注解说明</a>点击进入</p>\n<h2 id=\"特殊的接口\">特殊的接口<a href=\"#特殊的接口\" title=\"特殊的接口\"></a></h2><p>函数式接口</p>\n<p>简单来说，就是只有一个方法的接口。</p>\n<h2 id=\"接口继承接口以及java8之后的接口多继承问题\">接口继承接口以及java8之后的接口多继承问题<a href=\"#接口继承接口以及java8之后的接口多继承问题\" title=\"接口继承接口以及java8之后的接口多继承问题\"></a></h2><p><a href=\"https://colobu.com/2014/11/04/Java-8-default-method-and-multiple-inheritance/\" target=\"_blank\">详细解释链接</a>可能失效，我这里简述一下。</p>\n<h4 id=\"java中不是没有多继承吗？\">java中不是没有多继承吗？<a href=\"#java中不是没有多继承吗？\" title=\"java中不是没有多继承吗？\"></a></h4><p><strong>java8之前</strong></p>\n<p>是的，的确java中没有多继承，但是在java中接口是个例外，接口可以多继承，因为接口没有方法体，所以不论实现哪个父接口的中的方法都是没有关系的。</p>\n<p><strong>java8之后</strong></p>\n<p>java8之后出现了接口的默认实现，就像以下的模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">hhh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"我是B\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">hhh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"我是C\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>如果有个接口继承前两个接口，就必须把冲突的方法重写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span>, <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">hhh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>如果有个类同时实现这两个接口也需要实现冲突默认方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> <span class=\"keyword\">implements</span> <span class=\"title\">B</span>, <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hhh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h1 id=\"抽象类-1\">抽象类<a href=\"#抽象类-1\" title=\"抽象类\"></a></h1><h2 id=\"定义\">定义<a href=\"#定义\" title=\"定义\"></a></h2><ul><li>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</li><li>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</li><li>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</li><li>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</li><li>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><h2 id=\"怎么使用\">怎么使用<a href=\"#怎么使用\" title=\"怎么使用\"></a></h2><h4 id=\"抽象类声明\">抽象类声明<a href=\"#抽象类声明\" title=\"抽象类声明\"></a></h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 普通的类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 抽象类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>声明一个java抽象类只需要在正常的类的class之前加上<code>abstract</code></p>\n<h4 id=\"抽象方法声明\">抽象方法声明<a href=\"#抽象方法声明\" title=\"抽象方法声明\"></a></h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">a</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"使用时需要注意的：\">使用时需要注意的：<a href=\"#使用时需要注意的：\" title=\"使用时需要注意的：\"></a></h2><ul><li><p>抽象类<strong>不能被实例化</strong>，实例化的工作应该交<strong>由它的子类来完成</strong>，它<strong>只需要有一个引用即可</strong>。</p><blockquote><p>最重要的主程序来了，仔细看注释介绍</p></blockquote></li><li><p><strong>抽象方法</strong>必须<strong>由子类来进行重写</strong>。</p><blockquote><p><strong>抽象类</strong></p><p>人类</p></blockquote></li><li><p>只要<strong>包含一个抽象方法的抽象类</strong>，该方法<strong>必须要定义成抽象类</strong>，不管是否还包含有其他方法。</p></li><li><p>抽象类中<strong>可以包含具体的方法</strong>，当然<strong>也可以不包含抽象方法</strong>。</p></li><li><p>子类中的抽象方法<strong>不能</strong>与父类的抽象方法<strong>同名</strong>。</p></li><li><p><code>abstract</code>不能与<code>final</code>并列修饰同一个类。</p><blockquote><p>这个显而易见，既然是抽象的，就必须需要时需要被子类实现的，所以不可能时final</p></blockquote></li><li><p><code>abstract</code> 不能与<code>private</code>、<code>static</code>、<code>final</code>或并列修饰同一个方法。</p><blockquote><p><code>private</code>:抽象方法，必须是需要被继承的实现的，所以不可以用私有修饰符修饰</p><p><code>static</code>：同样，抽象方法是需要被实现的，但是静态方法是不可以被重写</p><p>final：同上</p></blockquote></li></ul><h1 id=\"抽象类和接口的区别\">抽象类和接口的区别<a href=\"#抽象类和接口的区别\" title=\"抽象类和接口的区别\"></a></h1><h2 id=\"语法层面上的区别\">语法层面上的区别<a href=\"#语法层面上的区别\" title=\"语法层面上的区别\"></a></h2><ul><li><strong>抽象类</strong>可以提供<strong>成员方法的实现细节</strong>，而<strong>接口</strong>中只能存在<strong>public abstract 方法（在java8的之后接口）</strong>；</li><li><strong>抽象类</strong>中的成员变量可以是<strong>各种类型</strong>的，而<strong>接口</strong>中的成员变量只能是<strong>public static final类型</strong>的；</li><li><strong>接口</strong>中<strong>不能含有静态代码块</strong>以及<strong>静态方法</strong>，而<strong>抽象类</strong>可以有<strong>静态代码块</strong>和<strong>静态方法</strong>；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><h2 id=\"设计层面上的区别\">设计层面上的区别<a href=\"#设计层面上的区别\" title=\"设计层面上的区别\"></a></h2><ul><li><p>抽象类是对一种<strong>事物的抽象</strong>，即<strong>对类抽象</strong>，而接口是<strong>对行为的抽象</strong>。</p></li><li><p>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</p></li><li><p>举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，<strong>继承</strong>是一个 “<strong>是不是</strong>“的关系，而 <strong>接口</strong> 实现则是 “<strong>有没有</strong>“的关系。</p></li><li><p>如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而<strong>接口实现则是有没有</strong>、<strong>具备不具备的关系</strong>，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p></li><li><p>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？ ？</p><blockquote><p>最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p></blockquote></li></ul><h2 id=\"实际的例子\">实际的例子<a href=\"#实际的例子\" title=\"实际的例子\"></a></h2><p>下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 门的抽象类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoorAbstract</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>　　或者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 门的接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DoorInterface</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>但是现在如果我们需要门具有<strong>报警alarm( )</strong>的功能，那么该如何实现？下面提供两种思路：</p>\n<ul><li>将这三个功能都放在抽象类里面，但是这样一来<strong>所有继承于这个抽象类的子类都具备了报警功能</strong>，但是有的门并不一定具备报警功能；</li><li>将这三个功能都放在接口里面，需要用到<strong>报警功能的类就需要实现这个接口中的open( )和close( )</strong>，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</li></ul><p>很明显这个属性放到以上任何一个的当中都是不合适的，但是报警又是一个比较广泛的属性，java不支持多继承，所以最好将这个方法抽象到一个接口里面，这就是所谓的对行为抽象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 报警的接口，所有实现了这个接口的类都是有报警这个功能</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alarm</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然后在对这个可以报警的门进行封装：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以报警的门</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">DoorAbstract</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"这里其中有个注解\">这里其中有个注解<a href=\"#这里其中有个注解\" title=\"这里其中有个注解\"></a></h4><p>@Override我简单说明一下（至于注解是啥，不详细的讲解了下节课会讲到）：</p>\n<p><code>@Override</code>是伪代码,表示重写可以不写，不过写上有如下好处: </p>\n<ul><li>可以当注释用,方便阅读，可以很明显的看到哪些方法是重写的方法；</li><li>编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了，这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)。</li></ul><p>对于这里而言第二个作用是没有作用的，因为如果继承了抽象类，如果抽象类中含有抽象方法，必须实现这个方法不然编译器也会报错，接口也是同样的，前面说到接口中的方法默认是<code>public abstract</code>。</p>\n<h1 id=\"内部类\">内部类<a href=\"#内部类\" title=\"内部类\"></a></h1><p> 顾名思义：可以将一个类的定义放在另一个类的定义内部，这就是内部类。 <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-2b4d1f67bd8f8aaecb32920c58cd687c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<h2 id=\"怎么用？\">怎么用？<a href=\"#怎么用？\" title=\"怎么用？\"></a></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 类中定义类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>好了，你现在已经会了内部类了，你看多简单呐     <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-8da4b48b8262d2786486cb942571be4c_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<p>好了开玩笑的啦。<img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-db4581e2b067caef5a9586f7eebdf201_hd.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n<h2 id=\"内部类小飞机\">内部类小飞机<a href=\"#内部类小飞机\" title=\"内部类小飞机\"></a></h2><h2 id=\"为什么要使用内部类？\">为什么要使用内部类？<a href=\"#为什么要使用内部类？\" title=\"为什么要使用内部类？\"></a></h2><p>​        在《Think in java》也就是《java编程思想》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 </p>\n<p>​        在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>\n<p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-acb2c980db4a235ed0538f34d9c2918d_hd-1571748707404.jpg\" alt=\"img\" style=\"zoom: 33%;\">  完了上面这么简单的描述还听不懂 ，听不懂没关系，这样说我也不懂，来慢慢分析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Mother</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>接下来骚操作来了：</p>\n<p>你可以这样子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">implements</span> <span class=\"title\">Father</span>, <span class=\"title\">Mother</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>也可以这样子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Father</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother</span> <span class=\"keyword\">implements</span> <span class=\"title\">Mother</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>但是，不是一个类可以实现多个接口嘛，第二种实现还有什么意义呢。</p>\n<p>那么问题来了，如果爸爸妈妈他们不是接口而是一个抽象类或者类呢？现在应该理解更为深刻了。</p>\n<h2 id=\"内部类基础\">内部类基础<a href=\"#内部类基础\" title=\"内部类基础\"></a></h2><p><code>.this</code>和<code>.new</code>语法</p>\n<p> 当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。 </p>\n<p><strong>内部类如何访问外围类的东西呢？</strong></p>\n<blockquote>\n<p>当然直接用变量名就可以访问啦</p>\n<p>原因？（凡事要解释得通才行嘛）</p>\n<blockquote>\n<p>其实在内部类对象中保存了一个对外部类对象的引用，当在内部类的成员方法中访问某一变量时，如果在该方法和内部类中都没有定义过这个变量，（如果有这个变量的话，或者外部类的某个成员变量与内部类的成员变量相同eg:在内部类中定义 <strong>private String name;</strong> 那么访问的则是内部类的这个变量）调用就会被传递给内部类中的那个对外部类对象的引用，通过这个引用去调用这个变量。在内部类调用外部类的方法也是同样的一个道理（还是这个内部类对象保存了一个对外部类的引用）。 </p>\n</blockquote>\n</blockquote>\n<p><strong>内部类如何获取外围类的对象呢？（.this）</strong></p>\n<blockquote>\n<p>这样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 内部类示例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    String s = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lala</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            A a = A.<span class=\"keyword\">this</span>;  <span class=\"comment\">//关键的地方</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></blockquote>\n<p><strong>如何创建内部类的对象呢？</strong></p>\n<blockquote>\n<p><strong>在外围类内</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 内部类示例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    String s = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lala</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        B b = <span class=\"keyword\">new</span> B();  <span class=\"comment\">//关键的地方</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>在外围类外（也就是在其他地方）：</strong>（.new）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">A.B b = a.new B();</span><br></pre></td></tr></table></figure></blockquote>\n<p> 到这里了我们需要明确一点，<strong>内部类是个编译时的概念</strong>，一旦编译成功后，它就与外围类<strong>属于两个完全不同的类</strong>（当然他们之间还是有联系的）。对于一个名为A的外围类和一个名为B的内部类，在编译成功后，会出现这样两个class文件：<strong>OuterClass.class和OuterClass$InnerClass.class。</strong> </p>\n<p>关于java编译运行有兴趣了解<a href=\"http://jontree.github.io/2019/10/23/java%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3\" target=\"_blank\">自己了解</a>（之前不是很多同学用命令行javac  和 java命令嘛）</p>\n<h2 id=\"内部类的分类\">内部类的分类<a href=\"#内部类的分类\" title=\"内部类的分类\"></a></h2><h3 id=\"成员内部类\">成员内部类<a href=\"#成员内部类\" title=\"成员内部类\"></a></h3><ul><li>成员内部类中不能存在任何static的变量和方法；</li><li>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。</li></ul><p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 类中定义类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>对就是这种最简单的内部类</p>\n<h3 id=\"局部内部类\">局部内部类<a href=\"#局部内部类\" title=\"局部内部类\"></a></h3><ul><li><p>嵌套在方法或者作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题</p><blockquote><p>嵌套在方法中很简单，直接在方法里面写类嘛，到那时嵌套在作用域里面怎么回事，这说明直接随便在一个类中随便找个位置，写个大括号，大括号中中也是可以写局部内部类的</p><p>例如：（这个简单例子可能有点绕）</p></blockquote></li><li><p>通常是想创建一个类来辅助我们的解决方案，但那时又不希望这个类是公共可用的，所以就产生了局部内部类</p></li><li><p>局部内部类和成员内部类一样被编译，只是它的作用域发生了改变</p></li><li><p>它只能在该方法和属性中被使用，出了该方法和属性就会失效</p><p>首先为了方便，我门先定义一个接口：</p><p>下面开始正式的例子：</p><p>可以返回局部内部类实例化对象的函数（下面有个类B，里面有个方法返回A的引用，并且函数体里面有个实现了接口A的局部内部类C）</p><p>你可以直接这样子定义然后在方法中使用（作用域在方法内）</p></li></ul><h3 id=\"匿名内部类\">匿名内部类<a href=\"#匿名内部类\" title=\"匿名内部类\"></a></h3><h4 id=\"咋写？\">咋写？<a href=\"#咋写？\" title=\"咋写？\"></a></h4><p>首先定义一个接口，一个抽象类，和一个简单的类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 我是一个冷漠无情的简单接口A</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">a</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 我是一个冷漠无情的简单抽象类B</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">b</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 我是一个冷漠无情的超简单普通类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">c</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>好了，有了上面的基础，我们就来演示一下匿名内部类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> A() &#123;<span class=\"comment\">//继承接口A的匿名内部类</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">a</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> B() &#123;<span class=\"comment\">//继承抽象类B的内部类</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">b</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> C() &#123;<span class=\"comment\">//继承普通类C的匿名内部类</span></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"内部类的注意事项\">内部类的注意事项<a href=\"#内部类的注意事项\" title=\"内部类的注意事项\"></a></h4><ul><li><p>匿名内部类是没有访问修饰符的。</p></li><li><p>new 匿名内部类，这个类首先是要存在的。如果我们将接口注释掉，就会出现编译出错。</p><blockquote><p>例子同上第二个，如果不用B这个现有的接口的话例如这样子写，是会报错的：</p></blockquote></li><li><p>java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final</p><blockquote><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-32db3eeb7c9cb282553504e2c1108130_hd.jpg\" alt=\"img\" style=\"zoom:50%\">你是啥意思呀，完全不懂你说的啥啊，这又是啥狗屁啊，小丁学长你在开啥飞机。</p><p>emmmmmmm，好的，那我们来举例子 <img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/ceeb653ejw1faoq48816nj208z0buaan.jpg\" alt=\"举个栗子 - 后退，我要开始装逼了_表情头牌_蘑菇头_搞笑对话表情\" style=\"zoom:10%\"></p><p>首先我们定义一个接口，做准备。</p><p>然后我门再写一个普通类B，后面修改B来挨个测试</p><p><strong>首先我们测试在方法里面的内部类，这个也是我们最常用的。我们在内部类实现的方法里面直接输出b看并且不把变量b设置为final</strong></p><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-72c27a074e1feb699849c4d9d8c2614c_hd.jpg\" alt=\"img\" style=\"zoom:50%\"> 是不是讲错了，咋不需要变量b咋不需要final就能通过，翻车了。</p><p>百度谷歌一番，我找到这样一句话。</p><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/TIM截图20191024013553.png\" alt=\"TIM截图20191024013553\"></p><p>emmm，那究竟是不是这样子呢？再来康康？我们这次在上面那个内部类直接修改变量b的值。看可不可以呢。</p><p>编译之后，果然报错了，错误如下：</p><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/TIM截图20191024014025.png\" alt=\"TIM截图20191024014025\"></p><p>安心了，我们继续开飞机：</p><p>下面这两个用法，我估计你今后写10万行代码都遇不上一次这样写的，但是为了验证以上话是正确的，我们得试试。</p><p><strong>第二项测试，在匿名内部类中类的静态代码块使用外部作用域里面的变量（因为是java有自动final修饰我们下面几次测试都使用直接更改外部作用域变量来测试【即：直接更改变量b的值】）</strong></p><p>好的我来编译一下</p><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/TIM截图20191024014025.png\" alt=\"TIM截图20191024014025\"></p><p>好的继续报错，而且还是这个错，nice说明，那句话更加正确了，<code>java中匿名内部类的局部作用域中要使用外部作用域里面变量的话，那个变量必须得是final</code></p><p><strong>那么接下来我们来测试最后一项测试，我们在匿名内部类中访问外围类中的属性，看能不能修改</strong></p><p>编译一下，没错？运行一下，没有报错？woc，emmmmmm，<img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-72c27a074e1feb699849c4d9d8c2614c_hd.jpg\" alt=\"img\" style=\"zoom:50%\"></p><p>找找原因，于是我们在再在B类中添加一个普通内部类，如下：</p><p>前面我们说了，<br>找找原因，为啥没有报错，前面我们说内部类基础得时候，我们说是内部类是持有外围类得引用的，所以会智能的可以直接使用外围类的成员属性。</p><p>我们编译B类，然后出现了如下文件：</p><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/TIM截图20191024021220.png\" alt=\"TIM截图20191024021220\"></p><p>咦，难道匿名内部类也会储存外围类的引用🐎，是不是我们具体来康康。</p><p>我们先来看看B类编译之后反编译的代码</p><p>没有太大的区别，唯一的区别就是变量b，原本的0的值变成了布尔类型，这是为啥呢？</p><p>还问为啥？是要我开火箭嘛，这篇课件不是因为“为啥”会有13000+的字嘛？？你仔细想想，写个程序要那么多为什么吗？？您好要的。最简单的来说这是编译器的一个优化，你这个值没有使用，为啥要给你要存一个整形，整形相对于布尔类型还是蛮大的，自己康康，整整四倍呢。。。。。。</p><div class=\"φcz\"><div class=\"φdb\"><table><thead><tr><th>类型</th><th>存储需求</th><th>bit 数</th><th>取值范围</th><th>备注</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td>4*8</td><td>-2147483648~2147483647</td><td>即 (-2)的31次方 ~ (2的31次方) - 1</td></tr><tr><td>short</td><td>2字节</td><td>2*8</td><td>-32768~32767</td><td>即 (-2)的15次方 ~ (2的15次方) - 1</td></tr><tr><td>long</td><td>8字节</td><td>8*8</td><td></td><td>即 (-2)的63次方 ~ (2的63次方) - 1</td></tr><tr><td>byte</td><td>1字节</td><td>1*8</td><td>-128~127</td><td>即 (-2)的7次方 ~ (2的7次方) - 1</td></tr><tr><td>float</td><td>4字节</td><td>4*8</td><td></td><td>float 类型的数值有一个后缀 F（例如：3.14F）</td></tr><tr><td>double</td><td>8字节</td><td>8*8</td><td></td><td>没有后缀 F 的浮点数值（例如：3.14）默认为 double</td></tr><tr><td>boolean</td><td>1字节</td><td>1*8</td><td>true、false</td><td></td></tr><tr><td>char</td><td>2字节</td><td>2*8</td><td></td><td>Java中，只要是字符，不管是数字还是英文还是汉字，都占两个字节。</td></tr></tbody></table></div></div><p><strong>再来看看B$C.class，验证是否持有外围类的引用</strong></p><p>嗯，作为内部类，持有外围类的应用，<strong>正解</strong>。这里只能看到外围类的引用传进来了，那系统是怎么使用的呢？<img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/006APoFYjw1fbw78x1kr4g308c08caa2-1571887367591.gif\" alt=\"兔子摔地上 - 吐血表情包_动图_吐血表情\" style=\"zoom:15%\"> 保存和使用是jvm级别的事，这里就详细讲了，我还没怎么看呢。</p><p><strong>好的关键部分了，我们再来看看B$1.class反编译的结果</strong></p><p><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/9150e4e5gy1g6o895cawsj20sg0sg76j.jpg\" alt=\"原来是这么回事！这下谜解开了（哆啦A梦表情包）_这么回事_这下_解开_原来表情\" style=\"zoom:18%\"> 看到没有，匿名内部类也是会保存外围类的引用的</p><p>好了这下说明我上面那句话是对的，nice，那么问题又来了。</p><p><strong>为什么一定要是final<img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-114ee3caaad0d612d39818c9f3f81201_hd.jpg\" alt=\"img\" style=\"zoom:50%\">？？？</strong><img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/006APoFYjw1fbw78x1kr4g308c08caa2-1571887367591.gif\" alt=\"兔子摔地上 - 吐血表情包_动图_吐血表情\" style=\"zoom:15%\"><strong>你们吐血没？？反正我吐了</strong></p><p>好的，我们来讲</p><p>那么又来了一个名词，“<strong>闭包</strong>”</p><p>闭包是什么呢？来听听大牛的说的他认为最通俗易懂的答案：</p><ol><li>一个依赖于外部环境自由变量的函数</li><li>这个函数能够访问外部环境里的自由变量</li></ol><p>哦豁，<img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/v2-746b68b4c2149a0faef9f4ec9a4e8e92_hd.jpg\" alt=\"img\" style=\"zoom:50%\"> 还是不明白，好的，那么你继续听我慢慢分析</p><p>首先我们定义一个接口，做准备准备工作。</p><p><code>不准备了，不准备了，自己百度看教程吧，再准备这课件起码到20000字了。</code></p><p>这里附两个<a href=\"https://blog.csdn.net/jiao_zg/article/details/78911469\" target=\"_blank\">java中的final讲解</a> <a href=\"https://www.zhihu.com/question/24084277/answer/110176733\" target=\"_blank\">闭包讲解</a>其实分为java8之前之后</p></blockquote></li><li><p>匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。</p><blockquote><p>咦，上面不是反编译之后有构造方法吗？</p><p>不对不对，我这说的是使用内部类的时候，不能有构造方法，你都直接，反编译时出现的构造方法是系统在你生成匿名内部类对象时默认调用的构造方法，因为再怎么它也是个类嘛，还是有类的尊严的。</p><p>【内部类自白】：怎么人家成为你对象也是条件的嘛<img src=\"/2019/10/12/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB/6af89bc8gw1f8tzg6lig0g209m073x6p.gif\" alt=\"二次元妹子害羞了（亲亲）_二次元_亲亲_害羞表情\" style=\"zoom:25%\">，没有构造方法怎么行</p></blockquote></li></ul><h3 id=\"静态内部类\">静态内部类<a href=\"#静态内部类\" title=\"静态内部类\"></a></h3><ul><li><p>非静态内部类在编译完成之后会隐含地保存着一个引用</p></li><li><p>它的创建是不需要依赖于外围类的</p></li><li><p>它不能使用任何外围类的非static成员变量和方法。</p></li></ul>","date_formatted":{"ll":"Oct 12, 2019","L":"10/12/2019","MM-DD":"10-12"},"plink":"https://treeeeeeee.github.io/2019/10/12/java面向对象-接口和其他的类/","type":"post","toc":[{"id":"前言：","title":"前言：","index":"1"},{"id":"先来吹吹概念","title":"先来吹吹概念","index":"2","children":[{"id":"接口","title":"接口","index":"2.1","children":[{"id":"接口有什么作用？或者接口存在的必要性？","title":"接口有什么作用？或者接口存在的必要性？","index":"2.1.1"},{"id":"编程中的接口？","title":"编程中的接口？","index":"2.1.2"}]},{"id":"抽象类","title":"抽象类","index":"2.2","children":[{"id":"黄坤坤告诉你到底有多抽象？","title":"黄坤坤告诉你到底有多抽象？","index":"2.2.1"},{"id":"好了，说完上面牵强的解释，现在我们来看看例子：","title":"好了，说完上面牵强的解释，现在我们来看看例子：","index":"2.2.2"}]}]},{"id":"好了，开始开飞机了","title":"好了，开始开飞机了","index":"3"},{"id":"接口-1","title":"接口","index":"4","children":[{"id":"基本概念","title":"基本概念","index":"4.1"},{"id":"回调","title":"回调","index":"4.2"},{"id":"特殊的接口","title":"特殊的接口","index":"4.3"},{"id":"接口继承接口以及java8之后的接口多继承问题","title":"接口继承接口以及java8之后的接口多继承问题","index":"4.4"}]},{"id":"抽象类-1","title":"抽象类","index":"5","children":[{"id":"定义","title":"定义","index":"5.1"},{"id":"怎么使用","title":"怎么使用","index":"5.2"},{"id":"使用时需要注意的：","title":"使用时需要注意的：","index":"5.3"}]},{"id":"抽象类和接口的区别","title":"抽象类和接口的区别","index":"6","children":[{"id":"语法层面上的区别","title":"语法层面上的区别","index":"6.1"},{"id":"设计层面上的区别","title":"设计层面上的区别","index":"6.2"},{"id":"实际的例子","title":"实际的例子","index":"6.3"}]},{"id":"内部类","title":"内部类","index":"7","children":[{"id":"怎么用？","title":"怎么用？","index":"7.1"},{"id":"内部类小飞机","title":"内部类小飞机","index":"7.2"},{"id":"为什么要使用内部类？","title":"为什么要使用内部类？","index":"7.3"},{"id":"内部类基础","title":"内部类基础","index":"7.4"},{"id":"内部类的分类","title":"内部类的分类","index":"7.5","children":[{"id":"成员内部类","title":"成员内部类","index":"7.5.1"},{"id":"局部内部类","title":"局部内部类","index":"7.5.2"},{"id":"匿名内部类","title":"匿名内部类","index":"7.5.3"},{"id":"静态内部类","title":"静态内部类","index":"7.5.4"}]}]}]},{"title":"ssh用法及命令","date":"2019-10-07T09:34:23.000Z","_content":"\n[原文链接](https://blog.csdn.net/pipisorry/article/details/52269785)\n\n# 什么是SSH？\n\n简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。\nSSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。这里只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。\n\n## 中间人攻击\n\nSSH之所以能够保证安全，原因在于它采用了公钥加密。\n整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。\n这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。\n可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的\"中间人攻击\"（Man-in-the-middle attack）。\n\n# ssh的安装\n\nSSH分客户端openssh-client和openssh-server\n\n如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudoapt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server。\n\nUbuntu缺省已经安装了ssh client。\n\n## #配置ssh#\n\n```shell\necho -e \"\\033[31;1m ******************************* \\033[0m\"\necho -e \"\\033[31;1m ************安装和配置ssh************ \\033[0m\"\nsudo apt-get install -y openssh-server 1> /dev/null\nsudo sed -i 's/UsePAM no/UsePAM yes/g' /etc/ssh/sshd_config\nsudo sed -i '8a /etc/init.d/ssh start' /etc/profile\nsudo /etc/init.d/ssh start\nps -e | grep ssh\n\necho -e \"\\033[31;1m ssh授权 \\033[0m\"\ncd ~/.ssh/\nssh-keygen -t rsa\ncat ./id_rsa.pub >> ./authorized_keys\n\n \n\n$ ps -e|grep ssh\n 2151 ?        00:00:00 ssh-agent\n\n 5313 ?        00:00:00 sshd\n\nssh-agent表示ssh-client启动，sshd表示ssh-server启动了。\n\n如果缺少sshd，说明ssh服务没有启动或者没有安装。\n```\n\n# SSH基本用法\n\n## SSH远程登录\n\n### 口令登录\n\n假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。\n\n```shell\n$ ssh user@host  如：ssh pika@192.168.0.111\n```\n\n如果本地用户名与远程用户名一致，登录时可以省略用户名。\n\n```shell\n$ ssh host\n```\n\nSSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。\n\n```shell\n$ ssh -p 2222 user@host\n```\n\n上面这条命令表示，ssh直接连接远程主机的2222端口。\n如果你是第一次登录对方主机，系统会出现下面的提示：\n\n```shell\n$ ssh user@host\n\nThe authenticity of host 'host (12.18.429.21)' can't be established.\nRSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.\nAre you sure you want to continue connecting (yes/no)?\n```\n\n这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？\n所谓\"公钥指纹\"，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。\n很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。\n假定经过风险衡量以后，用户决定接受这个远程主机的公钥。\n    　　`Are you sure you want to continue connecting (yes/no)? yes`\n系统会出现一句提示，表示host主机已经得到认可。\n    　　`Warning: Permanently added 'host,12.18.429.21' (RSA) to the list of known hosts.`\n然后，会要求输入密码。\n    　　`Password: (enter password)`\n如果密码正确，就可以登录了。\n当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。\n每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。\n\n如果本地用户名与远程用户名一致，登录时可以省略用户名。\n    \n\n```shell\n$ ssh host\n```\n\nSSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。\n\n```shell\n$ ssh -p 2222 user@host\n```\n\n上面这条命令表示，ssh直接连接远程主机的2222端口。\n如果你是第一次登录对方主机，系统会出现下面的提示：\n\n```shell\nThe authenticity of host 'host (12.18.429.21)' can't be established.\n    　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.\n    　　Are you sure you want to continue connecting (yes/no)?\n```\n\n这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？\n所谓\"公钥指纹\"，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。\n很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。\n假定经过风险衡量以后，用户决定接受这个远程主机的公钥。\n​    　　`Are you sure you want to continue connecting (yes/no)? yes`\n系统会出现一句提示，表示host主机已经得到认可。\n​    　　`Warning: Permanently added 'host,12.18.429.21' (RSA) to the list of known hosts.`\n然后，会要求输入密码。\n​    　　`Password: (enter password)`\n如果密码正确，就可以登录了。\n当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。\n每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。\n\n### 公钥登录\n\n使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。\n所谓\"公钥登录\"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。\n这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：\n\n```shell\n$ ssh-keygen\n```\n\n运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。\n运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。\n这时再输入下面的命令，将公钥传送到远程主机host上面：\n\n```shell\n$ ssh-copy-id user@host\n```\n\n好了，从此你再登录，就不需要输入密码了。\n如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面\"#\"注释是否取掉。\n\n```bash\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n```\n\n然后，重启远程主机的ssh服务。\n\n```bash\n# ubuntu系统\nservice ssh restart\n```\n\n```bash\n# debian系统\n/etc/init.d/ssh restart\n```\n\nauthorized_keys文件\n远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。\n这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：\n\n```shell\n$ ssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub\n```\n\n这条命令由多个语句组成，依次分解开来看：\n\n1. \"$ ssh user@host\"，表示登录远程主机；\n2. 单引号中的mkdir .ssh && cat >> .ssh/authorized_keys，表示登录后在远程shell上执行的命令：\n3. \"$ mkdir -p .ssh\"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；\n4. 'cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。\n   写入authorized_keys文件后，公钥登录的设置就完成了。\n\n然后，重启远程主机的ssh服务。\n\n```shell\n# ubuntu系统\nservice ssh restart\n# debian系统\n/etc/init.d/ssh restart\n```\n\nauthorized_keys文件\n远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。\n这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：\n\n```shell\n$ ssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub\n```\n\n这条命令由多个语句组成，依次分解开来看：（1）\"$ ssh user@host\"，表示登录远程主机；（2）单引号中的mkdir .ssh && cat >> .ssh/authorized_keys，表示登录后在远程shell上执行的命令：（3）\"$ mkdir -p .ssh\"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；（4）'cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。\n写入authorized_keys文件后，公钥登录的设置就完成了。\n\n[SSH原理与运用（一）：远程登录]\n\n使用ssh在远程后台不中断地跑程序\nLinux关闭ssh（关闭终端等）后运行的程序或者服务自动停止，如python3 a.py &。\n\n解决：使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行。\n\n```bash\nnohup python3 a.py &\n```\n\n[linux进程管理与SELinux]\n\n## ssh连接中断\n\n如果使用的是iTerm2，要让ssh不断线： profiles -> sessions -> When idel, send ASCII code\n\n其它命令行客户端，通过配置 ServerAliveInterval 来实现，在 ~/.ssh/config 中加入： ServerAliveInterval=30。表示ssh客户端每隔30秒给远程主机发送一个no-op包，no-op是无任何操作的意思，这样远程主机就不会关闭这个SSH会话。\n\nvim ~/.ssh/config，然后新增\n\nHost *\n    ServerAliveInterval 60\n60秒就好了，而且基本去连的机器都保持，所以配置了*，如果有需要针对某个机器，可以自行配置为需要的serverHostName。\n\n[ssh保持连接不断开]\n\n \n\n## SSH远程操作\n\n### SSH数据传输\n\nSSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。\n    　　$ ssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub\n单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。\n这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。\n下面看几个例子。\n【例1】\n将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。\n    　　$ cd && tar czv src | ssh user@host 'tar xz'\n【例2】\n将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。\n    　　$ ssh user@host 'tar cz src' | tar xzv\n【例3】\n查看远程主机是否运行进程httpd。\n    　　$ ssh user@host 'ps ax | grep [h]ttpd'\n\nlz建议使用scp进行远程copy：\n\nscp 跨机远程拷贝\nscp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限。\n\n### scp命令参数\n\n- -1 强制scp命令使用协议ssh1\n- -2 强制scp命令使用协议ssh2\n- -4 强制scp命令只使用IPv4寻址\n- -6 强制scp命令只使用IPv6寻址\n- -B 使用批处理模式（传输过程中不询问传输口令或短语）\n- -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）\n- -p 留原文件的修改时间，访问时间和访问权限。\n- -q 不显示传输进度条。\n- -r 递归复制整个目录。\n- -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。\n- -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。\n- -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。\n- -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。\n- -l limit 限定用户所能使用的带宽，以Kbit/s为单位。\n- -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，\n- -P port 注意是大写的P, port是指定数据传输用到的端口号\n- -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。\n- scp一般有六种使用方法\n  * 本地复制远程文件：（把远程的文件复制到本地）\n  * scp root@www.test.com:/val/test/test.tar.gz /val/test/test.tar.gz\n    远程复制本地文件：（把本地的文件复制到远程主机上）\n  * scp /val/test.tar.gz root@www.test.com:/val/test.tar.gz\n    本地复制远程目录：（把远程的目录复制到本地）\n  * scp -r root@www.test.com:/val/test/ /val/test/\n    远程复制本地目录：（把本地的目录复制到远程主机上）\n  * scp -r ./ubuntu_env/ root@192.168.0.111:/home/pipi\n  * pika:/media/pika/files/machine_learning/datasets$scp -r SocialNetworks/ \n  * piting@192.168.0.172:/media/data/pipi/datasets\n- 本地复制远程文件到指定目录：（把远程的文件复制到本地）\n- scp root@www.test.com:/val/test/test.tar.gz /val/test/\n  远程复制本地文件到指定目录：（把本地的文件复制到远程主机上）\n- scp /val/test.tar.gz root@www.test.com:/val/\n\nps: scp复制文件时只指定服务器地址不加路径默认复制到哪里???\n\n[12个scp传输文件的命令栗子]\n\n[scp 跨机远程拷贝]\n\n## SSH端口操作\n\n### 绑定本地端口\n\n既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。\n假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：\n    　　$ ssh -D 8080 user@host\nSSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。\n\n### 本地端口转发\n\n有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的\"端口转发\"。为了区别后文的\"远程端口转发\"，我们把这种情况称为\"本地端口转发\"（Local forwarding）。\n假定host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。\n我们在host1执行下面的命令：\n    　　$ ssh -L 2121:host2:21 host3\n命令中的L参数一共接受三个值，分别是\"本地端口:目标主机:目标主机端口\"，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。\n这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。\n    　　$ ftp localhost:2121\n\"本地端口转发\"使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为\"SSH隧道\"。\n下面是一个比较有趣的例子。\n\n```shell\n$ ssh -L 5900:localhost:5900 host3\n```\n\n它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。\n另一个例子是通过host3的端口转发，ssh登录host2。\n\n```shell\n$ ssh -L 9001:host2:22 host3\n```\n\n这时，只要ssh登录本机的9001端口，就相当于登录host2了。 　　\n\n```shell\n$ ssh -p 9001 localhost\n```\n\n上面的-p参数表示指定登录端口。\n\n出错处理：ssh: Could not resolve hostname 192.168.*.*:***: Name or service not known\n\n解决：指定端口不能直接使用ip:端口号，使用-p参数来解决就可以了。\n\n### 远程端口转发\n\n既然\"本地端口转发\"是指绑定本地端口的转发，那么\"远程端口转发\"（remote forwarding）当然是指绑定远程端口的转发。\n还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，\"本地端口转发\"就不能用了，怎么办？\n解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。\n我们在host3执行下面的命令：\n\n```shell\n$ ssh -R 2121:host2:21 host1\n```\n\nR参数也是接受三个值，分别是\"远程主机端口:目标主机:目标主机端口\"。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为\"远程端口绑定\"。\n绑定之后，我们在host1就可以连接host2了：\n\n```shell\n$ ftp localhost:2121\n```\n\n这里必须指出，\"远程端口转发\"的前提条件是，host1和host3两台主机都有sshD和ssh客户端。\n\n# SSH的其他参数\n\nSSH还有一些别的参数，也值得介绍。\nN参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。\n\n```shell\n$ ssh -NT -D 8080 host\n```\n\nf参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。\n\n```shell\n$ ssh -f -D 8080 host\n```\n\n要关闭这个后台连接，就只有用kill命令去杀掉进程。","source":"_posts/ssh用法及命令.md","raw":"---\ntitle: ssh用法及命令\ndate: 2019-10-07 17:34:23\ntags:\n---\n\n[原文链接](https://blog.csdn.net/pipisorry/article/details/52269785)\n\n# 什么是SSH？\n\n简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。\nSSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。这里只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。\n\n## 中间人攻击\n\nSSH之所以能够保证安全，原因在于它采用了公钥加密。\n整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。\n这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。\n可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的\"中间人攻击\"（Man-in-the-middle attack）。\n\n# ssh的安装\n\nSSH分客户端openssh-client和openssh-server\n\n如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudoapt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server。\n\nUbuntu缺省已经安装了ssh client。\n\n## #配置ssh#\n\n```shell\necho -e \"\\033[31;1m ******************************* \\033[0m\"\necho -e \"\\033[31;1m ************安装和配置ssh************ \\033[0m\"\nsudo apt-get install -y openssh-server 1> /dev/null\nsudo sed -i 's/UsePAM no/UsePAM yes/g' /etc/ssh/sshd_config\nsudo sed -i '8a /etc/init.d/ssh start' /etc/profile\nsudo /etc/init.d/ssh start\nps -e | grep ssh\n\necho -e \"\\033[31;1m ssh授权 \\033[0m\"\ncd ~/.ssh/\nssh-keygen -t rsa\ncat ./id_rsa.pub >> ./authorized_keys\n\n \n\n$ ps -e|grep ssh\n 2151 ?        00:00:00 ssh-agent\n\n 5313 ?        00:00:00 sshd\n\nssh-agent表示ssh-client启动，sshd表示ssh-server启动了。\n\n如果缺少sshd，说明ssh服务没有启动或者没有安装。\n```\n\n# SSH基本用法\n\n## SSH远程登录\n\n### 口令登录\n\n假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。\n\n```shell\n$ ssh user@host  如：ssh pika@192.168.0.111\n```\n\n如果本地用户名与远程用户名一致，登录时可以省略用户名。\n\n```shell\n$ ssh host\n```\n\nSSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。\n\n```shell\n$ ssh -p 2222 user@host\n```\n\n上面这条命令表示，ssh直接连接远程主机的2222端口。\n如果你是第一次登录对方主机，系统会出现下面的提示：\n\n```shell\n$ ssh user@host\n\nThe authenticity of host 'host (12.18.429.21)' can't be established.\nRSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.\nAre you sure you want to continue connecting (yes/no)?\n```\n\n这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？\n所谓\"公钥指纹\"，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。\n很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。\n假定经过风险衡量以后，用户决定接受这个远程主机的公钥。\n    　　`Are you sure you want to continue connecting (yes/no)? yes`\n系统会出现一句提示，表示host主机已经得到认可。\n    　　`Warning: Permanently added 'host,12.18.429.21' (RSA) to the list of known hosts.`\n然后，会要求输入密码。\n    　　`Password: (enter password)`\n如果密码正确，就可以登录了。\n当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。\n每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。\n\n如果本地用户名与远程用户名一致，登录时可以省略用户名。\n    \n\n```shell\n$ ssh host\n```\n\nSSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。\n\n```shell\n$ ssh -p 2222 user@host\n```\n\n上面这条命令表示，ssh直接连接远程主机的2222端口。\n如果你是第一次登录对方主机，系统会出现下面的提示：\n\n```shell\nThe authenticity of host 'host (12.18.429.21)' can't be established.\n    　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.\n    　　Are you sure you want to continue connecting (yes/no)?\n```\n\n这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？\n所谓\"公钥指纹\"，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。\n很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。\n假定经过风险衡量以后，用户决定接受这个远程主机的公钥。\n​    　　`Are you sure you want to continue connecting (yes/no)? yes`\n系统会出现一句提示，表示host主机已经得到认可。\n​    　　`Warning: Permanently added 'host,12.18.429.21' (RSA) to the list of known hosts.`\n然后，会要求输入密码。\n​    　　`Password: (enter password)`\n如果密码正确，就可以登录了。\n当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。\n每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。\n\n### 公钥登录\n\n使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。\n所谓\"公钥登录\"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。\n这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：\n\n```shell\n$ ssh-keygen\n```\n\n运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。\n运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。\n这时再输入下面的命令，将公钥传送到远程主机host上面：\n\n```shell\n$ ssh-copy-id user@host\n```\n\n好了，从此你再登录，就不需要输入密码了。\n如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面\"#\"注释是否取掉。\n\n```bash\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n```\n\n然后，重启远程主机的ssh服务。\n\n```bash\n# ubuntu系统\nservice ssh restart\n```\n\n```bash\n# debian系统\n/etc/init.d/ssh restart\n```\n\nauthorized_keys文件\n远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。\n这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：\n\n```shell\n$ ssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub\n```\n\n这条命令由多个语句组成，依次分解开来看：\n\n1. \"$ ssh user@host\"，表示登录远程主机；\n2. 单引号中的mkdir .ssh && cat >> .ssh/authorized_keys，表示登录后在远程shell上执行的命令：\n3. \"$ mkdir -p .ssh\"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；\n4. 'cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。\n   写入authorized_keys文件后，公钥登录的设置就完成了。\n\n然后，重启远程主机的ssh服务。\n\n```shell\n# ubuntu系统\nservice ssh restart\n# debian系统\n/etc/init.d/ssh restart\n```\n\nauthorized_keys文件\n远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。\n这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：\n\n```shell\n$ ssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub\n```\n\n这条命令由多个语句组成，依次分解开来看：（1）\"$ ssh user@host\"，表示登录远程主机；（2）单引号中的mkdir .ssh && cat >> .ssh/authorized_keys，表示登录后在远程shell上执行的命令：（3）\"$ mkdir -p .ssh\"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；（4）'cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。\n写入authorized_keys文件后，公钥登录的设置就完成了。\n\n[SSH原理与运用（一）：远程登录]\n\n使用ssh在远程后台不中断地跑程序\nLinux关闭ssh（关闭终端等）后运行的程序或者服务自动停止，如python3 a.py &。\n\n解决：使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行。\n\n```bash\nnohup python3 a.py &\n```\n\n[linux进程管理与SELinux]\n\n## ssh连接中断\n\n如果使用的是iTerm2，要让ssh不断线： profiles -> sessions -> When idel, send ASCII code\n\n其它命令行客户端，通过配置 ServerAliveInterval 来实现，在 ~/.ssh/config 中加入： ServerAliveInterval=30。表示ssh客户端每隔30秒给远程主机发送一个no-op包，no-op是无任何操作的意思，这样远程主机就不会关闭这个SSH会话。\n\nvim ~/.ssh/config，然后新增\n\nHost *\n    ServerAliveInterval 60\n60秒就好了，而且基本去连的机器都保持，所以配置了*，如果有需要针对某个机器，可以自行配置为需要的serverHostName。\n\n[ssh保持连接不断开]\n\n \n\n## SSH远程操作\n\n### SSH数据传输\n\nSSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。\n    　　$ ssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub\n单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。\n这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。\n下面看几个例子。\n【例1】\n将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。\n    　　$ cd && tar czv src | ssh user@host 'tar xz'\n【例2】\n将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。\n    　　$ ssh user@host 'tar cz src' | tar xzv\n【例3】\n查看远程主机是否运行进程httpd。\n    　　$ ssh user@host 'ps ax | grep [h]ttpd'\n\nlz建议使用scp进行远程copy：\n\nscp 跨机远程拷贝\nscp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限。\n\n### scp命令参数\n\n- -1 强制scp命令使用协议ssh1\n- -2 强制scp命令使用协议ssh2\n- -4 强制scp命令只使用IPv4寻址\n- -6 强制scp命令只使用IPv6寻址\n- -B 使用批处理模式（传输过程中不询问传输口令或短语）\n- -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）\n- -p 留原文件的修改时间，访问时间和访问权限。\n- -q 不显示传输进度条。\n- -r 递归复制整个目录。\n- -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。\n- -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。\n- -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。\n- -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。\n- -l limit 限定用户所能使用的带宽，以Kbit/s为单位。\n- -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，\n- -P port 注意是大写的P, port是指定数据传输用到的端口号\n- -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。\n- scp一般有六种使用方法\n  * 本地复制远程文件：（把远程的文件复制到本地）\n  * scp root@www.test.com:/val/test/test.tar.gz /val/test/test.tar.gz\n    远程复制本地文件：（把本地的文件复制到远程主机上）\n  * scp /val/test.tar.gz root@www.test.com:/val/test.tar.gz\n    本地复制远程目录：（把远程的目录复制到本地）\n  * scp -r root@www.test.com:/val/test/ /val/test/\n    远程复制本地目录：（把本地的目录复制到远程主机上）\n  * scp -r ./ubuntu_env/ root@192.168.0.111:/home/pipi\n  * pika:/media/pika/files/machine_learning/datasets$scp -r SocialNetworks/ \n  * piting@192.168.0.172:/media/data/pipi/datasets\n- 本地复制远程文件到指定目录：（把远程的文件复制到本地）\n- scp root@www.test.com:/val/test/test.tar.gz /val/test/\n  远程复制本地文件到指定目录：（把本地的文件复制到远程主机上）\n- scp /val/test.tar.gz root@www.test.com:/val/\n\nps: scp复制文件时只指定服务器地址不加路径默认复制到哪里???\n\n[12个scp传输文件的命令栗子]\n\n[scp 跨机远程拷贝]\n\n## SSH端口操作\n\n### 绑定本地端口\n\n既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。\n假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：\n    　　$ ssh -D 8080 user@host\nSSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。\n\n### 本地端口转发\n\n有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的\"端口转发\"。为了区别后文的\"远程端口转发\"，我们把这种情况称为\"本地端口转发\"（Local forwarding）。\n假定host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。\n我们在host1执行下面的命令：\n    　　$ ssh -L 2121:host2:21 host3\n命令中的L参数一共接受三个值，分别是\"本地端口:目标主机:目标主机端口\"，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。\n这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。\n    　　$ ftp localhost:2121\n\"本地端口转发\"使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为\"SSH隧道\"。\n下面是一个比较有趣的例子。\n\n```shell\n$ ssh -L 5900:localhost:5900 host3\n```\n\n它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。\n另一个例子是通过host3的端口转发，ssh登录host2。\n\n```shell\n$ ssh -L 9001:host2:22 host3\n```\n\n这时，只要ssh登录本机的9001端口，就相当于登录host2了。 　　\n\n```shell\n$ ssh -p 9001 localhost\n```\n\n上面的-p参数表示指定登录端口。\n\n出错处理：ssh: Could not resolve hostname 192.168.*.*:***: Name or service not known\n\n解决：指定端口不能直接使用ip:端口号，使用-p参数来解决就可以了。\n\n### 远程端口转发\n\n既然\"本地端口转发\"是指绑定本地端口的转发，那么\"远程端口转发\"（remote forwarding）当然是指绑定远程端口的转发。\n还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，\"本地端口转发\"就不能用了，怎么办？\n解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。\n我们在host3执行下面的命令：\n\n```shell\n$ ssh -R 2121:host2:21 host1\n```\n\nR参数也是接受三个值，分别是\"远程主机端口:目标主机:目标主机端口\"。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为\"远程端口绑定\"。\n绑定之后，我们在host1就可以连接host2了：\n\n```shell\n$ ftp localhost:2121\n```\n\n这里必须指出，\"远程端口转发\"的前提条件是，host1和host3两台主机都有sshD和ssh客户端。\n\n# SSH的其他参数\n\nSSH还有一些别的参数，也值得介绍。\nN参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。\n\n```shell\n$ ssh -NT -D 8080 host\n```\n\nf参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。\n\n```shell\n$ ssh -f -D 8080 host\n```\n\n要关闭这个后台连接，就只有用kill命令去杀掉进程。","slug":"ssh用法及命令","published":1,"updated":"2019-12-30T02:50:50.957Z","comments":1,"layout":"post","photos":[],"link":"2019/10/07/ssh用法及命令","_id":"ck8jl8qis000yw0w0e0u41c3l","content":"<p><a href=\"https://blog.csdn.net/pipisorry/article/details/52269785\" target=\"_blank\">原文链接</a></p>\n<h1 id=\"什么是ssh？\">什么是SSH？<a href=\"#什么是ssh？\" title=\"什么是SSH？\"></a></h1><p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。<br>SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。这里只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。</p>\n<h2 id=\"中间人攻击\">中间人攻击<a href=\"#中间人攻击\" title=\"中间人攻击\"></a></h2><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。<br>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。<br>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。<br>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。</p>\n<h1 id=\"ssh的安装\">ssh的安装<a href=\"#ssh的安装\" title=\"ssh的安装\"></a></h1><p>SSH分客户端openssh-client和openssh-server</p>\n<p>如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudoapt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server。</p>\n<p>Ubuntu缺省已经安装了ssh client。</p>\n<h2 id=\"配置ssh\">#配置ssh#<a href=\"#配置ssh\" title=\"#配置ssh#\"></a></h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo -e \"\\033[31;1m ******************************* \\033[0m\"</span><br><span class=\"line\">echo -e \"\\033[31;1m ************安装和配置ssh************ \\033[0m\"</span><br><span class=\"line\">sudo apt-get install -y openssh-server 1&gt; /dev/null</span><br><span class=\"line\">sudo sed -i 's/UsePAM no/UsePAM yes/g' /etc/ssh/sshd_config</span><br><span class=\"line\">sudo sed -i '8a /etc/init.d/ssh start' /etc/profile</span><br><span class=\"line\">sudo /etc/init.d/ssh start</span><br><span class=\"line\">ps -e | grep ssh</span><br><span class=\"line\"></span><br><span class=\"line\">echo -e \"\\033[31;1m ssh授权 \\033[0m\"</span><br><span class=\"line\">cd ~/.ssh/</span><br><span class=\"line\">ssh-keygen -t rsa</span><br><span class=\"line\">cat ./id_rsa.pub &gt;&gt; ./authorized_keys</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ps -e|grep ssh</span></span><br><span class=\"line\"> 2151 ?        00:00:00 ssh-agent</span><br><span class=\"line\"></span><br><span class=\"line\"> 5313 ?        00:00:00 sshd</span><br><span class=\"line\"></span><br><span class=\"line\">ssh-agent表示ssh-client启动，sshd表示ssh-server启动了。</span><br><span class=\"line\"></span><br><span class=\"line\">如果缺少sshd，说明ssh服务没有启动或者没有安装。</span><br></pre></td></tr></table></figure><h1 id=\"ssh基本用法\">SSH基本用法<a href=\"#ssh基本用法\" title=\"SSH基本用法\"></a></h1><h2 id=\"ssh远程登录\">SSH远程登录<a href=\"#ssh远程登录\" title=\"SSH远程登录\"></a></h2><h3 id=\"口令登录\">口令登录<a href=\"#口令登录\" title=\"口令登录\"></a></h3><p>假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh user@host  如：ssh pika@192.168.0.111</span></span><br></pre></td></tr></table></figure><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh host</span></span><br></pre></td></tr></table></figure><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -p 2222 user@host</span></span><br></pre></td></tr></table></figure><p>上面这条命令表示，ssh直接连接远程主机的2222端口。<br>如果你是第一次登录对方主机，系统会出现下面的提示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh user@host</span></span><br><span class=\"line\"></span><br><span class=\"line\">The authenticity of host 'host (12.18.429.21)' can't be established.</span><br><span class=\"line\">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？<br>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。<br>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。<br>    　　<code>Are you sure you want to continue connecting (yes/no)? yes</code><br>系统会出现一句提示，表示host主机已经得到认可。<br>    　　<code>Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.</code><br>然后，会要求输入密码。<br>    　　<code>Password: (enter password)</code><br>如果密码正确，就可以登录了。<br>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>\n<p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh host</span></span><br></pre></td></tr></table></figure><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -p 2222 user@host</span></span><br></pre></td></tr></table></figure><p>上面这条命令表示，ssh直接连接远程主机的2222端口。<br>如果你是第一次登录对方主机，系统会出现下面的提示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The authenticity of host 'host (12.18.429.21)' can't be established.</span><br><span class=\"line\">    　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class=\"line\">    　　Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？<br>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。<br>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。<br>​    　　<code>Are you sure you want to continue connecting (yes/no)? yes</code><br>系统会出现一句提示，表示host主机已经得到认可。<br>​    　　<code>Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.</code><br>然后，会要求输入密码。<br>​    　　<code>Password: (enter password)</code><br>如果密码正确，就可以登录了。<br>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>\n<h3 id=\"公钥登录\">公钥登录<a href=\"#公钥登录\" title=\"公钥登录\"></a></h3><p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。<br>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh-keygen</span></span><br></pre></td></tr></table></figure><p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。<br>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。<br>这时再输入下面的命令，将公钥传送到远程主机host上面：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh-copy-id user@host</span></span><br></pre></td></tr></table></figure><p>好了，从此你再登录，就不需要输入密码了。<br>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RSAAuthentication yes</span><br><span class=\"line\">PubkeyAuthentication yes</span><br><span class=\"line\">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后，重启远程主机的ssh服务。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ubuntu系统</span></span><br><span class=\"line\">service ssh restart</span><br></pre></td></tr></table></figure><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># debian系统</span></span><br><span class=\"line\">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><p>authorized_keys文件<br>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。<br>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh user@host <span class=\"string\">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure><p>这条命令由多个语句组成，依次分解开来看：</p>\n<ol><li>“$ ssh user@host”，表示登录远程主机；</li><li>单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：</li><li>“$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；</li><li>‘cat &gt;&gt; .ssh/authorized_keys’ &lt; <del>/.ssh/id_rsa.pub的作用是，将本地的公钥文件</del>/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。</li></ol><p>然后，重启远程主机的ssh服务。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ubuntu系统</span></span><br><span class=\"line\">service ssh restart</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> debian系统</span></span><br><span class=\"line\">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><p>authorized_keys文件<br>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。<br>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh user@host <span class=\"string\">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure><p>这条命令由多个语句组成，依次分解开来看：（1）”$ ssh user@host”，表示登录远程主机；（2）单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：（3）”$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；（4）’cat &gt;&gt; .ssh/authorized_keys’ &lt; <del>/.ssh/id_rsa.pub的作用是，将本地的公钥文件</del>/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。</p>\n<p>[SSH原理与运用（一）：远程登录]</p>\n<p>使用ssh在远程后台不中断地跑程序<br>Linux关闭ssh（关闭终端等）后运行的程序或者服务自动停止，如python3 a.py &amp;。</p>\n<p>解决：使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup python3 a.py &amp;</span><br></pre></td></tr></table></figure><p>[linux进程管理与SELinux]</p>\n<h2 id=\"ssh连接中断\">ssh连接中断<a href=\"#ssh连接中断\" title=\"ssh连接中断\"></a></h2><p>如果使用的是iTerm2，要让ssh不断线： profiles -&gt; sessions -&gt; When idel, send ASCII code</p>\n<p>其它命令行客户端，通过配置 ServerAliveInterval 来实现，在 ~/.ssh/config 中加入： ServerAliveInterval=30。表示ssh客户端每隔30秒给远程主机发送一个no-op包，no-op是无任何操作的意思，这样远程主机就不会关闭这个SSH会话。</p>\n<p>vim ~/.ssh/config，然后新增</p>\n<p>Host *<br>    ServerAliveInterval 60<br>60秒就好了，而且基本去连的机器都保持，所以配置了*，如果有需要针对某个机器，可以自行配置为需要的serverHostName。</p>\n<p>[ssh保持连接不断开]</p>\n<h2 id=\"ssh远程操作\">SSH远程操作<a href=\"#ssh远程操作\" title=\"SSH远程操作\"></a></h2><h3 id=\"ssh数据传输\">SSH数据传输<a href=\"#ssh数据传输\" title=\"SSH数据传输\"></a></h3><p>SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。<br>    　　$ ssh user@host ‘mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub<br>单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。<br>这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。<br>下面看几个例子。<br>【例1】<br>将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。<br>    　　$ cd &amp;&amp; tar czv src | ssh user@host ‘tar xz’<br>【例2】<br>将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。<br>    　　$ ssh user@host ‘tar cz src’ | tar xzv<br>【例3】<br>查看远程主机是否运行进程httpd。<br>    　　$ ssh user@host ‘ps ax | grep [h]ttpd’</p>\n<p>lz建议使用scp进行远程copy：</p>\n<p>scp 跨机远程拷贝<br>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限。</p>\n<h3 id=\"scp命令参数\">scp命令参数<a href=\"#scp命令参数\" title=\"scp命令参数\"></a></h3><ul><li>-1 强制scp命令使用协议ssh1</li><li>-2 强制scp命令使用协议ssh2</li><li>-4 强制scp命令只使用IPv4寻址</li><li>-6 强制scp命令只使用IPv6寻址</li><li>-B 使用批处理模式（传输过程中不询问传输口令或短语）</li><li>-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li><li>-p 留原文件的修改时间，访问时间和访问权限。</li><li>-q 不显示传输进度条。</li><li>-r 递归复制整个目录。</li><li>-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li><li>-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li><li>-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li><li>-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li><li>-l limit 限定用户所能使用的带宽，以Kbit/s为单位。</li><li>-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，</li><li>-P port 注意是大写的P, port是指定数据传输用到的端口号</li><li>-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li><li>scp一般有六种使用方法<ul><li>本地复制远程文件：（把远程的文件复制到本地）</li><li>scp <a href=\"mailto:root@www.test.com\">root@www.test.com</a>:/val/test/test.tar.gz /val/test/test.tar.gz<br>远程复制本地文件：（把本地的文件复制到远程主机上）</li><li>scp /val/test.tar.gz <a href=\"mailto:root@www.test.com\">root@www.test.com</a>:/val/test.tar.gz<br>本地复制远程目录：（把远程的目录复制到本地）</li><li>scp -r <a href=\"mailto:root@www.test.com\">root@www.test.com</a>:/val/test/ /val/test/<br>远程复制本地目录：（把本地的目录复制到远程主机上）</li><li>scp -r ./ubuntu_env/ <a href=\"mailto:root@192.168.0.111\">root@192.168.0.111</a>:/home/pipi</li><li>pika:/media/pika/files/machine_learning/datasets$scp -r SocialNetworks/</li><li><a href=\"mailto:piting@192.168.0.172\">piting@192.168.0.172</a>:/media/data/pipi/datasets</li></ul></li><li>本地复制远程文件到指定目录：（把远程的文件复制到本地）</li><li>scp <a href=\"mailto:root@www.test.com\">root@www.test.com</a>:/val/test/test.tar.gz /val/test/<br>远程复制本地文件到指定目录：（把本地的文件复制到远程主机上）</li><li>scp /val/test.tar.gz <a href=\"mailto:root@www.test.com\">root@www.test.com</a>:/val/</li></ul><p>ps: scp复制文件时只指定服务器地址不加路径默认复制到哪里???</p>\n<p>[12个scp传输文件的命令栗子]</p>\n<p>[scp 跨机远程拷贝]</p>\n<h2 id=\"ssh端口操作\">SSH端口操作<a href=\"#ssh端口操作\" title=\"SSH端口操作\"></a></h2><h3 id=\"绑定本地端口\">绑定本地端口<a href=\"#绑定本地端口\" title=\"绑定本地端口\"></a></h3><p>既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。<br>假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：<br>    　　$ ssh -D 8080 user@host<br>SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。</p>\n<h3 id=\"本地端口转发\">本地端口转发<a href=\"#本地端口转发\" title=\"本地端口转发\"></a></h3><p>有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）。<br>假定host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。<br>我们在host1执行下面的命令：<br>    　　$ ssh -L 2121:host2:21 host3<br>命令中的L参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。<br>这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。<br>    　　$ ftp localhost:2121<br>“本地端口转发”使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH隧道”。<br>下面是一个比较有趣的例子。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -L 5900:localhost:5900 host3</span></span><br></pre></td></tr></table></figure><p>它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。<br>另一个例子是通过host3的端口转发，ssh登录host2。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -L 9001:host2:22 host3</span></span><br></pre></td></tr></table></figure><p>这时，只要ssh登录本机的9001端口，就相当于登录host2了。 　　</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -p 9001 localhost</span></span><br></pre></td></tr></table></figure><p>上面的-p参数表示指定登录端口。</p>\n<p>出错处理：ssh: Could not resolve hostname 192.168.<em>.</em>:***: Name or service not known</p>\n<p>解决：指定端口不能直接使用ip:端口号，使用-p参数来解决就可以了。</p>\n<h3 id=\"远程端口转发\">远程端口转发<a href=\"#远程端口转发\" title=\"远程端口转发\"></a></h3><p>既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。<br>还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，”本地端口转发”就不能用了，怎么办？<br>解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。<br>我们在host3执行下面的命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -R 2121:host2:21 host1</span></span><br></pre></td></tr></table></figure><p>R参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。<br>绑定之后，我们在host1就可以连接host2了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ftp localhost:2121</span></span><br></pre></td></tr></table></figure><p>这里必须指出，”远程端口转发”的前提条件是，host1和host3两台主机都有sshD和ssh客户端。</p>\n<h1 id=\"ssh的其他参数\">SSH的其他参数<a href=\"#ssh的其他参数\" title=\"SSH的其他参数\"></a></h1><p>SSH还有一些别的参数，也值得介绍。<br>N参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -NT -D 8080 host</span></span><br></pre></td></tr></table></figure><p>f参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -f -D 8080 host</span></span><br></pre></td></tr></table></figure><p>要关闭这个后台连接，就只有用kill命令去杀掉进程。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://blog.csdn.net/pipisorry/article/details/52269785\" target=\"_blank\">原文链接</a></p>\n<h1 id=\"什么是ssh？\">什么是SSH？<a href=\"#什么是ssh？\" title=\"什么是SSH？\"></a></h1><p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。<br>SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。这里只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。</p>\n<h2 id=\"中间人攻击\">中间人攻击<a href=\"#中间人攻击\" title=\"中间人攻击\"></a></h2><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。<br>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。<br>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。<br>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。</p>\n<h1 id=\"ssh的安装\">ssh的安装<a href=\"#ssh的安装\" title=\"ssh的安装\"></a></h1><p>SSH分客户端openssh-client和openssh-server</p>\n<p>如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudoapt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server。</p>\n<p>Ubuntu缺省已经安装了ssh client。</p>\n<h2 id=\"配置ssh\">#配置ssh#<a href=\"#配置ssh\" title=\"#配置ssh#\"></a></h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo -e \"\\033[31;1m ******************************* \\033[0m\"</span><br><span class=\"line\">echo -e \"\\033[31;1m ************安装和配置ssh************ \\033[0m\"</span><br><span class=\"line\">sudo apt-get install -y openssh-server 1&gt; /dev/null</span><br><span class=\"line\">sudo sed -i 's/UsePAM no/UsePAM yes/g' /etc/ssh/sshd_config</span><br><span class=\"line\">sudo sed -i '8a /etc/init.d/ssh start' /etc/profile</span><br><span class=\"line\">sudo /etc/init.d/ssh start</span><br><span class=\"line\">ps -e | grep ssh</span><br><span class=\"line\"></span><br><span class=\"line\">echo -e \"\\033[31;1m ssh授权 \\033[0m\"</span><br><span class=\"line\">cd ~/.ssh/</span><br><span class=\"line\">ssh-keygen -t rsa</span><br><span class=\"line\">cat ./id_rsa.pub &gt;&gt; ./authorized_keys</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ps -e|grep ssh</span></span><br><span class=\"line\"> 2151 ?        00:00:00 ssh-agent</span><br><span class=\"line\"></span><br><span class=\"line\"> 5313 ?        00:00:00 sshd</span><br><span class=\"line\"></span><br><span class=\"line\">ssh-agent表示ssh-client启动，sshd表示ssh-server启动了。</span><br><span class=\"line\"></span><br><span class=\"line\">如果缺少sshd，说明ssh服务没有启动或者没有安装。</span><br></pre></td></tr></table></figure><h1 id=\"ssh基本用法\">SSH基本用法<a href=\"#ssh基本用法\" title=\"SSH基本用法\"></a></h1><h2 id=\"ssh远程登录\">SSH远程登录<a href=\"#ssh远程登录\" title=\"SSH远程登录\"></a></h2><h3 id=\"口令登录\">口令登录<a href=\"#口令登录\" title=\"口令登录\"></a></h3><p>假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh user@host  如：ssh pika@192.168.0.111</span></span><br></pre></td></tr></table></figure><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh host</span></span><br></pre></td></tr></table></figure><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -p 2222 user@host</span></span><br></pre></td></tr></table></figure><p>上面这条命令表示，ssh直接连接远程主机的2222端口。<br>如果你是第一次登录对方主机，系统会出现下面的提示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh user@host</span></span><br><span class=\"line\"></span><br><span class=\"line\">The authenticity of host 'host (12.18.429.21)' can't be established.</span><br><span class=\"line\">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？<br>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。<br>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。<br>    　　<code>Are you sure you want to continue connecting (yes/no)? yes</code><br>系统会出现一句提示，表示host主机已经得到认可。<br>    　　<code>Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.</code><br>然后，会要求输入密码。<br>    　　<code>Password: (enter password)</code><br>如果密码正确，就可以登录了。<br>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>\n<p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh host</span></span><br></pre></td></tr></table></figure><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -p 2222 user@host</span></span><br></pre></td></tr></table></figure><p>上面这条命令表示，ssh直接连接远程主机的2222端口。<br>如果你是第一次登录对方主机，系统会出现下面的提示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The authenticity of host 'host (12.18.429.21)' can't be established.</span><br><span class=\"line\">    　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class=\"line\">    　　Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？<br>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。<br>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。<br>​    　　<code>Are you sure you want to continue connecting (yes/no)? yes</code><br>系统会出现一句提示，表示host主机已经得到认可。<br>​    　　<code>Warning: Permanently added &#39;host,12.18.429.21&#39; (RSA) to the list of known hosts.</code><br>然后，会要求输入密码。<br>​    　　<code>Password: (enter password)</code><br>如果密码正确，就可以登录了。<br>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>\n<h3 id=\"公钥登录\">公钥登录<a href=\"#公钥登录\" title=\"公钥登录\"></a></h3><p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。<br>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh-keygen</span></span><br></pre></td></tr></table></figure><p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。<br>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。<br>这时再输入下面的命令，将公钥传送到远程主机host上面：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh-copy-id user@host</span></span><br></pre></td></tr></table></figure><p>好了，从此你再登录，就不需要输入密码了。<br>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RSAAuthentication yes</span><br><span class=\"line\">PubkeyAuthentication yes</span><br><span class=\"line\">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后，重启远程主机的ssh服务。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ubuntu系统</span></span><br><span class=\"line\">service ssh restart</span><br></pre></td></tr></table></figure><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># debian系统</span></span><br><span class=\"line\">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><p>authorized_keys文件<br>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。<br>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh user@host <span class=\"string\">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure><p>这条命令由多个语句组成，依次分解开来看：</p>\n<ol><li>“$ ssh user@host”，表示登录远程主机；</li><li>单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：</li><li>“$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；</li><li>‘cat &gt;&gt; .ssh/authorized_keys’ &lt; <del>/.ssh/id_rsa.pub的作用是，将本地的公钥文件</del>/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。</li></ol><p>然后，重启远程主机的ssh服务。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ubuntu系统</span></span><br><span class=\"line\">service ssh restart</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> debian系统</span></span><br><span class=\"line\">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><p>authorized_keys文件<br>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。<br>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh user@host <span class=\"string\">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure><p>这条命令由多个语句组成，依次分解开来看：（1）”$ ssh user@host”，表示登录远程主机；（2）单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：（3）”$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；（4）’cat &gt;&gt; .ssh/authorized_keys’ &lt; <del>/.ssh/id_rsa.pub的作用是，将本地的公钥文件</del>/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。</p>\n<p>[SSH原理与运用（一）：远程登录]</p>\n<p>使用ssh在远程后台不中断地跑程序<br>Linux关闭ssh（关闭终端等）后运行的程序或者服务自动停止，如python3 a.py &amp;。</p>\n<p>解决：使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup python3 a.py &amp;</span><br></pre></td></tr></table></figure><p>[linux进程管理与SELinux]</p>\n<h2 id=\"ssh连接中断\">ssh连接中断<a href=\"#ssh连接中断\" title=\"ssh连接中断\"></a></h2><p>如果使用的是iTerm2，要让ssh不断线： profiles -&gt; sessions -&gt; When idel, send ASCII code</p>\n<p>其它命令行客户端，通过配置 ServerAliveInterval 来实现，在 ~/.ssh/config 中加入： ServerAliveInterval=30。表示ssh客户端每隔30秒给远程主机发送一个no-op包，no-op是无任何操作的意思，这样远程主机就不会关闭这个SSH会话。</p>\n<p>vim ~/.ssh/config，然后新增</p>\n<p>Host *<br>    ServerAliveInterval 60<br>60秒就好了，而且基本去连的机器都保持，所以配置了*，如果有需要针对某个机器，可以自行配置为需要的serverHostName。</p>\n<p>[ssh保持连接不断开]</p>\n<h2 id=\"ssh远程操作\">SSH远程操作<a href=\"#ssh远程操作\" title=\"SSH远程操作\"></a></h2><h3 id=\"ssh数据传输\">SSH数据传输<a href=\"#ssh数据传输\" title=\"SSH数据传输\"></a></h3><p>SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。<br>    　　$ ssh user@host ‘mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub<br>单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。<br>这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。<br>下面看几个例子。<br>【例1】<br>将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。<br>    　　$ cd &amp;&amp; tar czv src | ssh user@host ‘tar xz’<br>【例2】<br>将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。<br>    　　$ ssh user@host ‘tar cz src’ | tar xzv<br>【例3】<br>查看远程主机是否运行进程httpd。<br>    　　$ ssh user@host ‘ps ax | grep [h]ttpd’</p>\n<p>lz建议使用scp进行远程copy：</p>\n<p>scp 跨机远程拷贝<br>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限。</p>\n<h3 id=\"scp命令参数\">scp命令参数<a href=\"#scp命令参数\" title=\"scp命令参数\"></a></h3><ul><li>-1 强制scp命令使用协议ssh1</li><li>-2 强制scp命令使用协议ssh2</li><li>-4 强制scp命令只使用IPv4寻址</li><li>-6 强制scp命令只使用IPv6寻址</li><li>-B 使用批处理模式（传输过程中不询问传输口令或短语）</li><li>-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li><li>-p 留原文件的修改时间，访问时间和访问权限。</li><li>-q 不显示传输进度条。</li><li>-r 递归复制整个目录。</li><li>-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li><li>-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li><li>-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li><li>-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li><li>-l limit 限定用户所能使用的带宽，以Kbit/s为单位。</li><li>-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，</li><li>-P port 注意是大写的P, port是指定数据传输用到的端口号</li><li>-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li><li>scp一般有六种使用方法<ul><li>本地复制远程文件：（把远程的文件复制到本地）</li><li>scp <a href=\"mailto:root@www.test.com\">root@www.test.com</a>:/val/test/test.tar.gz /val/test/test.tar.gz<br>远程复制本地文件：（把本地的文件复制到远程主机上）</li><li>scp /val/test.tar.gz <a href=\"mailto:root@www.test.com\">root@www.test.com</a>:/val/test.tar.gz<br>本地复制远程目录：（把远程的目录复制到本地）</li><li>scp -r <a href=\"mailto:root@www.test.com\">root@www.test.com</a>:/val/test/ /val/test/<br>远程复制本地目录：（把本地的目录复制到远程主机上）</li><li>scp -r ./ubuntu_env/ <a href=\"mailto:root@192.168.0.111\">root@192.168.0.111</a>:/home/pipi</li><li>pika:/media/pika/files/machine_learning/datasets$scp -r SocialNetworks/</li><li><a href=\"mailto:piting@192.168.0.172\">piting@192.168.0.172</a>:/media/data/pipi/datasets</li></ul></li><li>本地复制远程文件到指定目录：（把远程的文件复制到本地）</li><li>scp <a href=\"mailto:root@www.test.com\">root@www.test.com</a>:/val/test/test.tar.gz /val/test/<br>远程复制本地文件到指定目录：（把本地的文件复制到远程主机上）</li><li>scp /val/test.tar.gz <a href=\"mailto:root@www.test.com\">root@www.test.com</a>:/val/</li></ul><p>ps: scp复制文件时只指定服务器地址不加路径默认复制到哪里???</p>\n<p>[12个scp传输文件的命令栗子]</p>\n<p>[scp 跨机远程拷贝]</p>\n<h2 id=\"ssh端口操作\">SSH端口操作<a href=\"#ssh端口操作\" title=\"SSH端口操作\"></a></h2><h3 id=\"绑定本地端口\">绑定本地端口<a href=\"#绑定本地端口\" title=\"绑定本地端口\"></a></h3><p>既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。<br>假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：<br>    　　$ ssh -D 8080 user@host<br>SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。</p>\n<h3 id=\"本地端口转发\">本地端口转发<a href=\"#本地端口转发\" title=\"本地端口转发\"></a></h3><p>有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）。<br>假定host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。<br>我们在host1执行下面的命令：<br>    　　$ ssh -L 2121:host2:21 host3<br>命令中的L参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。<br>这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。<br>    　　$ ftp localhost:2121<br>“本地端口转发”使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH隧道”。<br>下面是一个比较有趣的例子。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -L 5900:localhost:5900 host3</span></span><br></pre></td></tr></table></figure><p>它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。<br>另一个例子是通过host3的端口转发，ssh登录host2。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -L 9001:host2:22 host3</span></span><br></pre></td></tr></table></figure><p>这时，只要ssh登录本机的9001端口，就相当于登录host2了。 　　</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -p 9001 localhost</span></span><br></pre></td></tr></table></figure><p>上面的-p参数表示指定登录端口。</p>\n<p>出错处理：ssh: Could not resolve hostname 192.168.<em>.</em>:***: Name or service not known</p>\n<p>解决：指定端口不能直接使用ip:端口号，使用-p参数来解决就可以了。</p>\n<h3 id=\"远程端口转发\">远程端口转发<a href=\"#远程端口转发\" title=\"远程端口转发\"></a></h3><p>既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。<br>还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，”本地端口转发”就不能用了，怎么办？<br>解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。<br>我们在host3执行下面的命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -R 2121:host2:21 host1</span></span><br></pre></td></tr></table></figure><p>R参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。<br>绑定之后，我们在host1就可以连接host2了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ftp localhost:2121</span></span><br></pre></td></tr></table></figure><p>这里必须指出，”远程端口转发”的前提条件是，host1和host3两台主机都有sshD和ssh客户端。</p>\n<h1 id=\"ssh的其他参数\">SSH的其他参数<a href=\"#ssh的其他参数\" title=\"SSH的其他参数\"></a></h1><p>SSH还有一些别的参数，也值得介绍。<br>N参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -NT -D 8080 host</span></span><br></pre></td></tr></table></figure><p>f参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ssh -f -D 8080 host</span></span><br></pre></td></tr></table></figure><p>要关闭这个后台连接，就只有用kill命令去杀掉进程。</p>\n","date_formatted":{"ll":"Oct 7, 2019","L":"10/07/2019","MM-DD":"10-07"},"plink":"https://treeeeeeee.github.io/2019/10/07/ssh用法及命令/","type":"post","toc":[{"id":"什么是ssh？","title":"什么是SSH？","index":"1","children":[{"id":"中间人攻击","title":"中间人攻击","index":"1.1"}]},{"id":"ssh的安装","title":"ssh的安装","index":"2","children":[{"id":"配置ssh","title":"#配置ssh#","index":"2.1"}]},{"id":"ssh基本用法","title":"SSH基本用法","index":"3","children":[{"id":"ssh远程登录","title":"SSH远程登录","index":"3.1","children":[{"id":"口令登录","title":"口令登录","index":"3.1.1"},{"id":"公钥登录","title":"公钥登录","index":"3.1.2"}]},{"id":"ssh连接中断","title":"ssh连接中断","index":"3.2"},{"id":"ssh远程操作","title":"SSH远程操作","index":"3.3","children":[{"id":"ssh数据传输","title":"SSH数据传输","index":"3.3.1"},{"id":"scp命令参数","title":"scp命令参数","index":"3.3.2"}]},{"id":"ssh端口操作","title":"SSH端口操作","index":"3.4","children":[{"id":"绑定本地端口","title":"绑定本地端口","index":"3.4.1"},{"id":"本地端口转发","title":"本地端口转发","index":"3.4.2"},{"id":"远程端口转发","title":"远程端口转发","index":"3.4.3"}]}]},{"id":"ssh的其他参数","title":"SSH的其他参数","index":"4"}]},{"title":"命令行后台运行程序命令","author":"Jon","date":"2019-10-03T15:50:00.000Z","_content":"#  后台执行命令：&和nohup\n\n## 归纳：\n\n#### `ps -ef`或者`grep`查看进程\n\n#### `kill XX`杀死进程，`XX`替换为进程PID\n\n#### 命令后加`&`后台运行，但生命周期受窗口限制\n\n#### `nohup 命令 &`完全后台运行\n\n[**原文链接**](https://blog.csdn.net/liuyanfeier/article/details/62422742)，本文归纳梳理，便于自己记忆。\n\n## 后台运行命令\n\n### &  \n\n`断开链接或者关闭窗口仍然会终止程序`\n\n> 在命令后面加上& 实现后台运行。例如：\n\n```\nsh test.sh &\n```\n\n> * 适合在后台运行的命令有find、费时的排序及一些shell脚本。\n>\n> * 需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。\n>\n> * 后台运行一样会将结果输出到屏幕上，干扰你的工作。\n>\n> * 如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中\n>\n> `命令  >  out.file  2>&1  & 1`\n>\n> 这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。\n>\n> * 当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它\n>\n>   **(ps -ef | grep 进程号 或者 kill -9 进程号）**\n\n### nohup\n\n `可退出命令窗口使用`\n\n> * 使用&命令后，作业被提交到后台运行，当前控制台没有被占用\n>\n> * 一但把当前控制台关掉(退出帐户时)，作业就会停止运行。\n>\n> * **nohup命令**可以在你退出帐户之后继续运行相应的进程。\n>\n>   > nohup就是不挂起的意思( no hang up)。该命令的一般形式为：\n\n```\nnohup 命令 &1\n```\n\n如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：\n\n```\nnohup command > myout.file 2>&1 &1\n```\n\n## 注意\n\n使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。\n\n- ctrl + z\n  可以将一个正在前台执行的命令放到后台，并且处于暂停状态。\n- ctrl+c\n  终止前台命令。\n- jobs\n  查看当前有多少在后台运行的命令。\n  jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。\n- 2>&1解析\n\n```\ncommand >out.file 2>&1 &1\n```\n\n1. command>out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。\n2. 2>&1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&， 是让该命令在后台执行。\n3. 试想2>1代表什么，2与>结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2>&1，&与1结合就代表标准输出了，就变成错误重定向到标准输出.","source":"_posts/linux后台运行程序.md","raw":"title: 命令行后台运行程序命令\nauthor: Jon\ntags:\n  - 知识就是力量\ncategories:\n  - Linux\ndate: 2019-10-03 23:50:00\n---\n#  后台执行命令：&和nohup\n\n## 归纳：\n\n#### `ps -ef`或者`grep`查看进程\n\n#### `kill XX`杀死进程，`XX`替换为进程PID\n\n#### 命令后加`&`后台运行，但生命周期受窗口限制\n\n#### `nohup 命令 &`完全后台运行\n\n[**原文链接**](https://blog.csdn.net/liuyanfeier/article/details/62422742)，本文归纳梳理，便于自己记忆。\n\n## 后台运行命令\n\n### &  \n\n`断开链接或者关闭窗口仍然会终止程序`\n\n> 在命令后面加上& 实现后台运行。例如：\n\n```\nsh test.sh &\n```\n\n> * 适合在后台运行的命令有find、费时的排序及一些shell脚本。\n>\n> * 需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。\n>\n> * 后台运行一样会将结果输出到屏幕上，干扰你的工作。\n>\n> * 如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中\n>\n> `命令  >  out.file  2>&1  & 1`\n>\n> 这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。\n>\n> * 当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它\n>\n>   **(ps -ef | grep 进程号 或者 kill -9 进程号）**\n\n### nohup\n\n `可退出命令窗口使用`\n\n> * 使用&命令后，作业被提交到后台运行，当前控制台没有被占用\n>\n> * 一但把当前控制台关掉(退出帐户时)，作业就会停止运行。\n>\n> * **nohup命令**可以在你退出帐户之后继续运行相应的进程。\n>\n>   > nohup就是不挂起的意思( no hang up)。该命令的一般形式为：\n\n```\nnohup 命令 &1\n```\n\n如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：\n\n```\nnohup command > myout.file 2>&1 &1\n```\n\n## 注意\n\n使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。\n\n- ctrl + z\n  可以将一个正在前台执行的命令放到后台，并且处于暂停状态。\n- ctrl+c\n  终止前台命令。\n- jobs\n  查看当前有多少在后台运行的命令。\n  jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。\n- 2>&1解析\n\n```\ncommand >out.file 2>&1 &1\n```\n\n1. command>out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。\n2. 2>&1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&， 是让该命令在后台执行。\n3. 试想2>1代表什么，2与>结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2>&1，&与1结合就代表标准输出了，就变成错误重定向到标准输出.","slug":"linux后台运行程序","published":1,"updated":"2019-12-30T02:50:50.956Z","comments":1,"layout":"post","photos":[],"link":"2019/10/03/linux后台运行程序","_id":"ck8jl8qiu0012w0w0emwphil5","content":"<h1 id=\"后台执行命令：amp和nohup\">后台执行命令：&amp;和nohup<a href=\"#后台执行命令：amp和nohup\" title=\"后台执行命令：&amp;和nohup\"></a></h1><h2 id=\"归纳：\">归纳：<a href=\"#归纳：\" title=\"归纳：\"></a></h2><h4 id=\"ps--ef或者grep查看进程\"><code>ps -ef</code>或者<code>grep</code>查看进程<a href=\"#ps--ef或者grep查看进程\" title=\"ps -ef或者grep查看进程\"></a></h4><h4 id=\"kill-xx杀死进程，xx替换为进程pid\"><code>kill XX</code>杀死进程，<code>XX</code>替换为进程PID<a href=\"#kill-xx杀死进程，xx替换为进程pid\" title=\"kill XX杀死进程，XX替换为进程PID\"></a></h4><h4 id=\"命令后加amp后台运行，但生命周期受窗口限制\">命令后加<code>&amp;</code>后台运行，但生命周期受窗口限制<a href=\"#命令后加amp后台运行，但生命周期受窗口限制\" title=\"命令后加&amp;后台运行，但生命周期受窗口限制\"></a></h4><h4 id=\"nohup-命令-amp完全后台运行\"><code>nohup 命令 &amp;</code>完全后台运行<a href=\"#nohup-命令-amp完全后台运行\" title=\"nohup 命令 &amp;完全后台运行\"></a></h4><p><a href=\"https://blog.csdn.net/liuyanfeier/article/details/62422742\" target=\"_blank\"><strong>原文链接</strong></a>，本文归纳梳理，便于自己记忆。</p>\n<h2 id=\"后台运行命令\">后台运行命令<a href=\"#后台运行命令\" title=\"后台运行命令\"></a></h2><h3 id=\"amp\">&amp;<a href=\"#amp\" title=\"&amp;\"></a></h3><p><code>断开链接或者关闭窗口仍然会终止程序</code></p>\n<blockquote>\n<p>在命令后面加上&amp; 实现后台运行。例如：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh test.sh &amp;</span><br></pre></td></tr></table></figure><blockquote>\n<ul><li><p>适合在后台运行的命令有find、费时的排序及一些shell脚本。</p></li><li><p>需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。</p></li><li><p>后台运行一样会将结果输出到屏幕上，干扰你的工作。</p></li><li><p>如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中</p></li></ul><p><code>命令  &gt;  out.file  2&gt;&amp;1  &amp; 1</code></p>\n<p>这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。</p>\n<ul><li><p>当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它</p><p><strong>(ps -ef | grep 进程号 或者 kill -9 进程号）</strong></p></li></ul></blockquote>\n<h3 id=\"nohup\">nohup<a href=\"#nohup\" title=\"nohup\"></a></h3><p> <code>可退出命令窗口使用</code></p>\n<blockquote>\n<ul><li><p>使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用</p></li><li><p>一但把当前控制台关掉(退出帐户时)，作业就会停止运行。</p></li><li><p><strong>nohup命令</strong>可以在你退出帐户之后继续运行相应的进程。</p><blockquote><p>nohup就是不挂起的意思( no hang up)。该命令的一般形式为：</p></blockquote></li></ul></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup 命令 &amp;1</span><br></pre></td></tr></table></figure><p>如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup command &gt; myout.file 2&gt;&amp;1 &amp;1</span><br></pre></td></tr></table></figure><h2 id=\"注意\">注意<a href=\"#注意\" title=\"注意\"></a></h2><p>使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。</p>\n<ul><li>ctrl + z<br>可以将一个正在前台执行的命令放到后台，并且处于暂停状态。</li><li>ctrl+c<br>终止前台命令。</li><li>jobs<br>查看当前有多少在后台运行的命令。<br>jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。</li><li>2&gt;&amp;1解析</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command &gt;out.file 2&gt;&amp;1 &amp;1</span><br></pre></td></tr></table></figure><ol><li>command&gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。</li><li>2&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行。</li><li>试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.</li></ol>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"后台执行命令：amp和nohup\">后台执行命令：&amp;和nohup<a href=\"#后台执行命令：amp和nohup\" title=\"后台执行命令：&amp;和nohup\"></a></h1><h2 id=\"归纳：\">归纳：<a href=\"#归纳：\" title=\"归纳：\"></a></h2><h4 id=\"ps--ef或者grep查看进程\"><code>ps -ef</code>或者<code>grep</code>查看进程<a href=\"#ps--ef或者grep查看进程\" title=\"ps -ef或者grep查看进程\"></a></h4><h4 id=\"kill-xx杀死进程，xx替换为进程pid\"><code>kill XX</code>杀死进程，<code>XX</code>替换为进程PID<a href=\"#kill-xx杀死进程，xx替换为进程pid\" title=\"kill XX杀死进程，XX替换为进程PID\"></a></h4><h4 id=\"命令后加amp后台运行，但生命周期受窗口限制\">命令后加<code>&amp;</code>后台运行，但生命周期受窗口限制<a href=\"#命令后加amp后台运行，但生命周期受窗口限制\" title=\"命令后加&amp;后台运行，但生命周期受窗口限制\"></a></h4><h4 id=\"nohup-命令-amp完全后台运行\"><code>nohup 命令 &amp;</code>完全后台运行<a href=\"#nohup-命令-amp完全后台运行\" title=\"nohup 命令 &amp;完全后台运行\"></a></h4><p><a href=\"https://blog.csdn.net/liuyanfeier/article/details/62422742\" target=\"_blank\"><strong>原文链接</strong></a>，本文归纳梳理，便于自己记忆。</p>\n<h2 id=\"后台运行命令\">后台运行命令<a href=\"#后台运行命令\" title=\"后台运行命令\"></a></h2><h3 id=\"amp\">&amp;<a href=\"#amp\" title=\"&amp;\"></a></h3><p><code>断开链接或者关闭窗口仍然会终止程序</code></p>\n<blockquote>\n<p>在命令后面加上&amp; 实现后台运行。例如：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh test.sh &amp;</span><br></pre></td></tr></table></figure><blockquote>\n<ul><li><p>适合在后台运行的命令有find、费时的排序及一些shell脚本。</p></li><li><p>需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。</p></li><li><p>后台运行一样会将结果输出到屏幕上，干扰你的工作。</p></li><li><p>如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中</p></li></ul><p><code>命令  &gt;  out.file  2&gt;&amp;1  &amp; 1</code></p>\n<p>这样，所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。</p>\n<ul><li><p>当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它</p><p><strong>(ps -ef | grep 进程号 或者 kill -9 进程号）</strong></p></li></ul></blockquote>\n<h3 id=\"nohup\">nohup<a href=\"#nohup\" title=\"nohup\"></a></h3><p> <code>可退出命令窗口使用</code></p>\n<blockquote>\n<ul><li><p>使用&amp;命令后，作业被提交到后台运行，当前控制台没有被占用</p></li><li><p>一但把当前控制台关掉(退出帐户时)，作业就会停止运行。</p></li><li><p><strong>nohup命令</strong>可以在你退出帐户之后继续运行相应的进程。</p><blockquote><p>nohup就是不挂起的意思( no hang up)。该命令的一般形式为：</p></blockquote></li></ul></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup 命令 &amp;1</span><br></pre></td></tr></table></figure><p>如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup command &gt; myout.file 2&gt;&amp;1 &amp;1</span><br></pre></td></tr></table></figure><h2 id=\"注意\">注意<a href=\"#注意\" title=\"注意\"></a></h2><p>使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。</p>\n<ul><li>ctrl + z<br>可以将一个正在前台执行的命令放到后台，并且处于暂停状态。</li><li>ctrl+c<br>终止前台命令。</li><li>jobs<br>查看当前有多少在后台运行的命令。<br>jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。</li><li>2&gt;&amp;1解析</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command &gt;out.file 2&gt;&amp;1 &amp;1</span><br></pre></td></tr></table></figure><ol><li>command&gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。</li><li>2&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&amp;， 是让该命令在后台执行。</li><li>试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.</li></ol>","date_formatted":{"ll":"Oct 3, 2019","L":"10/03/2019","MM-DD":"10-03"},"plink":"https://treeeeeeee.github.io/2019/10/03/linux后台运行程序/","type":"post","toc":[{"id":"后台执行命令：amp和nohup","title":"后台执行命令：&amp;和nohup","index":"1","children":[{"id":"归纳：","title":"归纳：","index":"1.1"},{"id":"后台运行命令","title":"后台运行命令","index":"1.2","children":[{"id":"amp","title":"&amp;","index":"1.2.1"},{"id":"nohup","title":"nohup","index":"1.2.2"}]},{"id":"注意","title":"注意","index":"1.3"}]}]},{"title":"windows脚本转移Linux上git命令出现错误","author":"Jon","date":"2019-10-03T15:18:00.000Z","_content":"## 场景\n\n在我将整个hexo博客源码从windows10转移到linux（centos7）中时，脚本中的git命令没有例外的出现了这个错误\n\n```bash\ngit: 'pull' is not a git command. See 'git --help'.  \nDid you mean one of these? \n\t\tpull\n\ngit: 'push' is not a git command. See 'git --help'.  \nDid you mean one of these? \n\t\tpush\n\n```\n\n这是什么人间疾苦，于是我Google，找到最接近的答案就是这个\n\n[https://stackoverflow.com/questions/1465398/git-pull-broken](https://stackoverflow.com/questions/1465398/git-pull-broken)\n\n这是十年前的一个issue，很明显不是这个问题。git早已经修正了这个issue。\n\n**那么问题来了，这到底是什么原因导致git认为你认为完全正确的命令是有问题的呢：**\n\n* 首先我保证绝对不是git版本的问题，我反复在服务器上更替了不同版本的git，无论是直接安装编译好的版本还是自己编译都多次尝试过，但是无一例外出错了。还是相同的错误。\n* 其次脚本绝对是可运行的，在windows上可以正确无误的执行。\n* 服务器镜像问题？没钱换服务器，况且服务器上运行了不少东西，不好更换，但我觉得的应该不是，其他脚本命令是可以运行的。\n\n那到底是哪的问题呢？\n\n## 解决\n\n最后我几乎快完全丧失解决它的希望时，我进行了最后一次尝试。\n\n**用在linux  vim重写脚本，发现在写的途中有些命令写出现和原来的颜色是不一样的**\n\n最后脚本运行成功。\n\n**所以千万别用windows10的记事本写代码，应该是编码的问题，还是建议用专业的编辑器写脚本**","source":"_posts/windows脚本转移Linux上git命令出现错误.md","raw":"title: \"windows脚本转移Linux上git命令出现错误\"\nauthor: Jon\ntags:\n\n  - 巨坑\ncategories:\n  - 错误记录\ndate: 2019-10-03 23:18:00\n---\n## 场景\n\n在我将整个hexo博客源码从windows10转移到linux（centos7）中时，脚本中的git命令没有例外的出现了这个错误\n\n```bash\ngit: 'pull' is not a git command. See 'git --help'.  \nDid you mean one of these? \n\t\tpull\n\ngit: 'push' is not a git command. See 'git --help'.  \nDid you mean one of these? \n\t\tpush\n\n```\n\n这是什么人间疾苦，于是我Google，找到最接近的答案就是这个\n\n[https://stackoverflow.com/questions/1465398/git-pull-broken](https://stackoverflow.com/questions/1465398/git-pull-broken)\n\n这是十年前的一个issue，很明显不是这个问题。git早已经修正了这个issue。\n\n**那么问题来了，这到底是什么原因导致git认为你认为完全正确的命令是有问题的呢：**\n\n* 首先我保证绝对不是git版本的问题，我反复在服务器上更替了不同版本的git，无论是直接安装编译好的版本还是自己编译都多次尝试过，但是无一例外出错了。还是相同的错误。\n* 其次脚本绝对是可运行的，在windows上可以正确无误的执行。\n* 服务器镜像问题？没钱换服务器，况且服务器上运行了不少东西，不好更换，但我觉得的应该不是，其他脚本命令是可以运行的。\n\n那到底是哪的问题呢？\n\n## 解决\n\n最后我几乎快完全丧失解决它的希望时，我进行了最后一次尝试。\n\n**用在linux  vim重写脚本，发现在写的途中有些命令写出现和原来的颜色是不一样的**\n\n最后脚本运行成功。\n\n**所以千万别用windows10的记事本写代码，应该是编码的问题，还是建议用专业的编辑器写脚本**","slug":"windows脚本转移Linux上git命令出现错误","published":1,"updated":"2019-12-30T02:50:50.958Z","comments":1,"layout":"post","photos":[],"link":"2019/10/03/windows脚本转移Linux上git命令出现错误","_id":"ck8jl8qiv0014w0w07orverv4","content":"<h2 id=\"场景\">场景<a href=\"#场景\" title=\"场景\"></a></h2><p>在我将整个hexo博客源码从windows10转移到linux（centos7）中时，脚本中的git命令没有例外的出现了这个错误</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git: <span class=\"string\">'pull'</span> is not a git <span class=\"built_in\">command</span>. See <span class=\"string\">'git --help'</span>.  </span><br><span class=\"line\">Did you mean one of these? </span><br><span class=\"line\">\t\tpull</span><br><span class=\"line\"></span><br><span class=\"line\">git: <span class=\"string\">'push'</span> is not a git <span class=\"built_in\">command</span>. See <span class=\"string\">'git --help'</span>.  </span><br><span class=\"line\">Did you mean one of these? </span><br><span class=\"line\">\t\tpush</span><br></pre></td></tr></table></figure><p>这是什么人间疾苦，于是我Google，找到最接近的答案就是这个</p>\n<p><a href=\"https://stackoverflow.com/questions/1465398/git-pull-broken\" target=\"_blank\">https://stackoverflow.com/questions/1465398/git-pull-broken</a></p>\n<p>这是十年前的一个issue，很明显不是这个问题。git早已经修正了这个issue。</p>\n<p><strong>那么问题来了，这到底是什么原因导致git认为你认为完全正确的命令是有问题的呢：</strong></p>\n<ul><li>首先我保证绝对不是git版本的问题，我反复在服务器上更替了不同版本的git，无论是直接安装编译好的版本还是自己编译都多次尝试过，但是无一例外出错了。还是相同的错误。</li><li>其次脚本绝对是可运行的，在windows上可以正确无误的执行。</li><li>服务器镜像问题？没钱换服务器，况且服务器上运行了不少东西，不好更换，但我觉得的应该不是，其他脚本命令是可以运行的。</li></ul><p>那到底是哪的问题呢？</p>\n<h2 id=\"解决\">解决<a href=\"#解决\" title=\"解决\"></a></h2><p>最后我几乎快完全丧失解决它的希望时，我进行了最后一次尝试。</p>\n<p><strong>用在linux  vim重写脚本，发现在写的途中有些命令写出现和原来的颜色是不一样的</strong></p>\n<p>最后脚本运行成功。</p>\n<p><strong>所以千万别用windows10的记事本写代码，应该是编码的问题，还是建议用专业的编辑器写脚本</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"场景\">场景<a href=\"#场景\" title=\"场景\"></a></h2><p>在我将整个hexo博客源码从windows10转移到linux（centos7）中时，脚本中的git命令没有例外的出现了这个错误</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git: <span class=\"string\">'pull'</span> is not a git <span class=\"built_in\">command</span>. See <span class=\"string\">'git --help'</span>.  </span><br><span class=\"line\">Did you mean one of these? </span><br><span class=\"line\">\t\tpull</span><br><span class=\"line\"></span><br><span class=\"line\">git: <span class=\"string\">'push'</span> is not a git <span class=\"built_in\">command</span>. See <span class=\"string\">'git --help'</span>.  </span><br><span class=\"line\">Did you mean one of these? </span><br><span class=\"line\">\t\tpush</span><br></pre></td></tr></table></figure><p>这是什么人间疾苦，于是我Google，找到最接近的答案就是这个</p>\n<p><a href=\"https://stackoverflow.com/questions/1465398/git-pull-broken\" target=\"_blank\">https://stackoverflow.com/questions/1465398/git-pull-broken</a></p>\n<p>这是十年前的一个issue，很明显不是这个问题。git早已经修正了这个issue。</p>\n<p><strong>那么问题来了，这到底是什么原因导致git认为你认为完全正确的命令是有问题的呢：</strong></p>\n<ul><li>首先我保证绝对不是git版本的问题，我反复在服务器上更替了不同版本的git，无论是直接安装编译好的版本还是自己编译都多次尝试过，但是无一例外出错了。还是相同的错误。</li><li>其次脚本绝对是可运行的，在windows上可以正确无误的执行。</li><li>服务器镜像问题？没钱换服务器，况且服务器上运行了不少东西，不好更换，但我觉得的应该不是，其他脚本命令是可以运行的。</li></ul><p>那到底是哪的问题呢？</p>\n<h2 id=\"解决\">解决<a href=\"#解决\" title=\"解决\"></a></h2><p>最后我几乎快完全丧失解决它的希望时，我进行了最后一次尝试。</p>\n<p><strong>用在linux  vim重写脚本，发现在写的途中有些命令写出现和原来的颜色是不一样的</strong></p>\n<p>最后脚本运行成功。</p>\n<p><strong>所以千万别用windows10的记事本写代码，应该是编码的问题，还是建议用专业的编辑器写脚本</strong></p>\n","date_formatted":{"ll":"Oct 3, 2019","L":"10/03/2019","MM-DD":"10-03"},"plink":"https://treeeeeeee.github.io/2019/10/03/windows脚本转移Linux上git命令出现错误/","type":"post","toc":[{"id":"场景","title":"场景","index":"1"},{"id":"解决","title":"解决","index":"2"}]},{"title":"基于酷q平台的管理机器人","date":"2019-10-01T12:15:14.000Z","_content":"\n## 酷Q机器人\n\n***********************\n\n**自从samrtQQ下线之后，很多QQ机器人都失效了。**\n\n**但是最近又比较想用这样一个机器人来管理减轻自己的一些工作，于是千方百计的我发现了酷Q。**\n\n**这里附上[官网链接](https://cqp.cc/)**\n\n### 开发以及注意事项\n1. ##### SDK的选择\n\n   酷q提供了多种[SDK](https://cqp.cc/t/15124)但是都是我不常用的，官方的支持的SDK是E语言，这语言emmmm好，都好，写，都可以写。虽然提供了java的sdk但是java版本始终不是正统，咬牙学了一天E语言，最后还是吐了。没办法，不习惯，没说E语言不好。害，最后还是选择的java版本。不过但是还没开始使用的时候我看到了更加好用的一个找到一个更加好用方便的SDK-[PicqBotX](https://github.com/HyDevelop/PicqBotX)，这是通过http的插件来与酷q的程序交互。虽然不能像官方网站上提供的那个那样可以直接打包成jar运行但是个人认为开发更加简单。\n\n2. **环境以及配置细节**\n\n   [这里讲得很清楚，以下说明几个坑](https://github.com/HyDevelop/PicqBotX)：\n\n   * 如果使用kotlin代替java进行开发，请最好使用Gradle对项目进行管理，它对kotlin有更加完美的支持。\n\n   * ![](基于酷q平台的管理机器人/酷q配置坏境的注意事项.jpg)\n\n     在介绍readme中的这个位置一定要看准，下载对应版本的工具，否则可能出问题，比较麻烦，而且没有提示难以排查。\n\n   * 两个端口号一定要对应于你程序中的机器人的端口号否则会链接失败（建议直接用默认的31091 31092，也可自己选择）\n\n\n\n### 本人开发流程\n\n1. 使用idea新建项目选择gradle管理项目![](基于酷q平台的管理机器人/idea新建项目.png)java版本任意，需要kotlin开发勾选kotlin\n\n2. 导包\n\n   ![](基于酷q平台的管理机器人/导包.png)\n\n   导入最新的sdk。\n\n3. 根据需要复制示例代码更改\n\n   ```java\n   public class TestBot\n   {\n       public static void main(String[] args)\n       {\n           // 创建机器人对象 ( 传入配置 )\n           PicqBotX bot = new PicqBotX(new PicqConfig(31092).setDebug(true));\n   \n           // 添加一个机器人账户 ( 名字, 发送URL, 发送端口 )\n           bot.addAccount(\"Bot01\", \"127.0.0.1\", 31091);\n   \n           // 注册事件监听器, 可以注册多个监听器\n           bot.getEventManager().registerListeners(\n                   new TestListener(), \n                   new RequestListener(),\n                   new ExceptionListener()\n           );\n   \n           // 启用指令管理器\n           // 这些字符串是指令前缀, 比如指令\"!help\"的前缀就是\"!\"\n           bot.enableCommandManager(\"bot -\", \"!\", \"/\", \"~\");\n   \n           // 注册指令, 可以注册多个指令\n           bot.getCommandManager().registerCommands(\n                   new CommandSay(),\n                   new CommandTest(),\n                   new CommandVersion()\n           );\n   \n           // 启动机器人, 不会占用主线程\n           bot.startBot();\n       }\n   }\n   ```\n\n\n\n### 个人实现效果和功能\n\n- 通知功能\n\n  <img src=\"基于酷q平台的管理机器人/通知.jpg\" style=\"zoom:50%;\" />\n\n- 请假功能\n\n  有学生请假则会以json格式文本保存在服务器（或者本地）\n\n  <img src=\"基于酷q平台的管理机器人/请假.jpg\" style=\"zoom: 33%;\" />\n\n- 导出请假表格文档，会直接给下载链接\n\n  <img src=\"基于酷q平台的管理机器人/请假文档.jpg\" style=\"zoom: 50%;\" />\n\n- 补登请假\n\n  <img src=\"基于酷q平台的管理机器人/补登请假.jpg\" style=\"zoom: 50%;\" />\n\n- 还有安卓端的管理app和网页版实时查看数据。\n\n\n\n### 部署机器人\n\n**在winows server上部署**\n\n太简单了，省略具体步骤，总结解释就是以下步骤：\n\n* 电脑上安装上所有酷q，http插件，java所需要的环境，跟你的本地一样（本地会配置，我想server上配置也难不倒聪明的你）\n* 打包你的机器人，可以是jar可以是其他的，只要是能够将你的代码打包运行就好\n* 运行酷q，打开http插件，运行你的机器人。\n\n**在linux上部署**\n\n因为酷q是window程序，要想在linux上部署那就必须得使用docker（不知道docker是什么的请百度），由于不是专业运维方向对docker不是很了解，也踩了很多坑。\n\n这里附上http插件的[官方教程](https://cqhttp.cc/docs)，里面有详细的描述如何安装最新的酷q的docker镜像，如果docker还没安装自行百度安装你的服务器的docker。\n\n然后基本上和以上步骤都是差不多，但是有个地方需要注意\n\n![image-20191113001251371](%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20191113001251371.png)\n\n这里的上报地址，理所当然就是酷q接收到消息之后传递给你的程序去处理，但是在docker中利用127.0.0.1是访问的docker内部，而你的机器人程序并不是在docker内所以，酷q是无法将消息上报给你的机器人的，有以下解决方案：\n\n* 对于mac和windows可以使用host.docker.internal替换127.0.0.1\n\n* 对于Linux可以创建一个桥接网络(我在网络上查找的，自己在centos上没有尝试成功)\n  下面的localNet是网络名字,可自行修改;关于192.168.0.0这个子网,也可以自行定义.\n  默认按照下面的命令,执行后将可以通过192.168.0.1访问宿主机\n\n  `docker network create -d bridge --subnet 192.168.0.0/24 --gateway 192.168.0.1 localNet`\n\n* 若你是在你的服务器上部署的你的机器人，可以直接使用服务器的公网ip\n\n只有这样酷q才能将消息上报到你的机器人处理,否则你的机器人只能发送消息，不能接收消息并作出反应。\n\n### 用到的库\n\n*********************************\n\n* 阿帕奇的表格框架\n* gson\n\n通知管理机器人源代码地址：[冷漠无情的机器人]()\n\n因为源代码中有不少私人数据，所以取消。\n\n","source":"_posts/基于酷q平台的管理机器人.md","raw":"---\ntitle: 基于酷q平台的管理机器人\ndate: 2019-10-01 20:15:14\ntags:\n- 世界这么大，当然要多去看看\ncategories: 兴趣\n---\n\n## 酷Q机器人\n\n***********************\n\n**自从samrtQQ下线之后，很多QQ机器人都失效了。**\n\n**但是最近又比较想用这样一个机器人来管理减轻自己的一些工作，于是千方百计的我发现了酷Q。**\n\n**这里附上[官网链接](https://cqp.cc/)**\n\n### 开发以及注意事项\n1. ##### SDK的选择\n\n   酷q提供了多种[SDK](https://cqp.cc/t/15124)但是都是我不常用的，官方的支持的SDK是E语言，这语言emmmm好，都好，写，都可以写。虽然提供了java的sdk但是java版本始终不是正统，咬牙学了一天E语言，最后还是吐了。没办法，不习惯，没说E语言不好。害，最后还是选择的java版本。不过但是还没开始使用的时候我看到了更加好用的一个找到一个更加好用方便的SDK-[PicqBotX](https://github.com/HyDevelop/PicqBotX)，这是通过http的插件来与酷q的程序交互。虽然不能像官方网站上提供的那个那样可以直接打包成jar运行但是个人认为开发更加简单。\n\n2. **环境以及配置细节**\n\n   [这里讲得很清楚，以下说明几个坑](https://github.com/HyDevelop/PicqBotX)：\n\n   * 如果使用kotlin代替java进行开发，请最好使用Gradle对项目进行管理，它对kotlin有更加完美的支持。\n\n   * ![](基于酷q平台的管理机器人/酷q配置坏境的注意事项.jpg)\n\n     在介绍readme中的这个位置一定要看准，下载对应版本的工具，否则可能出问题，比较麻烦，而且没有提示难以排查。\n\n   * 两个端口号一定要对应于你程序中的机器人的端口号否则会链接失败（建议直接用默认的31091 31092，也可自己选择）\n\n\n\n### 本人开发流程\n\n1. 使用idea新建项目选择gradle管理项目![](基于酷q平台的管理机器人/idea新建项目.png)java版本任意，需要kotlin开发勾选kotlin\n\n2. 导包\n\n   ![](基于酷q平台的管理机器人/导包.png)\n\n   导入最新的sdk。\n\n3. 根据需要复制示例代码更改\n\n   ```java\n   public class TestBot\n   {\n       public static void main(String[] args)\n       {\n           // 创建机器人对象 ( 传入配置 )\n           PicqBotX bot = new PicqBotX(new PicqConfig(31092).setDebug(true));\n   \n           // 添加一个机器人账户 ( 名字, 发送URL, 发送端口 )\n           bot.addAccount(\"Bot01\", \"127.0.0.1\", 31091);\n   \n           // 注册事件监听器, 可以注册多个监听器\n           bot.getEventManager().registerListeners(\n                   new TestListener(), \n                   new RequestListener(),\n                   new ExceptionListener()\n           );\n   \n           // 启用指令管理器\n           // 这些字符串是指令前缀, 比如指令\"!help\"的前缀就是\"!\"\n           bot.enableCommandManager(\"bot -\", \"!\", \"/\", \"~\");\n   \n           // 注册指令, 可以注册多个指令\n           bot.getCommandManager().registerCommands(\n                   new CommandSay(),\n                   new CommandTest(),\n                   new CommandVersion()\n           );\n   \n           // 启动机器人, 不会占用主线程\n           bot.startBot();\n       }\n   }\n   ```\n\n\n\n### 个人实现效果和功能\n\n- 通知功能\n\n  <img src=\"基于酷q平台的管理机器人/通知.jpg\" style=\"zoom:50%;\" />\n\n- 请假功能\n\n  有学生请假则会以json格式文本保存在服务器（或者本地）\n\n  <img src=\"基于酷q平台的管理机器人/请假.jpg\" style=\"zoom: 33%;\" />\n\n- 导出请假表格文档，会直接给下载链接\n\n  <img src=\"基于酷q平台的管理机器人/请假文档.jpg\" style=\"zoom: 50%;\" />\n\n- 补登请假\n\n  <img src=\"基于酷q平台的管理机器人/补登请假.jpg\" style=\"zoom: 50%;\" />\n\n- 还有安卓端的管理app和网页版实时查看数据。\n\n\n\n### 部署机器人\n\n**在winows server上部署**\n\n太简单了，省略具体步骤，总结解释就是以下步骤：\n\n* 电脑上安装上所有酷q，http插件，java所需要的环境，跟你的本地一样（本地会配置，我想server上配置也难不倒聪明的你）\n* 打包你的机器人，可以是jar可以是其他的，只要是能够将你的代码打包运行就好\n* 运行酷q，打开http插件，运行你的机器人。\n\n**在linux上部署**\n\n因为酷q是window程序，要想在linux上部署那就必须得使用docker（不知道docker是什么的请百度），由于不是专业运维方向对docker不是很了解，也踩了很多坑。\n\n这里附上http插件的[官方教程](https://cqhttp.cc/docs)，里面有详细的描述如何安装最新的酷q的docker镜像，如果docker还没安装自行百度安装你的服务器的docker。\n\n然后基本上和以上步骤都是差不多，但是有个地方需要注意\n\n![image-20191113001251371](%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20191113001251371.png)\n\n这里的上报地址，理所当然就是酷q接收到消息之后传递给你的程序去处理，但是在docker中利用127.0.0.1是访问的docker内部，而你的机器人程序并不是在docker内所以，酷q是无法将消息上报给你的机器人的，有以下解决方案：\n\n* 对于mac和windows可以使用host.docker.internal替换127.0.0.1\n\n* 对于Linux可以创建一个桥接网络(我在网络上查找的，自己在centos上没有尝试成功)\n  下面的localNet是网络名字,可自行修改;关于192.168.0.0这个子网,也可以自行定义.\n  默认按照下面的命令,执行后将可以通过192.168.0.1访问宿主机\n\n  `docker network create -d bridge --subnet 192.168.0.0/24 --gateway 192.168.0.1 localNet`\n\n* 若你是在你的服务器上部署的你的机器人，可以直接使用服务器的公网ip\n\n只有这样酷q才能将消息上报到你的机器人处理,否则你的机器人只能发送消息，不能接收消息并作出反应。\n\n### 用到的库\n\n*********************************\n\n* 阿帕奇的表格框架\n* gson\n\n通知管理机器人源代码地址：[冷漠无情的机器人]()\n\n因为源代码中有不少私人数据，所以取消。\n\n","slug":"基于酷q平台的管理机器人","published":1,"updated":"2019-12-30T03:16:47.531Z","comments":1,"layout":"post","photos":[],"link":"2019/10/01/基于酷q平台的管理机器人","_id":"ck8jl8qix0018w0w0fj8v8299","content":"<h2 id=\"酷q机器人\">酷Q机器人<a href=\"#酷q机器人\" title=\"酷Q机器人\"></a></h2><hr>\n<p><strong>自从samrtQQ下线之后，很多QQ机器人都失效了。</strong></p>\n<p><strong>但是最近又比较想用这样一个机器人来管理减轻自己的一些工作，于是千方百计的我发现了酷Q。</strong></p>\n<p><strong>这里附上<a href=\"https://cqp.cc/\" target=\"_blank\">官网链接</a></strong></p>\n<h3 id=\"开发以及注意事项\">开发以及注意事项<a href=\"#开发以及注意事项\" title=\"开发以及注意事项\"></a></h3><ol><li><h5 id=\"sdk的选择\">SDK的选择<a href=\"#sdk的选择\" title=\"SDK的选择\"></a></h5><p>酷q提供了多种<a href=\"https://cqp.cc/t/15124\" target=\"_blank\">SDK</a>但是都是我不常用的，官方的支持的SDK是E语言，这语言emmmm好，都好，写，都可以写。虽然提供了java的sdk但是java版本始终不是正统，咬牙学了一天E语言，最后还是吐了。没办法，不习惯，没说E语言不好。害，最后还是选择的java版本。不过但是还没开始使用的时候我看到了更加好用的一个找到一个更加好用方便的SDK-<a href=\"https://github.com/HyDevelop/PicqBotX\" target=\"_blank\">PicqBotX</a>，这是通过http的插件来与酷q的程序交互。虽然不能像官方网站上提供的那个那样可以直接打包成jar运行但是个人认为开发更加简单。</p></li><li><p><strong>环境以及配置细节</strong></p><p><a href=\"https://github.com/HyDevelop/PicqBotX\" target=\"_blank\">这里讲得很清楚，以下说明几个坑</a>：</p><ul><li><p>如果使用kotlin代替java进行开发，请最好使用Gradle对项目进行管理，它对kotlin有更加完美的支持。</p></li><li><p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/酷q配置坏境的注意事项.jpg\"></p><p>在介绍readme中的这个位置一定要看准，下载对应版本的工具，否则可能出问题，比较麻烦，而且没有提示难以排查。</p></li><li><p>两个端口号一定要对应于你程序中的机器人的端口号否则会链接失败（建议直接用默认的31091 31092，也可自己选择）</p></li></ul></li></ol><h3 id=\"本人开发流程\">本人开发流程<a href=\"#本人开发流程\" title=\"本人开发流程\"></a></h3><ol><li><p>使用idea新建项目选择gradle管理项目<img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/idea新建项目.png\">java版本任意，需要kotlin开发勾选kotlin</p></li><li><p>导包</p></li></ol><p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/导包.png\" class=\"φcy\"></p>\n<p>   导入最新的sdk。</p>\n<ol><li><p>根据需要复制示例代码更改</p></li></ol><h3 id=\"个人实现效果和功能\">个人实现效果和功能<a href=\"#个人实现效果和功能\" title=\"个人实现效果和功能\"></a></h3><ul><li><p>通知功能</p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/通知.jpg\" style=\"zoom:50%\"></li><li><p>请假功能</p><p>有学生请假则会以json格式文本保存在服务器（或者本地）</p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/请假.jpg\" style=\"zoom:33%\"></li><li><p>导出请假表格文档，会直接给下载链接</p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/请假文档.jpg\" style=\"zoom:50%\"></li><li><p>补登请假</p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/补登请假.jpg\" style=\"zoom:50%\"></li><li><p>还有安卓端的管理app和网页版实时查看数据。</p></li></ul><h3 id=\"部署机器人\">部署机器人<a href=\"#部署机器人\" title=\"部署机器人\"></a></h3><p><strong>在winows server上部署</strong></p>\n<p>太简单了，省略具体步骤，总结解释就是以下步骤：</p>\n<ul><li>电脑上安装上所有酷q，http插件，java所需要的环境，跟你的本地一样（本地会配置，我想server上配置也难不倒聪明的你）</li><li>打包你的机器人，可以是jar可以是其他的，只要是能够将你的代码打包运行就好</li><li>运行酷q，打开http插件，运行你的机器人。</li></ul><p><strong>在linux上部署</strong></p>\n<p>因为酷q是window程序，要想在linux上部署那就必须得使用docker（不知道docker是什么的请百度），由于不是专业运维方向对docker不是很了解，也踩了很多坑。</p>\n<p>这里附上http插件的<a href=\"https://cqhttp.cc/docs\" target=\"_blank\">官方教程</a>，里面有详细的描述如何安装最新的酷q的docker镜像，如果docker还没安装自行百度安装你的服务器的docker。</p>\n<p>然后基本上和以上步骤都是差不多，但是有个地方需要注意</p>\n<p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20191113001251371.png\" class=\"φcy\" alt=\"image-20191113001251371\"></p>\n<p>这里的上报地址，理所当然就是酷q接收到消息之后传递给你的程序去处理，但是在docker中利用127.0.0.1是访问的docker内部，而你的机器人程序并不是在docker内所以，酷q是无法将消息上报给你的机器人的，有以下解决方案：</p>\n<ul><li><p>对于mac和windows可以使用host.docker.internal替换127.0.0.1</p></li><li><p>对于Linux可以创建一个桥接网络(我在网络上查找的，自己在centos上没有尝试成功)<br>下面的localNet是网络名字,可自行修改;关于192.168.0.0这个子网,也可以自行定义.<br>默认按照下面的命令,执行后将可以通过192.168.0.1访问宿主机</p><p><code>docker network create -d bridge --subnet 192.168.0.0/24 --gateway 192.168.0.1 localNet</code></p></li><li><p>若你是在你的服务器上部署的你的机器人，可以直接使用服务器的公网ip</p></li></ul><p>只有这样酷q才能将消息上报到你的机器人处理,否则你的机器人只能发送消息，不能接收消息并作出反应。</p>\n<h3 id=\"用到的库\">用到的库<a href=\"#用到的库\" title=\"用到的库\"></a></h3><hr>\n<ul><li>阿帕奇的表格框架</li><li>gson</li></ul><p>通知管理机器人源代码地址：<a>冷漠无情的机器人</a></p>\n<p>因为源代码中有不少私人数据，所以取消。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"酷q机器人\">酷Q机器人<a href=\"#酷q机器人\" title=\"酷Q机器人\"></a></h2><hr>\n<p><strong>自从samrtQQ下线之后，很多QQ机器人都失效了。</strong></p>\n<p><strong>但是最近又比较想用这样一个机器人来管理减轻自己的一些工作，于是千方百计的我发现了酷Q。</strong></p>\n<p><strong>这里附上<a href=\"https://cqp.cc/\" target=\"_blank\">官网链接</a></strong></p>\n<h3 id=\"开发以及注意事项\">开发以及注意事项<a href=\"#开发以及注意事项\" title=\"开发以及注意事项\"></a></h3><ol><li><h5 id=\"sdk的选择\">SDK的选择<a href=\"#sdk的选择\" title=\"SDK的选择\"></a></h5><p>酷q提供了多种<a href=\"https://cqp.cc/t/15124\" target=\"_blank\">SDK</a>但是都是我不常用的，官方的支持的SDK是E语言，这语言emmmm好，都好，写，都可以写。虽然提供了java的sdk但是java版本始终不是正统，咬牙学了一天E语言，最后还是吐了。没办法，不习惯，没说E语言不好。害，最后还是选择的java版本。不过但是还没开始使用的时候我看到了更加好用的一个找到一个更加好用方便的SDK-<a href=\"https://github.com/HyDevelop/PicqBotX\" target=\"_blank\">PicqBotX</a>，这是通过http的插件来与酷q的程序交互。虽然不能像官方网站上提供的那个那样可以直接打包成jar运行但是个人认为开发更加简单。</p></li><li><p><strong>环境以及配置细节</strong></p><p><a href=\"https://github.com/HyDevelop/PicqBotX\" target=\"_blank\">这里讲得很清楚，以下说明几个坑</a>：</p><ul><li><p>如果使用kotlin代替java进行开发，请最好使用Gradle对项目进行管理，它对kotlin有更加完美的支持。</p></li><li><p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/酷q配置坏境的注意事项.jpg\"></p><p>在介绍readme中的这个位置一定要看准，下载对应版本的工具，否则可能出问题，比较麻烦，而且没有提示难以排查。</p></li><li><p>两个端口号一定要对应于你程序中的机器人的端口号否则会链接失败（建议直接用默认的31091 31092，也可自己选择）</p></li></ul></li></ol><h3 id=\"本人开发流程\">本人开发流程<a href=\"#本人开发流程\" title=\"本人开发流程\"></a></h3><ol><li><p>使用idea新建项目选择gradle管理项目<img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/idea新建项目.png\">java版本任意，需要kotlin开发勾选kotlin</p></li><li><p>导包</p></li></ol><p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/导包.png\" class=\"φcy\"></p>\n<p>   导入最新的sdk。</p>\n<ol><li><p>根据需要复制示例代码更改</p></li></ol><h3 id=\"个人实现效果和功能\">个人实现效果和功能<a href=\"#个人实现效果和功能\" title=\"个人实现效果和功能\"></a></h3><ul><li><p>通知功能</p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/通知.jpg\" style=\"zoom:50%\"></li><li><p>请假功能</p><p>有学生请假则会以json格式文本保存在服务器（或者本地）</p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/请假.jpg\" style=\"zoom:33%\"></li><li><p>导出请假表格文档，会直接给下载链接</p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/请假文档.jpg\" style=\"zoom:50%\"></li><li><p>补登请假</p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/补登请假.jpg\" style=\"zoom:50%\"></li><li><p>还有安卓端的管理app和网页版实时查看数据。</p></li></ul><h3 id=\"部署机器人\">部署机器人<a href=\"#部署机器人\" title=\"部署机器人\"></a></h3><p><strong>在winows server上部署</strong></p>\n<p>太简单了，省略具体步骤，总结解释就是以下步骤：</p>\n<ul><li>电脑上安装上所有酷q，http插件，java所需要的环境，跟你的本地一样（本地会配置，我想server上配置也难不倒聪明的你）</li><li>打包你的机器人，可以是jar可以是其他的，只要是能够将你的代码打包运行就好</li><li>运行酷q，打开http插件，运行你的机器人。</li></ul><p><strong>在linux上部署</strong></p>\n<p>因为酷q是window程序，要想在linux上部署那就必须得使用docker（不知道docker是什么的请百度），由于不是专业运维方向对docker不是很了解，也踩了很多坑。</p>\n<p>这里附上http插件的<a href=\"https://cqhttp.cc/docs\" target=\"_blank\">官方教程</a>，里面有详细的描述如何安装最新的酷q的docker镜像，如果docker还没安装自行百度安装你的服务器的docker。</p>\n<p>然后基本上和以上步骤都是差不多，但是有个地方需要注意</p>\n<p><img src=\"/2019/10/01/%E5%9F%BA%E4%BA%8E%E9%85%B7q%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%BA%E5%99%A8%E4%BA%BA/image-20191113001251371.png\" class=\"φcy\" alt=\"image-20191113001251371\"></p>\n<p>这里的上报地址，理所当然就是酷q接收到消息之后传递给你的程序去处理，但是在docker中利用127.0.0.1是访问的docker内部，而你的机器人程序并不是在docker内所以，酷q是无法将消息上报给你的机器人的，有以下解决方案：</p>\n<ul><li><p>对于mac和windows可以使用host.docker.internal替换127.0.0.1</p></li><li><p>对于Linux可以创建一个桥接网络(我在网络上查找的，自己在centos上没有尝试成功)<br>下面的localNet是网络名字,可自行修改;关于192.168.0.0这个子网,也可以自行定义.<br>默认按照下面的命令,执行后将可以通过192.168.0.1访问宿主机</p><p><code>docker network create -d bridge --subnet 192.168.0.0/24 --gateway 192.168.0.1 localNet</code></p></li><li><p>若你是在你的服务器上部署的你的机器人，可以直接使用服务器的公网ip</p></li></ul><p>只有这样酷q才能将消息上报到你的机器人处理,否则你的机器人只能发送消息，不能接收消息并作出反应。</p>\n<h3 id=\"用到的库\">用到的库<a href=\"#用到的库\" title=\"用到的库\"></a></h3><hr>\n<ul><li>阿帕奇的表格框架</li><li>gson</li></ul><p>通知管理机器人源代码地址：<a>冷漠无情的机器人</a></p>\n<p>因为源代码中有不少私人数据，所以取消。</p>\n","date_formatted":{"ll":"Oct 1, 2019","L":"10/01/2019","MM-DD":"10-01"},"plink":"https://treeeeeeee.github.io/2019/10/01/基于酷q平台的管理机器人/","type":"post","toc":[{"id":"酷q机器人","title":"酷Q机器人","index":"1","children":[{"id":"开发以及注意事项","title":"开发以及注意事项","index":"1.1"},{"id":"本人开发流程","title":"本人开发流程","index":"1.2"},{"id":"个人实现效果和功能","title":"个人实现效果和功能","index":"1.3"},{"id":"部署机器人","title":"部署机器人","index":"1.4"},{"id":"用到的库","title":"用到的库","index":"1.5"}]}]},{"title":"kotlin的let、with、run、apply、also系列方法记录","date":"2020-03-26T17:51:47.000Z","_content":"\n## let\n\n#### 使用场景\n\n- **场景一:** 最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理。\n- **场景二:** 然后就是需要去明确一个变量所处特定的作用域范围内可以使用\n\n#### 提醒\n\n在函数块内可以通过 it 指代该对象。返回值为函数块的最后一行或指定return表达式\n\n#### 示例\n\n```kotlin\nAny().let { it: Any ->\n\n}\n```\n\n## with\n\n#### 提醒\n\n在函数块内可以通过 this 指代该对象。返回值为函数块的最后一行或指定return表达式\n\n#### 示例\n\n```kotlin\nwith(Any()){\n    \n}\n```\n\n## run\n\n#### 解释\n\n**let和with的结合**，函数块内，可以通过this代指该对象，返回值为函数块的最后一行或指定return表达式\n\n#### 示例\n\n```kotlin\nAny().run { \n    \n}\n```\n\n## apply\n\n**与run类似，唯一的不同是apply始终返回该对象**\n\n#### 示例\n\n```kotlin\nAny().apply {\n\n}\n```\n\n## also\n\n**结合apply和let**\n\n**函数始终返回该对象，函数类可以通过it访该对象**\n\n#### 示例\n\n```kotlin\nAny().also { it: Any ->\n\n}\n```","source":"_posts/kotlin的let、with、run、apply、also系列方法记录.md","raw":"---\ntitle: kotlin的let、with、run、apply、also系列方法记录\ndate: 2020-03-27 01:51:47\ntags:\n- 记录\ncategories:\n- Kotlin\n---\n\n## let\n\n#### 使用场景\n\n- **场景一:** 最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理。\n- **场景二:** 然后就是需要去明确一个变量所处特定的作用域范围内可以使用\n\n#### 提醒\n\n在函数块内可以通过 it 指代该对象。返回值为函数块的最后一行或指定return表达式\n\n#### 示例\n\n```kotlin\nAny().let { it: Any ->\n\n}\n```\n\n## with\n\n#### 提醒\n\n在函数块内可以通过 this 指代该对象。返回值为函数块的最后一行或指定return表达式\n\n#### 示例\n\n```kotlin\nwith(Any()){\n    \n}\n```\n\n## run\n\n#### 解释\n\n**let和with的结合**，函数块内，可以通过this代指该对象，返回值为函数块的最后一行或指定return表达式\n\n#### 示例\n\n```kotlin\nAny().run { \n    \n}\n```\n\n## apply\n\n**与run类似，唯一的不同是apply始终返回该对象**\n\n#### 示例\n\n```kotlin\nAny().apply {\n\n}\n```\n\n## also\n\n**结合apply和let**\n\n**函数始终返回该对象，函数类可以通过it访该对象**\n\n#### 示例\n\n```kotlin\nAny().also { it: Any ->\n\n}\n```","slug":"kotlin的let、with、run、apply、also系列方法记录","published":1,"updated":"2020-03-26T18:26:13.034Z","comments":1,"layout":"post","photos":[],"link":"2020/03/27/kotlin的let、with、run、apply、also系列方法记录","_id":"ck8jl8qiy001aw0w003qdfrmf","content":"<h2 id=\"let\">let<a href=\"#let\" title=\"let\"></a></h2><h4 id=\"使用场景\">使用场景<a href=\"#使用场景\" title=\"使用场景\"></a></h4><ul><li><strong>场景一:</strong> 最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理。</li><li><strong>场景二:</strong> 然后就是需要去明确一个变量所处特定的作用域范围内可以使用</li></ul><h4 id=\"提醒\">提醒<a href=\"#提醒\" title=\"提醒\"></a></h4><p>在函数块内可以通过 it 指代该对象。返回值为函数块的最后一行或指定return表达式</p>\n<h4 id=\"示例\">示例<a href=\"#示例\" title=\"示例\"></a></h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any().let &#123; it: Any -&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"with\">with<a href=\"#with\" title=\"with\"></a></h2><h4 id=\"提醒-1\">提醒<a href=\"#提醒-1\" title=\"提醒\"></a></h4><p>在函数块内可以通过 this 指代该对象。返回值为函数块的最后一行或指定return表达式</p>\n<h4 id=\"示例-1\">示例<a href=\"#示例-1\" title=\"示例\"></a></h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with(Any())&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"run\">run<a href=\"#run\" title=\"run\"></a></h2><h4 id=\"解释\">解释<a href=\"#解释\" title=\"解释\"></a></h4><p><strong>let和with的结合</strong>，函数块内，可以通过this代指该对象，返回值为函数块的最后一行或指定return表达式</p>\n<h4 id=\"示例-2\">示例<a href=\"#示例-2\" title=\"示例\"></a></h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any().run &#123; </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"apply\">apply<a href=\"#apply\" title=\"apply\"></a></h2><p><strong>与run类似，唯一的不同是apply始终返回该对象</strong></p>\n<h4 id=\"示例-3\">示例<a href=\"#示例-3\" title=\"示例\"></a></h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any().apply &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"also\">also<a href=\"#also\" title=\"also\"></a></h2><p><strong>结合apply和let</strong></p>\n<p><strong>函数始终返回该对象，函数类可以通过it访该对象</strong></p>\n<h4 id=\"示例-4\">示例<a href=\"#示例-4\" title=\"示例\"></a></h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any().also &#123; it: Any -&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"let\">let<a href=\"#let\" title=\"let\"></a></h2><h4 id=\"使用场景\">使用场景<a href=\"#使用场景\" title=\"使用场景\"></a></h4><ul><li><strong>场景一:</strong> 最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理。</li><li><strong>场景二:</strong> 然后就是需要去明确一个变量所处特定的作用域范围内可以使用</li></ul><h4 id=\"提醒\">提醒<a href=\"#提醒\" title=\"提醒\"></a></h4><p>在函数块内可以通过 it 指代该对象。返回值为函数块的最后一行或指定return表达式</p>\n<h4 id=\"示例\">示例<a href=\"#示例\" title=\"示例\"></a></h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any().let &#123; it: Any -&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"with\">with<a href=\"#with\" title=\"with\"></a></h2><h4 id=\"提醒-1\">提醒<a href=\"#提醒-1\" title=\"提醒\"></a></h4><p>在函数块内可以通过 this 指代该对象。返回值为函数块的最后一行或指定return表达式</p>\n<h4 id=\"示例-1\">示例<a href=\"#示例-1\" title=\"示例\"></a></h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with(Any())&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"run\">run<a href=\"#run\" title=\"run\"></a></h2><h4 id=\"解释\">解释<a href=\"#解释\" title=\"解释\"></a></h4><p><strong>let和with的结合</strong>，函数块内，可以通过this代指该对象，返回值为函数块的最后一行或指定return表达式</p>\n<h4 id=\"示例-2\">示例<a href=\"#示例-2\" title=\"示例\"></a></h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any().run &#123; </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"apply\">apply<a href=\"#apply\" title=\"apply\"></a></h2><p><strong>与run类似，唯一的不同是apply始终返回该对象</strong></p>\n<h4 id=\"示例-3\">示例<a href=\"#示例-3\" title=\"示例\"></a></h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any().apply &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"also\">also<a href=\"#also\" title=\"also\"></a></h2><p><strong>结合apply和let</strong></p>\n<p><strong>函数始终返回该对象，函数类可以通过it访该对象</strong></p>\n<h4 id=\"示例-4\">示例<a href=\"#示例-4\" title=\"示例\"></a></h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any().also &#123; it: Any -&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","date_formatted":{"ll":"Mar 27, 2020","L":"03/27/2020","MM-DD":"03-27"},"plink":"https://treeeeeeee.github.io/2020/03/27/kotlin的let、with、run、apply、also系列方法记录/","type":"post","toc":[{"id":"let","title":"let","index":"1"},{"id":"with","title":"with","index":"2"},{"id":"run","title":"run","index":"3"},{"id":"apply","title":"apply","index":"4"},{"id":"also","title":"also","index":"5"}]},{"title":"深入理解volatile和并发编程的三大特性","date":"2020-03-11T09:42:24.000Z","thumbnail":"2020/03/11/深入理解volatile和并发编程的三大特性/../深入理解volatile和并发编程的三大特性/images.webp","_content":"\n#  一切之前\n\n**早期**计算机中**CPU**和**内存**的速度是差不多的，但在**现代计算机**中，**CPU的指令速度远超内存的存取速度**,由于**计算机的存储设备**与**处理器的运算速度**有**几个数量级的差距**，所以现代计算机系统都**不得不加入一层**读写速度尽可能接近处理器运算速度的**高速缓存（Cache**）来作为**内存与处理器**之间的**缓冲**：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再**从缓存同步回内存之中**，这样处理器就无须等待缓慢的内存读写了。\n\n## JMM抽象结构模型\n\n**JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式**。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。\n\n从抽象的角度来看，**JMM定义了线程和主内存之间的抽象关系**：线程之间的**共享变量存储在主内存**（Main Memory）中，**每个线程都有一个私有的本地内存**（Local Memory），**本地内存中存储了该线程以读/写共享变量的副本。**\n\n本地内存是JMM的一个**抽象概念**，**并不真实存在**。它涵盖了**缓存、写缓冲区、寄存器以及其他的硬件和编译器优化**。\n\n下面这个图很好的说明了**JMM**的工作方式\n\n![img](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/2615789-8c0b960a27af28db.webp)\n\n那么高速缓存弥补了CPU和内存之间的发展差异，带来了好处，自然就会带来一些问题。\n\n# 可见性\n\n多个线程同时对共享变量进行操作，但是实际的运算是与本地内存和CPU交互，运算结果是线程之间不可见的，只有操作之后将本地内存副本刷新到主存，其他线程再去读取才是最新的值，如果操作完成，还没来得及刷新到主内存，其他线程就会拿到旧值，这样就会对结果造成影响。\n\n在Java中我们就可以使用**volatile关键字**或者是**加锁**来保证可见性\n\n被volatile修饰的变量一旦被更改就会立即把结果刷新到主内存，保证了变量的可见性。\n\n# 原子性\n\n原子性是指**一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉**。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。\n\n# 有序性\n\n## 重排序\n\n根据Java内存模型中的规定，可以总结出以下几条happens-before规则8。Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。\n\n- 程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。\n- 监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。\n- volatile变量法则：**对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。**\n- 线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。\n- 线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。\n- 中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。\n- 终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。\n- 传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C\n\n\n\n# volatile\n\n* volatile可以保证可见性，数据一旦修改可以及时更新到主存，可以杜绝更改之后没来得及刷新到主存而其他线程读取旧值而造成的异步问题\n* volatile可以一定程度上保证有序性\n  1. 所有在 volatile 修饰的变量写操作之前的写操作，将会对随后该 volatile 修饰的变量读操作之后的语句可见。\n  2. 禁止 JVM 重排序：volatile 修饰的变量的读写指令不能和其前后的任何指令重排序，其前后的指令可能会被重排序。\n\n","source":"_posts/深入理解volatile和并发编程的三大特性.md","raw":"---\ntitle: 深入理解volatile和并发编程的三大特性\ndate: 2020-03-11 17:42:24\ntags:\n- java并发\ncategories:\n- Java\nthumbnail: ../深入理解volatile和并发编程的三大特性/images.webp\n---\n\n#  一切之前\n\n**早期**计算机中**CPU**和**内存**的速度是差不多的，但在**现代计算机**中，**CPU的指令速度远超内存的存取速度**,由于**计算机的存储设备**与**处理器的运算速度**有**几个数量级的差距**，所以现代计算机系统都**不得不加入一层**读写速度尽可能接近处理器运算速度的**高速缓存（Cache**）来作为**内存与处理器**之间的**缓冲**：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再**从缓存同步回内存之中**，这样处理器就无须等待缓慢的内存读写了。\n\n## JMM抽象结构模型\n\n**JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式**。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。\n\n从抽象的角度来看，**JMM定义了线程和主内存之间的抽象关系**：线程之间的**共享变量存储在主内存**（Main Memory）中，**每个线程都有一个私有的本地内存**（Local Memory），**本地内存中存储了该线程以读/写共享变量的副本。**\n\n本地内存是JMM的一个**抽象概念**，**并不真实存在**。它涵盖了**缓存、写缓冲区、寄存器以及其他的硬件和编译器优化**。\n\n下面这个图很好的说明了**JMM**的工作方式\n\n![img](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/2615789-8c0b960a27af28db.webp)\n\n那么高速缓存弥补了CPU和内存之间的发展差异，带来了好处，自然就会带来一些问题。\n\n# 可见性\n\n多个线程同时对共享变量进行操作，但是实际的运算是与本地内存和CPU交互，运算结果是线程之间不可见的，只有操作之后将本地内存副本刷新到主存，其他线程再去读取才是最新的值，如果操作完成，还没来得及刷新到主内存，其他线程就会拿到旧值，这样就会对结果造成影响。\n\n在Java中我们就可以使用**volatile关键字**或者是**加锁**来保证可见性\n\n被volatile修饰的变量一旦被更改就会立即把结果刷新到主内存，保证了变量的可见性。\n\n# 原子性\n\n原子性是指**一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉**。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。\n\n# 有序性\n\n## 重排序\n\n根据Java内存模型中的规定，可以总结出以下几条happens-before规则8。Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。\n\n- 程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。\n- 监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。\n- volatile变量法则：**对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。**\n- 线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。\n- 线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。\n- 中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。\n- 终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。\n- 传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C\n\n\n\n# volatile\n\n* volatile可以保证可见性，数据一旦修改可以及时更新到主存，可以杜绝更改之后没来得及刷新到主存而其他线程读取旧值而造成的异步问题\n* volatile可以一定程度上保证有序性\n  1. 所有在 volatile 修饰的变量写操作之前的写操作，将会对随后该 volatile 修饰的变量读操作之后的语句可见。\n  2. 禁止 JVM 重排序：volatile 修饰的变量的读写指令不能和其前后的任何指令重排序，其前后的指令可能会被重排序。\n\n","slug":"深入理解volatile和并发编程的三大特性","published":1,"updated":"2020-04-02T19:31:06.984Z","_id":"ck8jl8qj2001ew0w0drev2ga0","comments":1,"layout":"post","photos":[],"link":"2020/03/11/深入理解volatile和并发编程的三大特性","content":"<h1 id=\"一切之前\">一切之前<a href=\"#一切之前\" title=\"一切之前\"></a></h1><p><strong>早期</strong>计算机中<strong>CPU</strong>和<strong>内存</strong>的速度是差不多的，但在<strong>现代计算机</strong>中，<strong>CPU的指令速度远超内存的存取速度</strong>,由于<strong>计算机的存储设备</strong>与<strong>处理器的运算速度</strong>有<strong>几个数量级的差距</strong>，所以现代计算机系统都<strong>不得不加入一层</strong>读写速度尽可能接近处理器运算速度的<strong>高速缓存（Cache</strong>）来作为<strong>内存与处理器</strong>之间的<strong>缓冲</strong>：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再<strong>从缓存同步回内存之中</strong>，这样处理器就无须等待缓慢的内存读写了。</p>\n<h2 id=\"jmm抽象结构模型\">JMM抽象结构模型<a href=\"#jmm抽象结构模型\" title=\"JMM抽象结构模型\"></a></h2><p><strong>JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式</strong>。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。</p>\n<p>从抽象的角度来看，<strong>JMM定义了线程和主内存之间的抽象关系</strong>：线程之间的<strong>共享变量存储在主内存</strong>（Main Memory）中，<strong>每个线程都有一个私有的本地内存</strong>（Local Memory），<strong>本地内存中存储了该线程以读/写共享变量的副本。</strong></p>\n<p>本地内存是JMM的一个<strong>抽象概念</strong>，<strong>并不真实存在</strong>。它涵盖了<strong>缓存、写缓冲区、寄存器以及其他的硬件和编译器优化</strong>。</p>\n<p>下面这个图很好的说明了<strong>JMM</strong>的工作方式</p>\n<p><img src=\"/2020/03/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/2615789-8c0b960a27af28db.webp\" class=\"φcy\" alt=\"img\"></p>\n<p>那么高速缓存弥补了CPU和内存之间的发展差异，带来了好处，自然就会带来一些问题。</p>\n<h1 id=\"可见性\">可见性<a href=\"#可见性\" title=\"可见性\"></a></h1><p>多个线程同时对共享变量进行操作，但是实际的运算是与本地内存和CPU交互，运算结果是线程之间不可见的，只有操作之后将本地内存副本刷新到主存，其他线程再去读取才是最新的值，如果操作完成，还没来得及刷新到主内存，其他线程就会拿到旧值，这样就会对结果造成影响。</p>\n<p>在Java中我们就可以使用<strong>volatile关键字</strong>或者是<strong>加锁</strong>来保证可见性</p>\n<p>被volatile修饰的变量一旦被更改就会立即把结果刷新到主内存，保证了变量的可见性。</p>\n<h1 id=\"原子性\">原子性<a href=\"#原子性\" title=\"原子性\"></a></h1><p>原子性是指<strong>一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉</strong>。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。</p>\n<h1 id=\"有序性\">有序性<a href=\"#有序性\" title=\"有序性\"></a></h1><h2 id=\"重排序\">重排序<a href=\"#重排序\" title=\"重排序\"></a></h2><p>根据Java内存模型中的规定，可以总结出以下几条happens-before规则8。Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。</p>\n<ul><li>程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。</li><li>监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。</li><li>volatile变量法则：<strong>对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</strong></li><li>线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。</li><li>线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。</li><li>中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。</li><li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li><li>传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C</li></ul><h1 id=\"volatile\">volatile<a href=\"#volatile\" title=\"volatile\"></a></h1><ul><li>volatile可以保证可见性，数据一旦修改可以及时更新到主存，可以杜绝更改之后没来得及刷新到主存而其他线程读取旧值而造成的异步问题</li><li>volatile可以一定程度上保证有序性<ol><li>所有在 volatile 修饰的变量写操作之前的写操作，将会对随后该 volatile 修饰的变量读操作之后的语句可见。</li><li>禁止 JVM 重排序：volatile 修饰的变量的读写指令不能和其前后的任何指令重排序，其前后的指令可能会被重排序。</li></ol></li></ul>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一切之前\">一切之前<a href=\"#一切之前\" title=\"一切之前\"></a></h1><p><strong>早期</strong>计算机中<strong>CPU</strong>和<strong>内存</strong>的速度是差不多的，但在<strong>现代计算机</strong>中，<strong>CPU的指令速度远超内存的存取速度</strong>,由于<strong>计算机的存储设备</strong>与<strong>处理器的运算速度</strong>有<strong>几个数量级的差距</strong>，所以现代计算机系统都<strong>不得不加入一层</strong>读写速度尽可能接近处理器运算速度的<strong>高速缓存（Cache</strong>）来作为<strong>内存与处理器</strong>之间的<strong>缓冲</strong>：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再<strong>从缓存同步回内存之中</strong>，这样处理器就无须等待缓慢的内存读写了。</p>\n<h2 id=\"jmm抽象结构模型\">JMM抽象结构模型<a href=\"#jmm抽象结构模型\" title=\"JMM抽象结构模型\"></a></h2><p><strong>JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式</strong>。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。</p>\n<p>从抽象的角度来看，<strong>JMM定义了线程和主内存之间的抽象关系</strong>：线程之间的<strong>共享变量存储在主内存</strong>（Main Memory）中，<strong>每个线程都有一个私有的本地内存</strong>（Local Memory），<strong>本地内存中存储了该线程以读/写共享变量的副本。</strong></p>\n<p>本地内存是JMM的一个<strong>抽象概念</strong>，<strong>并不真实存在</strong>。它涵盖了<strong>缓存、写缓冲区、寄存器以及其他的硬件和编译器优化</strong>。</p>\n<p>下面这个图很好的说明了<strong>JMM</strong>的工作方式</p>\n<p><img src=\"/2020/03/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/2615789-8c0b960a27af28db.webp\" class=\"φcy\" alt=\"img\"></p>\n<p>那么高速缓存弥补了CPU和内存之间的发展差异，带来了好处，自然就会带来一些问题。</p>\n<h1 id=\"可见性\">可见性<a href=\"#可见性\" title=\"可见性\"></a></h1><p>多个线程同时对共享变量进行操作，但是实际的运算是与本地内存和CPU交互，运算结果是线程之间不可见的，只有操作之后将本地内存副本刷新到主存，其他线程再去读取才是最新的值，如果操作完成，还没来得及刷新到主内存，其他线程就会拿到旧值，这样就会对结果造成影响。</p>\n<p>在Java中我们就可以使用<strong>volatile关键字</strong>或者是<strong>加锁</strong>来保证可见性</p>\n<p>被volatile修饰的变量一旦被更改就会立即把结果刷新到主内存，保证了变量的可见性。</p>\n<h1 id=\"原子性\">原子性<a href=\"#原子性\" title=\"原子性\"></a></h1><p>原子性是指<strong>一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉</strong>。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。</p>\n<h1 id=\"有序性\">有序性<a href=\"#有序性\" title=\"有序性\"></a></h1><h2 id=\"重排序\">重排序<a href=\"#重排序\" title=\"重排序\"></a></h2><p>根据Java内存模型中的规定，可以总结出以下几条happens-before规则8。Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。</p>\n<ul><li>程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。</li><li>监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。</li><li>volatile变量法则：<strong>对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</strong></li><li>线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。</li><li>线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。</li><li>中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。</li><li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li><li>传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C</li></ul><h1 id=\"volatile\">volatile<a href=\"#volatile\" title=\"volatile\"></a></h1><ul><li>volatile可以保证可见性，数据一旦修改可以及时更新到主存，可以杜绝更改之后没来得及刷新到主存而其他线程读取旧值而造成的异步问题</li><li>volatile可以一定程度上保证有序性<ol><li>所有在 volatile 修饰的变量写操作之前的写操作，将会对随后该 volatile 修饰的变量读操作之后的语句可见。</li><li>禁止 JVM 重排序：volatile 修饰的变量的读写指令不能和其前后的任何指令重排序，其前后的指令可能会被重排序。</li></ol></li></ul>","date_formatted":{"ll":"Mar 11, 2020","L":"03/11/2020","MM-DD":"03-11"},"plink":"https://treeeeeeee.github.io/2020/03/11/深入理解volatile和并发编程的三大特性/","type":"post","toc":[{"id":"一切之前","title":"一切之前","index":"1","children":[{"id":"jmm抽象结构模型","title":"JMM抽象结构模型","index":"1.1"}]},{"id":"可见性","title":"可见性","index":"2"},{"id":"原子性","title":"原子性","index":"3"},{"id":"有序性","title":"有序性","index":"4","children":[{"id":"重排序","title":"重排序","index":"4.1"}]},{"id":"volatile","title":"volatile","index":"5"}]},{"title":"当Activity异常销毁FragmentManager做了什么","date":"2020-03-26T18:36:09.000Z","thumbnail":"2020/03/27/当Activity异常销毁FragmentManager做了什么/../当Activity异常销毁FragmentManager做了什么/image-20200327042035621.png","_content":"\n\n\n最近在做项目的时候因为`Activity`和`FragmentManager`，使项目遇到了一些问题，`Activity`异常销毁重启之后，上次加载进去的`Fragment`也依然存在`FragmentManager`当中，但是在`Activity`中的初始化函数仍然会生成新的`fragment`进去。以此导致了界面出现了重复加载的问题。\n\n下面的分析都是基于`Androidx`的源码，和`support`有些区别\n\n## 问题出现可能的原因\n\n* `FragmentManager`生命周期更长\n* 销毁之前恢复机制将这些`fragment`数据进行了保存，重新创建时恢复了\n\n#### `FragmentManager`生命周期更长？？？\n\n`Activity`异常销毁（或者配置更改）时`FragmentManager`会像`ViewModel`一样自动保存下来？以便于下次加载使用吗\n\n**证明一下**\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    companion object{\n        const val TAG = \"MainActivityDemo\"\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        Log.d(TAG, \"${supportFragmentManager}\")\n    }\n}\n```\n\n接下来我们开启分屏\n\n![image-20200327042035621](%E5%BD%93Activity%E5%BC%82%E5%B8%B8%E9%94%80%E6%AF%81FragmentManager%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/image-20200327042035621.png)\n\n很明显这里不是同一个对象，这个原因pass。\n\n#### 被恢复了？？\n\n<img src=\"当Activity异常销毁FragmentManager做了什么/v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg\" alt=\"v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924\" style=\"zoom:50%;\" />我们来看看`FragmentActivity`中`onSaveInstanceState`干了什么\n\n```java\nprotected void onSaveInstanceState(@NonNull Bundle outState) {\n    super.onSaveInstanceState(outState);\n    markFragmentsCreated();//标记已经创建的fragment\n    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);\n    Parcelable p = mFragments.saveAllState();//保存状态\n    if (p != null) {\n        outState.putParcelable(FRAGMENTS_TAG, p);//放到Bundle\n    }\n    // do something..................\n}\n```\n\n这里的确做了保存，那么我们看看在哪里用到了`FRAGMENTS_TAG`这个标志位\n\n```java\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    mFragments.attachHost(null /*parent*/);\n    if (savedInstanceState != null) {\n        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);//获取保存的数据\n        mFragments.restoreSaveState(p);//对数据进行了恢复\n        // do something............\n    }\n\n    // do something............\n    \n    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);\n    mFragments.dispatchCreate();\n}\n\n\n\n```\n\n具体保存操作是怎么操作的这个，自己去研究，不在本篇文章讨论范围\n\n涉及到`FragmentManager`对`fragment`的`onSaveInstanceState`和`onRestoreInstanceState`的层层调用\n\n我们来看看一个Fragment到底保存了一些什么东西（以下我只保留了关键函数）\n\n```java\nfinal class FragmentState implements Parcelable {\n    final String mClassName;\n    final String mWho;\n    final boolean mFromLayout;\n    final int mFragmentId;\n    final int mContainerId;\n    final String mTag;\n    final boolean mRetainInstance;\n    final boolean mRemoving;\n    final boolean mDetached;\n    final Bundle mArguments;\n    final boolean mHidden;\n    final int mMaxLifecycleState;\n\n    Bundle mSavedFragmentState;\n\n    Fragment mInstance;\n\n    //传入fragment对数据进行构造\n    FragmentState(Fragment frag) {\n        mClassName = frag.getClass().getName();//类名\n        mWho = frag.mWho;//这个fragment对象独有的id\n        mFromLayout = frag.mFromLayout;//是否是直接从布局实例化的（boolean）\n        mFragmentId = frag.mFragmentId;//若是动态添加的，则为容器id，从视图添加则为布局中的id\n        mContainerId = frag.mContainerId;//动态添加时，容器的id\n        mTag = frag.mTag;\n        //这个属性有些复杂，如果fragment设置这个属性那么\n        //这个fragment会被存到FragmentManagerViewModel里，\n        //这个viewModel的owner是FragmentManager依附的Activity\n        //由于ViewModel的特性，activity配置更改后viewModel会自动保存\n        //下一次FragmentManager恢复数据时会优先判断判断FragmentManagerViewModel\n        //里是否保存，如果保存了就不调用下面的instantiate创建新的Fragment对象\n        mRetainInstance = frag.mRetainInstance;\n        mRemoving = frag.mRemoving;//是否从activity中移除\n        mDetached = frag.mDetached;//是否被禁用，当被detach时会被设置为false\n        mArguments = frag.mArguments;//这个是个Bundle，用来传递东西的\n        mHidden = frag.mHidden;//当前Fragment是否时隐藏状态\n        mMaxLifecycleState = frag.mMaxState.ordinal();\n    }\n\n    //通过保存的信息恢复一个完整的Fragment\n    public Fragment instantiate(@NonNull ClassLoader classLoader,\n            @NonNull FragmentFactory factory) {\n        if (mInstance == null) {\n            if (mArguments != null) {\n                mArguments.setClassLoader(classLoader);\n            }\n\n            mInstance = factory.instantiate(classLoader, mClassName);\n            mInstance.setArguments(mArguments);\n\n            if (mSavedFragmentState != null) {\n                mSavedFragmentState.setClassLoader(classLoader);\n                mInstance.mSavedFragmentState = mSavedFragmentState;\n            } else {\n                // When restoring a Fragment, always ensure we have a\n                // non-null Bundle so that developers have a signal for\n                // when the Fragment is being restored\n                mInstance.mSavedFragmentState = new Bundle();\n            }\n            mInstance.mWho = mWho;\n            mInstance.mFromLayout = mFromLayout;\n            mInstance.mRestored = true;\n            mInstance.mFragmentId = mFragmentId;\n            mInstance.mContainerId = mContainerId;\n            mInstance.mTag = mTag;\n            mInstance.mRetainInstance = mRetainInstance;\n            mInstance.mRemoving = mRemoving;\n            mInstance.mDetached = mDetached;\n            mInstance.mHidden = mHidden;\n            mInstance.mMaxState = Lifecycle.State.values()[mMaxLifecycleState];\n\n            if (FragmentManagerImpl.DEBUG) {\n                Log.v(FragmentManagerImpl.TAG, \"Instantiated fragment \" + mInstance);\n            }\n        }\n        return mInstance;\n    }\n\n}\n```\n\n从上面的代码注释就可以看出，保存了哪些东西\n\n看来这个解答时正解，哦耶<img src=\"%E5%BD%93Activity%E5%BC%82%E5%B8%B8%E9%94%80%E6%AF%81FragmentManager%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg\" alt=\"img\" style=\"zoom:50%;\" />","source":"_posts/当Activity异常销毁FragmentManager做了什么.md","raw":"---\ntitle: 当Activity异常销毁FragmentManager做了什么\ndate: 2020-03-27 02:36:09\ntags:\n- 查漏补缺\ncategories:\n- Android\nthumbnail: ../当Activity异常销毁FragmentManager做了什么/image-20200327042035621.png\n---\n\n\n\n最近在做项目的时候因为`Activity`和`FragmentManager`，使项目遇到了一些问题，`Activity`异常销毁重启之后，上次加载进去的`Fragment`也依然存在`FragmentManager`当中，但是在`Activity`中的初始化函数仍然会生成新的`fragment`进去。以此导致了界面出现了重复加载的问题。\n\n下面的分析都是基于`Androidx`的源码，和`support`有些区别\n\n## 问题出现可能的原因\n\n* `FragmentManager`生命周期更长\n* 销毁之前恢复机制将这些`fragment`数据进行了保存，重新创建时恢复了\n\n#### `FragmentManager`生命周期更长？？？\n\n`Activity`异常销毁（或者配置更改）时`FragmentManager`会像`ViewModel`一样自动保存下来？以便于下次加载使用吗\n\n**证明一下**\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    companion object{\n        const val TAG = \"MainActivityDemo\"\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        Log.d(TAG, \"${supportFragmentManager}\")\n    }\n}\n```\n\n接下来我们开启分屏\n\n![image-20200327042035621](%E5%BD%93Activity%E5%BC%82%E5%B8%B8%E9%94%80%E6%AF%81FragmentManager%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/image-20200327042035621.png)\n\n很明显这里不是同一个对象，这个原因pass。\n\n#### 被恢复了？？\n\n<img src=\"当Activity异常销毁FragmentManager做了什么/v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg\" alt=\"v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924\" style=\"zoom:50%;\" />我们来看看`FragmentActivity`中`onSaveInstanceState`干了什么\n\n```java\nprotected void onSaveInstanceState(@NonNull Bundle outState) {\n    super.onSaveInstanceState(outState);\n    markFragmentsCreated();//标记已经创建的fragment\n    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);\n    Parcelable p = mFragments.saveAllState();//保存状态\n    if (p != null) {\n        outState.putParcelable(FRAGMENTS_TAG, p);//放到Bundle\n    }\n    // do something..................\n}\n```\n\n这里的确做了保存，那么我们看看在哪里用到了`FRAGMENTS_TAG`这个标志位\n\n```java\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    mFragments.attachHost(null /*parent*/);\n    if (savedInstanceState != null) {\n        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);//获取保存的数据\n        mFragments.restoreSaveState(p);//对数据进行了恢复\n        // do something............\n    }\n\n    // do something............\n    \n    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);\n    mFragments.dispatchCreate();\n}\n\n\n\n```\n\n具体保存操作是怎么操作的这个，自己去研究，不在本篇文章讨论范围\n\n涉及到`FragmentManager`对`fragment`的`onSaveInstanceState`和`onRestoreInstanceState`的层层调用\n\n我们来看看一个Fragment到底保存了一些什么东西（以下我只保留了关键函数）\n\n```java\nfinal class FragmentState implements Parcelable {\n    final String mClassName;\n    final String mWho;\n    final boolean mFromLayout;\n    final int mFragmentId;\n    final int mContainerId;\n    final String mTag;\n    final boolean mRetainInstance;\n    final boolean mRemoving;\n    final boolean mDetached;\n    final Bundle mArguments;\n    final boolean mHidden;\n    final int mMaxLifecycleState;\n\n    Bundle mSavedFragmentState;\n\n    Fragment mInstance;\n\n    //传入fragment对数据进行构造\n    FragmentState(Fragment frag) {\n        mClassName = frag.getClass().getName();//类名\n        mWho = frag.mWho;//这个fragment对象独有的id\n        mFromLayout = frag.mFromLayout;//是否是直接从布局实例化的（boolean）\n        mFragmentId = frag.mFragmentId;//若是动态添加的，则为容器id，从视图添加则为布局中的id\n        mContainerId = frag.mContainerId;//动态添加时，容器的id\n        mTag = frag.mTag;\n        //这个属性有些复杂，如果fragment设置这个属性那么\n        //这个fragment会被存到FragmentManagerViewModel里，\n        //这个viewModel的owner是FragmentManager依附的Activity\n        //由于ViewModel的特性，activity配置更改后viewModel会自动保存\n        //下一次FragmentManager恢复数据时会优先判断判断FragmentManagerViewModel\n        //里是否保存，如果保存了就不调用下面的instantiate创建新的Fragment对象\n        mRetainInstance = frag.mRetainInstance;\n        mRemoving = frag.mRemoving;//是否从activity中移除\n        mDetached = frag.mDetached;//是否被禁用，当被detach时会被设置为false\n        mArguments = frag.mArguments;//这个是个Bundle，用来传递东西的\n        mHidden = frag.mHidden;//当前Fragment是否时隐藏状态\n        mMaxLifecycleState = frag.mMaxState.ordinal();\n    }\n\n    //通过保存的信息恢复一个完整的Fragment\n    public Fragment instantiate(@NonNull ClassLoader classLoader,\n            @NonNull FragmentFactory factory) {\n        if (mInstance == null) {\n            if (mArguments != null) {\n                mArguments.setClassLoader(classLoader);\n            }\n\n            mInstance = factory.instantiate(classLoader, mClassName);\n            mInstance.setArguments(mArguments);\n\n            if (mSavedFragmentState != null) {\n                mSavedFragmentState.setClassLoader(classLoader);\n                mInstance.mSavedFragmentState = mSavedFragmentState;\n            } else {\n                // When restoring a Fragment, always ensure we have a\n                // non-null Bundle so that developers have a signal for\n                // when the Fragment is being restored\n                mInstance.mSavedFragmentState = new Bundle();\n            }\n            mInstance.mWho = mWho;\n            mInstance.mFromLayout = mFromLayout;\n            mInstance.mRestored = true;\n            mInstance.mFragmentId = mFragmentId;\n            mInstance.mContainerId = mContainerId;\n            mInstance.mTag = mTag;\n            mInstance.mRetainInstance = mRetainInstance;\n            mInstance.mRemoving = mRemoving;\n            mInstance.mDetached = mDetached;\n            mInstance.mHidden = mHidden;\n            mInstance.mMaxState = Lifecycle.State.values()[mMaxLifecycleState];\n\n            if (FragmentManagerImpl.DEBUG) {\n                Log.v(FragmentManagerImpl.TAG, \"Instantiated fragment \" + mInstance);\n            }\n        }\n        return mInstance;\n    }\n\n}\n```\n\n从上面的代码注释就可以看出，保存了哪些东西\n\n看来这个解答时正解，哦耶<img src=\"%E5%BD%93Activity%E5%BC%82%E5%B8%B8%E9%94%80%E6%AF%81FragmentManager%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg\" alt=\"img\" style=\"zoom:50%;\" />","slug":"当Activity异常销毁FragmentManager做了什么","published":1,"updated":"2020-04-02T21:47:15.863Z","_id":"ck8jl8qj8001gw0w05rrtak60","comments":1,"layout":"post","photos":[],"link":"2020/03/27/当Activity异常销毁FragmentManager做了什么","content":"<p>最近在做项目的时候因为<code>Activity</code>和<code>FragmentManager</code>，使项目遇到了一些问题，<code>Activity</code>异常销毁重启之后，上次加载进去的<code>Fragment</code>也依然存在<code>FragmentManager</code>当中，但是在<code>Activity</code>中的初始化函数仍然会生成新的<code>fragment</code>进去。以此导致了界面出现了重复加载的问题。</p>\n<p>下面的分析都是基于<code>Androidx</code>的源码，和<code>support</code>有些区别</p>\n<h2 id=\"问题出现可能的原因\">问题出现可能的原因<a href=\"#问题出现可能的原因\" title=\"问题出现可能的原因\"></a></h2><ul><li><code>FragmentManager</code>生命周期更长</li><li>销毁之前恢复机制将这些<code>fragment</code>数据进行了保存，重新创建时恢复了</li></ul><h4 id=\"fragmentmanager生命周期更长？？？\"><code>FragmentManager</code>生命周期更长？？？<a href=\"#fragmentmanager生命周期更长？？？\" title=\"FragmentManager生命周期更长？？？\"></a></h4><p><code>Activity</code>异常销毁（或者配置更改）时<code>FragmentManager</code>会像<code>ViewModel</code>一样自动保存下来？以便于下次加载使用吗</p>\n<p><strong>证明一下</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> TAG = <span class=\"string\">\"MainActivityDemo\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\">        Log.d(TAG, <span class=\"string\">\"<span class=\"subst\">$&#123;supportFragmentManager&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们开启分屏</p>\n<p><img src=\"/2020/03/27/%E5%BD%93Activity%E5%BC%82%E5%B8%B8%E9%94%80%E6%AF%81FragmentManager%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/image-20200327042035621.png\" class=\"φcy\" alt=\"image-20200327042035621\"></p>\n<p>很明显这里不是同一个对象，这个原因pass。</p>\n<h4 id=\"被恢复了？？\">被恢复了？？<a href=\"#被恢复了？？\" title=\"被恢复了？？\"></a></h4><p><img src=\"/2020/03/27/%E5%BD%93Activity%E5%BC%82%E5%B8%B8%E9%94%80%E6%AF%81FragmentManager%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg\" alt=\"v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924\" style=\"zoom:50%;\">我们来看看<code>FragmentActivity</code>中<code>onSaveInstanceState</code>干了什么</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSaveInstanceState</span><span class=\"params\">(@NonNull Bundle outState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onSaveInstanceState(outState);</span><br><span class=\"line\">    markFragmentsCreated();<span class=\"comment\">//标记已经创建的fragment</span></span><br><span class=\"line\">    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);</span><br><span class=\"line\">    Parcelable p = mFragments.saveAllState();<span class=\"comment\">//保存状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        outState.putParcelable(FRAGMENTS_TAG, p);<span class=\"comment\">//放到Bundle</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// do something..................</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里的确做了保存，那么我们看看在哪里用到了<code>FRAGMENTS_TAG</code>这个标志位</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    mFragments.attachHost(<span class=\"keyword\">null</span> <span class=\"comment\">/*parent*/</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (savedInstanceState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);<span class=\"comment\">//获取保存的数据</span></span><br><span class=\"line\">        mFragments.restoreSaveState(p);<span class=\"comment\">//对数据进行了恢复</span></span><br><span class=\"line\">        <span class=\"comment\">// do something............</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// do something............</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class=\"line\">    mFragments.dispatchCreate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>具体保存操作是怎么操作的这个，自己去研究，不在本篇文章讨论范围</p>\n<p>涉及到<code>FragmentManager</code>对<code>fragment</code>的<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>的层层调用</p>\n<p>我们来看看一个Fragment到底保存了一些什么东西（以下我只保留了关键函数）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentState</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String mClassName;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String mWho;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> mFromLayout;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mFragmentId;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mContainerId;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String mTag;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> mRetainInstance;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> mRemoving;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> mDetached;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Bundle mArguments;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> mHidden;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mMaxLifecycleState;</span><br><span class=\"line\"></span><br><span class=\"line\">    Bundle mSavedFragmentState;</span><br><span class=\"line\"></span><br><span class=\"line\">    Fragment mInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//传入fragment对数据进行构造</span></span><br><span class=\"line\">    FragmentState(Fragment frag) &#123;</span><br><span class=\"line\">        mClassName = frag.getClass().getName();<span class=\"comment\">//类名</span></span><br><span class=\"line\">        mWho = frag.mWho;<span class=\"comment\">//这个fragment对象独有的id</span></span><br><span class=\"line\">        mFromLayout = frag.mFromLayout;<span class=\"comment\">//是否是直接从布局实例化的（boolean）</span></span><br><span class=\"line\">        mFragmentId = frag.mFragmentId;<span class=\"comment\">//若是动态添加的，则为容器id，从视图添加则为布局中的id</span></span><br><span class=\"line\">        mContainerId = frag.mContainerId;<span class=\"comment\">//动态添加时，容器的id</span></span><br><span class=\"line\">        mTag = frag.mTag;</span><br><span class=\"line\">        <span class=\"comment\">//这个属性有些复杂，如果fragment设置这个属性那么</span></span><br><span class=\"line\">        <span class=\"comment\">//这个fragment会被存到FragmentManagerViewModel里，</span></span><br><span class=\"line\">        <span class=\"comment\">//这个viewModel的owner是FragmentManager依附的Activity</span></span><br><span class=\"line\">        <span class=\"comment\">//由于ViewModel的特性，activity配置更改后viewModel会自动保存</span></span><br><span class=\"line\">        <span class=\"comment\">//下一次FragmentManager恢复数据时会优先判断判断FragmentManagerViewModel</span></span><br><span class=\"line\">        <span class=\"comment\">//里是否保存，如果保存了就不调用下面的instantiate创建新的Fragment对象</span></span><br><span class=\"line\">        mRetainInstance = frag.mRetainInstance;</span><br><span class=\"line\">        mRemoving = frag.mRemoving;<span class=\"comment\">//是否从activity中移除</span></span><br><span class=\"line\">        mDetached = frag.mDetached;<span class=\"comment\">//是否被禁用，当被detach时会被设置为false</span></span><br><span class=\"line\">        mArguments = frag.mArguments;<span class=\"comment\">//这个是个Bundle，用来传递东西的</span></span><br><span class=\"line\">        mHidden = frag.mHidden;<span class=\"comment\">//当前Fragment是否时隐藏状态</span></span><br><span class=\"line\">        mMaxLifecycleState = frag.mMaxState.ordinal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//通过保存的信息恢复一个完整的Fragment</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fragment <span class=\"title\">instantiate</span><span class=\"params\">(@NonNull ClassLoader classLoader,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull FragmentFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mInstance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mArguments != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mArguments.setClassLoader(classLoader);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            mInstance = factory.instantiate(classLoader, mClassName);</span><br><span class=\"line\">            mInstance.setArguments(mArguments);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mSavedFragmentState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mSavedFragmentState.setClassLoader(classLoader);</span><br><span class=\"line\">                mInstance.mSavedFragmentState = mSavedFragmentState;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// When restoring a Fragment, always ensure we have a</span></span><br><span class=\"line\">                <span class=\"comment\">// non-null Bundle so that developers have a signal for</span></span><br><span class=\"line\">                <span class=\"comment\">// when the Fragment is being restored</span></span><br><span class=\"line\">                mInstance.mSavedFragmentState = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mInstance.mWho = mWho;</span><br><span class=\"line\">            mInstance.mFromLayout = mFromLayout;</span><br><span class=\"line\">            mInstance.mRestored = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            mInstance.mFragmentId = mFragmentId;</span><br><span class=\"line\">            mInstance.mContainerId = mContainerId;</span><br><span class=\"line\">            mInstance.mTag = mTag;</span><br><span class=\"line\">            mInstance.mRetainInstance = mRetainInstance;</span><br><span class=\"line\">            mInstance.mRemoving = mRemoving;</span><br><span class=\"line\">            mInstance.mDetached = mDetached;</span><br><span class=\"line\">            mInstance.mHidden = mHidden;</span><br><span class=\"line\">            mInstance.mMaxState = Lifecycle.State.values()[mMaxLifecycleState];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (FragmentManagerImpl.DEBUG) &#123;</span><br><span class=\"line\">                Log.v(FragmentManagerImpl.TAG, <span class=\"string\">\"Instantiated fragment \"</span> + mInstance);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码注释就可以看出，保存了哪些东西</p>\n<p>看来这个解答时正解，哦耶<img src=\"/2020/03/27/%E5%BD%93Activity%E5%BC%82%E5%B8%B8%E9%94%80%E6%AF%81FragmentManager%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在做项目的时候因为<code>Activity</code>和<code>FragmentManager</code>，使项目遇到了一些问题，<code>Activity</code>异常销毁重启之后，上次加载进去的<code>Fragment</code>也依然存在<code>FragmentManager</code>当中，但是在<code>Activity</code>中的初始化函数仍然会生成新的<code>fragment</code>进去。以此导致了界面出现了重复加载的问题。</p>\n<p>下面的分析都是基于<code>Androidx</code>的源码，和<code>support</code>有些区别</p>\n<h2 id=\"问题出现可能的原因\">问题出现可能的原因<a href=\"#问题出现可能的原因\" title=\"问题出现可能的原因\"></a></h2><ul><li><code>FragmentManager</code>生命周期更长</li><li>销毁之前恢复机制将这些<code>fragment</code>数据进行了保存，重新创建时恢复了</li></ul><h4 id=\"fragmentmanager生命周期更长？？？\"><code>FragmentManager</code>生命周期更长？？？<a href=\"#fragmentmanager生命周期更长？？？\" title=\"FragmentManager生命周期更长？？？\"></a></h4><p><code>Activity</code>异常销毁（或者配置更改）时<code>FragmentManager</code>会像<code>ViewModel</code>一样自动保存下来？以便于下次加载使用吗</p>\n<p><strong>证明一下</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> TAG = <span class=\"string\">\"MainActivityDemo\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\">        Log.d(TAG, <span class=\"string\">\"<span class=\"subst\">$&#123;supportFragmentManager&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们开启分屏</p>\n<p><img src=\"/2020/03/27/%E5%BD%93Activity%E5%BC%82%E5%B8%B8%E9%94%80%E6%AF%81FragmentManager%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/image-20200327042035621.png\" class=\"φcy\" alt=\"image-20200327042035621\"></p>\n<p>很明显这里不是同一个对象，这个原因pass。</p>\n<h4 id=\"被恢复了？？\">被恢复了？？<a href=\"#被恢复了？？\" title=\"被恢复了？？\"></a></h4><p><img src=\"/2020/03/27/%E5%BD%93Activity%E5%BC%82%E5%B8%B8%E9%94%80%E6%AF%81FragmentManager%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg\" alt=\"v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924\" style=\"zoom:50%;\">我们来看看<code>FragmentActivity</code>中<code>onSaveInstanceState</code>干了什么</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSaveInstanceState</span><span class=\"params\">(@NonNull Bundle outState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onSaveInstanceState(outState);</span><br><span class=\"line\">    markFragmentsCreated();<span class=\"comment\">//标记已经创建的fragment</span></span><br><span class=\"line\">    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);</span><br><span class=\"line\">    Parcelable p = mFragments.saveAllState();<span class=\"comment\">//保存状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        outState.putParcelable(FRAGMENTS_TAG, p);<span class=\"comment\">//放到Bundle</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// do something..................</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里的确做了保存，那么我们看看在哪里用到了<code>FRAGMENTS_TAG</code>这个标志位</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    mFragments.attachHost(<span class=\"keyword\">null</span> <span class=\"comment\">/*parent*/</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (savedInstanceState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);<span class=\"comment\">//获取保存的数据</span></span><br><span class=\"line\">        mFragments.restoreSaveState(p);<span class=\"comment\">//对数据进行了恢复</span></span><br><span class=\"line\">        <span class=\"comment\">// do something............</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// do something............</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class=\"line\">    mFragments.dispatchCreate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>具体保存操作是怎么操作的这个，自己去研究，不在本篇文章讨论范围</p>\n<p>涉及到<code>FragmentManager</code>对<code>fragment</code>的<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>的层层调用</p>\n<p>我们来看看一个Fragment到底保存了一些什么东西（以下我只保留了关键函数）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentState</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String mClassName;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String mWho;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> mFromLayout;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mFragmentId;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mContainerId;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String mTag;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> mRetainInstance;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> mRemoving;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> mDetached;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Bundle mArguments;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> mHidden;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mMaxLifecycleState;</span><br><span class=\"line\"></span><br><span class=\"line\">    Bundle mSavedFragmentState;</span><br><span class=\"line\"></span><br><span class=\"line\">    Fragment mInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//传入fragment对数据进行构造</span></span><br><span class=\"line\">    FragmentState(Fragment frag) &#123;</span><br><span class=\"line\">        mClassName = frag.getClass().getName();<span class=\"comment\">//类名</span></span><br><span class=\"line\">        mWho = frag.mWho;<span class=\"comment\">//这个fragment对象独有的id</span></span><br><span class=\"line\">        mFromLayout = frag.mFromLayout;<span class=\"comment\">//是否是直接从布局实例化的（boolean）</span></span><br><span class=\"line\">        mFragmentId = frag.mFragmentId;<span class=\"comment\">//若是动态添加的，则为容器id，从视图添加则为布局中的id</span></span><br><span class=\"line\">        mContainerId = frag.mContainerId;<span class=\"comment\">//动态添加时，容器的id</span></span><br><span class=\"line\">        mTag = frag.mTag;</span><br><span class=\"line\">        <span class=\"comment\">//这个属性有些复杂，如果fragment设置这个属性那么</span></span><br><span class=\"line\">        <span class=\"comment\">//这个fragment会被存到FragmentManagerViewModel里，</span></span><br><span class=\"line\">        <span class=\"comment\">//这个viewModel的owner是FragmentManager依附的Activity</span></span><br><span class=\"line\">        <span class=\"comment\">//由于ViewModel的特性，activity配置更改后viewModel会自动保存</span></span><br><span class=\"line\">        <span class=\"comment\">//下一次FragmentManager恢复数据时会优先判断判断FragmentManagerViewModel</span></span><br><span class=\"line\">        <span class=\"comment\">//里是否保存，如果保存了就不调用下面的instantiate创建新的Fragment对象</span></span><br><span class=\"line\">        mRetainInstance = frag.mRetainInstance;</span><br><span class=\"line\">        mRemoving = frag.mRemoving;<span class=\"comment\">//是否从activity中移除</span></span><br><span class=\"line\">        mDetached = frag.mDetached;<span class=\"comment\">//是否被禁用，当被detach时会被设置为false</span></span><br><span class=\"line\">        mArguments = frag.mArguments;<span class=\"comment\">//这个是个Bundle，用来传递东西的</span></span><br><span class=\"line\">        mHidden = frag.mHidden;<span class=\"comment\">//当前Fragment是否时隐藏状态</span></span><br><span class=\"line\">        mMaxLifecycleState = frag.mMaxState.ordinal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//通过保存的信息恢复一个完整的Fragment</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fragment <span class=\"title\">instantiate</span><span class=\"params\">(@NonNull ClassLoader classLoader,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @NonNull FragmentFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mInstance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mArguments != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mArguments.setClassLoader(classLoader);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            mInstance = factory.instantiate(classLoader, mClassName);</span><br><span class=\"line\">            mInstance.setArguments(mArguments);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mSavedFragmentState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mSavedFragmentState.setClassLoader(classLoader);</span><br><span class=\"line\">                mInstance.mSavedFragmentState = mSavedFragmentState;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// When restoring a Fragment, always ensure we have a</span></span><br><span class=\"line\">                <span class=\"comment\">// non-null Bundle so that developers have a signal for</span></span><br><span class=\"line\">                <span class=\"comment\">// when the Fragment is being restored</span></span><br><span class=\"line\">                mInstance.mSavedFragmentState = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mInstance.mWho = mWho;</span><br><span class=\"line\">            mInstance.mFromLayout = mFromLayout;</span><br><span class=\"line\">            mInstance.mRestored = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            mInstance.mFragmentId = mFragmentId;</span><br><span class=\"line\">            mInstance.mContainerId = mContainerId;</span><br><span class=\"line\">            mInstance.mTag = mTag;</span><br><span class=\"line\">            mInstance.mRetainInstance = mRetainInstance;</span><br><span class=\"line\">            mInstance.mRemoving = mRemoving;</span><br><span class=\"line\">            mInstance.mDetached = mDetached;</span><br><span class=\"line\">            mInstance.mHidden = mHidden;</span><br><span class=\"line\">            mInstance.mMaxState = Lifecycle.State.values()[mMaxLifecycleState];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (FragmentManagerImpl.DEBUG) &#123;</span><br><span class=\"line\">                Log.v(FragmentManagerImpl.TAG, <span class=\"string\">\"Instantiated fragment \"</span> + mInstance);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码注释就可以看出，保存了哪些东西</p>\n<p>看来这个解答时正解，哦耶<img src=\"/2020/03/27/%E5%BD%93Activity%E5%BC%82%E5%B8%B8%E9%94%80%E6%AF%81FragmentManager%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg\" alt=\"img\" style=\"zoom:50%;\"></p>\n","date_formatted":{"ll":"Mar 27, 2020","L":"03/27/2020","MM-DD":"03-27"},"plink":"https://treeeeeeee.github.io/2020/03/27/当Activity异常销毁FragmentManager做了什么/","type":"post","toc":[{"id":"问题出现可能的原因","title":"问题出现可能的原因","index":"1","children":[{"id":"fragmentmanager生命周期更长？？？","title":"FragmentManager生命周期更长？？？","index":"1.1"},{"id":"被恢复了？？","title":"被恢复了？？","index":"1.2"}]}]},{"title":"类加载和类加载器","date":"2020-04-01T05:06:43.000Z","_content":"\n## 类加载流程\n\n**链接和加载时并行的，没有谁先再后的先后顺序，涉及到源码中对链接的方法的调用**\n\n### 加载\n\n”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：\n\n- 通过一个类的全限定名来获取其定义的二进制字节流\n- 将这个字节流所代表的的**静态存储结构**转化为**方法区**中的**运行时数据结构**（初始化）\n- 在**堆**中生成一个代表这个类的Class对象，作为**方法区**中这些数据的访问入口。\n\n至于JVM的内存管理和分区结构大致是以下\n\n\n\n相对于类加载的其他阶段而言，加载阶段是**可控性最强**的阶段，因为程序员可以使用系统的类加载器加载，还可以使用自己的类加载器加载（从网络，本地，或者任意地方加载字节码文件）。\n\n**类加载器的作用就是上面虚拟机需要完成的三件事，我们定义的类加载器也是一样**\n\n### 链接\n\n* 验证\n\n  保证格式正确，符合java语法规范，不会对`jvm`造成危害\n\n  * 文件格式验证，是否符合class文件的格式的规范\n  * **元数据**验证，对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求\n  * 字节码验证，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。\n  * 符号引用验证，发生在**虚拟机将符号引用转化为直接引用**的时候。主要是对类自身以外的信息进行校验。目的是**确保解析动作能够完成**。\n\n* 准备\n\n  准备类变量（静态变量），赋默认值\n\n* 解析\n\n  解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。什么是符号应用和直接引用呢？\n  \n  - 符号引用：\n  \n    以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）\n  \n  - 直接引用：\n  \n    是可以指向目标的**指针**、**相对偏移量**或者是**一个能直接或间接定位到目标的句柄**。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。解析动作主要针对**类或接口**、**字段**、**类方法**、**接口方法**、**方法类型**、**方法句柄**和**调用点限定符**7类符号引用进行。\n\n### 初始化\n\n执行类构造器<cinit>\n\n* 有父类，但是父类还没有被初始化先执行父类的初始化\n\n  ```java\n  public class Animal {\n      static {\n          System.out.println(\"Animal\");\n      }\n  }\n  ```\n\n  ```java\n  public class People extends Animal {\n      static {\n          System.out.println(\"People\");\n      }\n  }\n  ```\n\n  ```java\n  public class Main {\n      public static void main(String[] args) {\n          People people = new People();\n      }\n  }\n  ```\n\n  > ```\n  > 输出：\n  > Animal\n  > People\n  > ```\n\n* 同一个命名空间只会初始化一次\n\n  > 类加载器的**命名空间**是由类加载器**本身以及所有父加载器**所加载出来的`binary name`(`full class name`)组成.\n  >\n  > * 在同一个命名空间里，不允许出现二个完全-样的`binary name`。\n  > * 在不同的命名空间种，可以出现二个相同的`binary name`。当时二者对应的Class对象是相互不能感知到的，也就是说Class对象的类型是不一样的。\n  > * 子加载器的命名空间中的binary name对应的类中可以访问父加载器命名空间中`binary name`对应的类，反之不行\n\n### 两个重要的init方法\n\n#### init\n\n是instance实例构造器，对非静态变量解析初始化\n\n#### **clinit**\n\n是class类构造器对静态变量，静态代码块进行初始化\n\n方法是由编译器**自动收集类中的所有类变量的赋值动作和静态语句块**（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，\n\n静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不可以使用，会报非法前置引用的错误。\n\n例如：\n\n```java\nstatic {\n    a = 0;//可以，因为在链接中的准备阶段就已经准备好了这个变量，这里相当于重新赋值\n    System.out.println(a);//不可以，会被提示非法前置引用\n}\nstatic int a = 0;//真正对程序员所期望的初始值进行初始化\n```\n\n### 相关例子\n\n#### 经典面试题\n\n```java\nclass Person{\n    static int a;\n    static int b = 0;\n    static Person instance = new Person();\n\n\n    Person(){\n        a++;\n        b++;\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Person person = Person.instance;\n        System.out.println(Person.a);\n        System.out.println(Person.b);\n    }\n}\n************************************\n输出：\n    1\n\t1\n************************************\n    \n/**\n*  将Person类中的\n*  static Person instance = new Person();\n*  提到最前面\n*/\nclass Person{\n    static Person instance = new Person();\n    static int a;\n    static int b = 0;\n\n\n    Person(){\n        a++;\n        b++;\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Person person = Person.instance;\n        System.out.println(Person.a);\n        System.out.println(Person.b);\n    }\n}\n************************************\n输出：\n    1\n    0\n************************************\n```\n\n**原因：**\n\n原因在准备\n\n## 类加载器\n\n* `BootstrapClassLoader`\n\n  由C实现\n\n* `ExtensionClassLoader`\n\n  由java实现，继承于`ClassLoader`\n\n* `ApplicationClassLoader`\n\n  由java实现，继承于`ClassLoader`\n\n* 自定义加载器\n\n  必须继承`ClassLoader`，默认父加载器为`ApplicationClassLoader`，可通过重写构造器自定义父加载器\n\n  源码中给出的Demo\n\n  ```java\n  class NetworkClassLoader extends ClassLoader {\n      String host;\n      int port;\n  \n      public Class findClass(String name) {\n          byte[] b = loadClassData(name);\n  \t\t//defineClass最终调用native方法，返回一个Class对象\n          return defineClass(name, b, 0, b.length);\n      }\n  \n      private byte[] loadClassData(String name) {\n          // load the class data from the connection\n          //加载字节码并返回一个but数组，来源不限，可以是网络、本地或者专有数据库中的class文件\n      }\n  }\n  ```\n\n\n\n**注意：有层级关系，相互没有继承关系**\n\n\n\n### 双亲委派模型\n\n简单来说，一个类似于“android中的事件分发的流程”\n\n加载类时依次向上层层调用，请求上层查找并加载，若上层不能查找或者加载到，自己加载或者查找\n\n`java.lang.ClassLoader.java`加载类关键代码\n\n```java\nprotected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n    synchronized(this.getClassLoadingLock(name)) {\n        Class<?> c = this.findLoadedClass(name);\n        if (c == null) {\n            long t0 = System.nanoTime();\n\n            try {\n                //判断父加载器是否为空\n                if (this.parent != null) {\n                    //有，则优先调用父加载器的loadClass加载方法，层层调用\n                    //上面一层的也会这样要父加载器加载\n                    c = this.parent.loadClass(name, false);\n                } else {\n                    //父加载器为空，则使用启动类加载器来加载\n                    c = this.findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException var10) {\n            }\n            //判断c是否为空\n            //为空？表示当前类加载器的所有上层加载器都不能找到或者加载此类\n            //不为空？表示当前类加载器的某个上层加载器已经找到或者加载此类，并返回了Class对象\n            if (c == null) {\n                long t1 = System.nanoTime();\n                c = this.findClass(name);\n                PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                PerfCounter.getFindClasses().increment();\n            }\n        }\n\n        if (resolve) {\n            this.resolveClass(c);\n        }\n\n        return c;\n    }\n}\n```\n\n### 优点\n\n- 避免类的重复加载\n\n- 保护程序安全，防止核心API随意篡改\n\n  > 如何保护？例如：自定义类:java.lang. String\n  >\n  > ```java\n  > package java.lang;\n  > \n  > public class String {\n  >     public static void main(String[] args) {\n  >         System.out.println(\"假的String里面\");\n  >     }\n  > }\n  > ```\n  >\n  > 自己建一个全类名跟String一样的类，如果这个类在java中的String类之前被加载，那么Java Api中的String会被我这个String替换，并且不再加载java自己的String。\n\n## 加载时机\n\n### 必须要有类去主动使用该 Class。\n\n* 使用 new 关键字、反射、克隆、反序列化；\n* 调用类的静态方法\n* 调用一个类的子类的时候会初始化其父类\n* 包含 main() 方法的类（相当于第二条）。\n\n### 被动使用则不会去装载 Class。\n\n* 调用了其父类的静态方法\n\n  ```java\n  public class Animal {\n      static {\n          System.out.println(\"Animal\");//类被初始化会打印Animal\n      }\n  \n      static String getValue() {\n          return \"getIntValue\";\n      }\n  }\n  ```\n\n  ```java\n  public class People extends Animal {\n      static {\n          System.out.println(\"People\");//类被初始化会打印People\n      }\n  }\n  ```\n\n  ```java\n  public class Main {\n      public static void main(String[] args) {\n          System.out.println(People.getValue());//调用People类的getValue\n      }\n  }\n  ```\n\n  ```\n输出：\n  Animal\n  getIntValue\n  ```\n```\n  \n  表明`getValue()`这个静态成员是Animal的就一定是Animal的，其实`People.getValue()`就等价于`Animal.getValue()`\n\n## 只加载不初始化\n\n​```java\npublic class People extends Animal {\n    static {\n        System.out.println(\"PeopleLoad\");\n    }\n}\n```\n\n```java\npublic class Main {\n    public static void main(String[] args){\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        Class mClass = classLoader.loadClass(\"People\");\n    }\n}\n```\n\n```\n输出：\nPeople\n```\n\n静态代码块没有执行，说明此时<cinit>方法还没有被调用，说明只加载没有初始化，原因在哪？\n\n`java.lang.ClassLoader#loadClass(java.lang.String, boolean)`，这个方法的第二个参数，就是控制链接的默认调用`loadClass`传入的时false，如果传入true最后会调用native方法进行链接\n\n```java\npublic Class<?> loadClass(String name) throws ClassNotFoundException {\n    return loadClass(name, false);\n}\n```\n\n## 既加载又初始化\n\n上面举了很多例子，我们看一个关键的\n\n还是下面这一些代码\n\n```java\npublic class People {\n    static {\n        System.out.println(\"PeopleLoad\");\n    }\n}\n```\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        Class.forName(\"People\", true, classLoader);\n    }\n}\n```\n\n```\n输出：\nPeopleLoad\n```\n\n","source":"_posts/类加载和类加载器.md","raw":"---\ntitle: 类加载和类加载器\ndate: 2020-04-01 13:06:43\ntags:\n- 干货\ncategories:\n- Java\n---\n\n## 类加载流程\n\n**链接和加载时并行的，没有谁先再后的先后顺序，涉及到源码中对链接的方法的调用**\n\n### 加载\n\n”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：\n\n- 通过一个类的全限定名来获取其定义的二进制字节流\n- 将这个字节流所代表的的**静态存储结构**转化为**方法区**中的**运行时数据结构**（初始化）\n- 在**堆**中生成一个代表这个类的Class对象，作为**方法区**中这些数据的访问入口。\n\n至于JVM的内存管理和分区结构大致是以下\n\n\n\n相对于类加载的其他阶段而言，加载阶段是**可控性最强**的阶段，因为程序员可以使用系统的类加载器加载，还可以使用自己的类加载器加载（从网络，本地，或者任意地方加载字节码文件）。\n\n**类加载器的作用就是上面虚拟机需要完成的三件事，我们定义的类加载器也是一样**\n\n### 链接\n\n* 验证\n\n  保证格式正确，符合java语法规范，不会对`jvm`造成危害\n\n  * 文件格式验证，是否符合class文件的格式的规范\n  * **元数据**验证，对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求\n  * 字节码验证，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。\n  * 符号引用验证，发生在**虚拟机将符号引用转化为直接引用**的时候。主要是对类自身以外的信息进行校验。目的是**确保解析动作能够完成**。\n\n* 准备\n\n  准备类变量（静态变量），赋默认值\n\n* 解析\n\n  解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。什么是符号应用和直接引用呢？\n  \n  - 符号引用：\n  \n    以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）\n  \n  - 直接引用：\n  \n    是可以指向目标的**指针**、**相对偏移量**或者是**一个能直接或间接定位到目标的句柄**。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。解析动作主要针对**类或接口**、**字段**、**类方法**、**接口方法**、**方法类型**、**方法句柄**和**调用点限定符**7类符号引用进行。\n\n### 初始化\n\n执行类构造器<cinit>\n\n* 有父类，但是父类还没有被初始化先执行父类的初始化\n\n  ```java\n  public class Animal {\n      static {\n          System.out.println(\"Animal\");\n      }\n  }\n  ```\n\n  ```java\n  public class People extends Animal {\n      static {\n          System.out.println(\"People\");\n      }\n  }\n  ```\n\n  ```java\n  public class Main {\n      public static void main(String[] args) {\n          People people = new People();\n      }\n  }\n  ```\n\n  > ```\n  > 输出：\n  > Animal\n  > People\n  > ```\n\n* 同一个命名空间只会初始化一次\n\n  > 类加载器的**命名空间**是由类加载器**本身以及所有父加载器**所加载出来的`binary name`(`full class name`)组成.\n  >\n  > * 在同一个命名空间里，不允许出现二个完全-样的`binary name`。\n  > * 在不同的命名空间种，可以出现二个相同的`binary name`。当时二者对应的Class对象是相互不能感知到的，也就是说Class对象的类型是不一样的。\n  > * 子加载器的命名空间中的binary name对应的类中可以访问父加载器命名空间中`binary name`对应的类，反之不行\n\n### 两个重要的init方法\n\n#### init\n\n是instance实例构造器，对非静态变量解析初始化\n\n#### **clinit**\n\n是class类构造器对静态变量，静态代码块进行初始化\n\n方法是由编译器**自动收集类中的所有类变量的赋值动作和静态语句块**（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，\n\n静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不可以使用，会报非法前置引用的错误。\n\n例如：\n\n```java\nstatic {\n    a = 0;//可以，因为在链接中的准备阶段就已经准备好了这个变量，这里相当于重新赋值\n    System.out.println(a);//不可以，会被提示非法前置引用\n}\nstatic int a = 0;//真正对程序员所期望的初始值进行初始化\n```\n\n### 相关例子\n\n#### 经典面试题\n\n```java\nclass Person{\n    static int a;\n    static int b = 0;\n    static Person instance = new Person();\n\n\n    Person(){\n        a++;\n        b++;\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Person person = Person.instance;\n        System.out.println(Person.a);\n        System.out.println(Person.b);\n    }\n}\n************************************\n输出：\n    1\n\t1\n************************************\n    \n/**\n*  将Person类中的\n*  static Person instance = new Person();\n*  提到最前面\n*/\nclass Person{\n    static Person instance = new Person();\n    static int a;\n    static int b = 0;\n\n\n    Person(){\n        a++;\n        b++;\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Person person = Person.instance;\n        System.out.println(Person.a);\n        System.out.println(Person.b);\n    }\n}\n************************************\n输出：\n    1\n    0\n************************************\n```\n\n**原因：**\n\n原因在准备\n\n## 类加载器\n\n* `BootstrapClassLoader`\n\n  由C实现\n\n* `ExtensionClassLoader`\n\n  由java实现，继承于`ClassLoader`\n\n* `ApplicationClassLoader`\n\n  由java实现，继承于`ClassLoader`\n\n* 自定义加载器\n\n  必须继承`ClassLoader`，默认父加载器为`ApplicationClassLoader`，可通过重写构造器自定义父加载器\n\n  源码中给出的Demo\n\n  ```java\n  class NetworkClassLoader extends ClassLoader {\n      String host;\n      int port;\n  \n      public Class findClass(String name) {\n          byte[] b = loadClassData(name);\n  \t\t//defineClass最终调用native方法，返回一个Class对象\n          return defineClass(name, b, 0, b.length);\n      }\n  \n      private byte[] loadClassData(String name) {\n          // load the class data from the connection\n          //加载字节码并返回一个but数组，来源不限，可以是网络、本地或者专有数据库中的class文件\n      }\n  }\n  ```\n\n\n\n**注意：有层级关系，相互没有继承关系**\n\n\n\n### 双亲委派模型\n\n简单来说，一个类似于“android中的事件分发的流程”\n\n加载类时依次向上层层调用，请求上层查找并加载，若上层不能查找或者加载到，自己加载或者查找\n\n`java.lang.ClassLoader.java`加载类关键代码\n\n```java\nprotected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n    synchronized(this.getClassLoadingLock(name)) {\n        Class<?> c = this.findLoadedClass(name);\n        if (c == null) {\n            long t0 = System.nanoTime();\n\n            try {\n                //判断父加载器是否为空\n                if (this.parent != null) {\n                    //有，则优先调用父加载器的loadClass加载方法，层层调用\n                    //上面一层的也会这样要父加载器加载\n                    c = this.parent.loadClass(name, false);\n                } else {\n                    //父加载器为空，则使用启动类加载器来加载\n                    c = this.findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException var10) {\n            }\n            //判断c是否为空\n            //为空？表示当前类加载器的所有上层加载器都不能找到或者加载此类\n            //不为空？表示当前类加载器的某个上层加载器已经找到或者加载此类，并返回了Class对象\n            if (c == null) {\n                long t1 = System.nanoTime();\n                c = this.findClass(name);\n                PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                PerfCounter.getFindClasses().increment();\n            }\n        }\n\n        if (resolve) {\n            this.resolveClass(c);\n        }\n\n        return c;\n    }\n}\n```\n\n### 优点\n\n- 避免类的重复加载\n\n- 保护程序安全，防止核心API随意篡改\n\n  > 如何保护？例如：自定义类:java.lang. String\n  >\n  > ```java\n  > package java.lang;\n  > \n  > public class String {\n  >     public static void main(String[] args) {\n  >         System.out.println(\"假的String里面\");\n  >     }\n  > }\n  > ```\n  >\n  > 自己建一个全类名跟String一样的类，如果这个类在java中的String类之前被加载，那么Java Api中的String会被我这个String替换，并且不再加载java自己的String。\n\n## 加载时机\n\n### 必须要有类去主动使用该 Class。\n\n* 使用 new 关键字、反射、克隆、反序列化；\n* 调用类的静态方法\n* 调用一个类的子类的时候会初始化其父类\n* 包含 main() 方法的类（相当于第二条）。\n\n### 被动使用则不会去装载 Class。\n\n* 调用了其父类的静态方法\n\n  ```java\n  public class Animal {\n      static {\n          System.out.println(\"Animal\");//类被初始化会打印Animal\n      }\n  \n      static String getValue() {\n          return \"getIntValue\";\n      }\n  }\n  ```\n\n  ```java\n  public class People extends Animal {\n      static {\n          System.out.println(\"People\");//类被初始化会打印People\n      }\n  }\n  ```\n\n  ```java\n  public class Main {\n      public static void main(String[] args) {\n          System.out.println(People.getValue());//调用People类的getValue\n      }\n  }\n  ```\n\n  ```\n输出：\n  Animal\n  getIntValue\n  ```\n```\n  \n  表明`getValue()`这个静态成员是Animal的就一定是Animal的，其实`People.getValue()`就等价于`Animal.getValue()`\n\n## 只加载不初始化\n\n​```java\npublic class People extends Animal {\n    static {\n        System.out.println(\"PeopleLoad\");\n    }\n}\n```\n\n```java\npublic class Main {\n    public static void main(String[] args){\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        Class mClass = classLoader.loadClass(\"People\");\n    }\n}\n```\n\n```\n输出：\nPeople\n```\n\n静态代码块没有执行，说明此时<cinit>方法还没有被调用，说明只加载没有初始化，原因在哪？\n\n`java.lang.ClassLoader#loadClass(java.lang.String, boolean)`，这个方法的第二个参数，就是控制链接的默认调用`loadClass`传入的时false，如果传入true最后会调用native方法进行链接\n\n```java\npublic Class<?> loadClass(String name) throws ClassNotFoundException {\n    return loadClass(name, false);\n}\n```\n\n## 既加载又初始化\n\n上面举了很多例子，我们看一个关键的\n\n还是下面这一些代码\n\n```java\npublic class People {\n    static {\n        System.out.println(\"PeopleLoad\");\n    }\n}\n```\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        Class.forName(\"People\", true, classLoader);\n    }\n}\n```\n\n```\n输出：\nPeopleLoad\n```\n\n","slug":"类加载和类加载器","published":1,"updated":"2020-04-02T16:14:37.851Z","comments":1,"layout":"post","photos":[],"link":"2020/04/01/类加载和类加载器","_id":"ck8jl8qjb001kw0w0clxuexst","content":"<h2 id=\"类加载流程\">类加载流程<a href=\"#类加载流程\" title=\"类加载流程\"></a></h2><p><strong>链接和加载时并行的，没有谁先再后的先后顺序，涉及到源码中对链接的方法的调用</strong></p>\n<h3 id=\"加载\">加载<a href=\"#加载\" title=\"加载\"></a></h3><p>”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：</p>\n<ul><li>通过一个类的全限定名来获取其定义的二进制字节流</li><li>将这个字节流所代表的的<strong>静态存储结构</strong>转化为<strong>方法区</strong>中的<strong>运行时数据结构</strong>（初始化）</li><li>在<strong>堆</strong>中生成一个代表这个类的Class对象，作为<strong>方法区</strong>中这些数据的访问入口。</li></ul><p>至于JVM的内存管理和分区结构大致是以下</p>\n<p>相对于类加载的其他阶段而言，加载阶段是<strong>可控性最强</strong>的阶段，因为程序员可以使用系统的类加载器加载，还可以使用自己的类加载器加载（从网络，本地，或者任意地方加载字节码文件）。</p>\n<p><strong>类加载器的作用就是上面虚拟机需要完成的三件事，我们定义的类加载器也是一样</strong></p>\n<h3 id=\"链接\">链接<a href=\"#链接\" title=\"链接\"></a></h3><ul><li><p>验证</p><p>保证格式正确，符合java语法规范，不会对<code>jvm</code>造成危害</p><ul><li>文件格式验证，是否符合class文件的格式的规范</li><li><strong>元数据</strong>验证，对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求</li><li>字节码验证，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证，发生在<strong>虚拟机将符号引用转化为直接引用</strong>的时候。主要是对类自身以外的信息进行校验。目的是<strong>确保解析动作能够完成</strong>。</li></ul></li><li><p>准备</p><p>准备类变量（静态变量），赋默认值</p></li><li><p>解析</p><p>解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。什么是符号应用和直接引用呢？</p><ul><li><p>符号引用：</p><p>以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）</p></li><li><p>直接引用：</p><p>是可以指向目标的<strong>指针</strong>、<strong>相对偏移量</strong>或者是<strong>一个能直接或间接定位到目标的句柄</strong>。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。解析动作主要针对<strong>类或接口</strong>、<strong>字段</strong>、<strong>类方法</strong>、<strong>接口方法</strong>、<strong>方法类型</strong>、<strong>方法句柄</strong>和<strong>调用点限定符</strong>7类符号引用进行。</p></li></ul></li></ul><h3 id=\"初始化\">初始化<a href=\"#初始化\" title=\"初始化\"></a></h3><p>执行类构造器<cinit></cinit></p>\n<ul><li><p>有父类，但是父类还没有被初始化先执行父类的初始化</p><blockquote></blockquote></li><li><p>同一个命名空间只会初始化一次</p><blockquote><p>类加载器的<strong>命名空间</strong>是由类加载器<strong>本身以及所有父加载器</strong>所加载出来的<code>binary name</code>(<code>full class name</code>)组成.</p><ul><li>在同一个命名空间里，不允许出现二个完全-样的<code>binary name</code>。</li><li>在不同的命名空间种，可以出现二个相同的<code>binary name</code>。当时二者对应的Class对象是相互不能感知到的，也就是说Class对象的类型是不一样的。</li><li>子加载器的命名空间中的binary name对应的类中可以访问父加载器命名空间中<code>binary name</code>对应的类，反之不行</li></ul></blockquote></li></ul><h3 id=\"两个重要的init方法\">两个重要的init方法<a href=\"#两个重要的init方法\" title=\"两个重要的init方法\"></a></h3><h4 id=\"init\">init<a href=\"#init\" title=\"init\"></a></h4><p>是instance实例构造器，对非静态变量解析初始化</p>\n<h4 id=\"clinit\"><strong>clinit</strong><a href=\"#clinit\" title=\"clinit\"></a></h4><p>是class类构造器对静态变量，静态代码块进行初始化</p>\n<p>方法是由编译器<strong>自动收集类中的所有类变量的赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，</p>\n<p>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不可以使用，会报非法前置引用的错误。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    a = <span class=\"number\">0</span>;<span class=\"comment\">//可以，因为在链接中的准备阶段就已经准备好了这个变量，这里相当于重新赋值</span></span><br><span class=\"line\">    System.out.println(a);<span class=\"comment\">//不可以，会被提示非法前置引用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;<span class=\"comment\">//真正对程序员所期望的初始值进行初始化</span></span><br></pre></td></tr></table></figure><h3 id=\"相关例子\">相关例子<a href=\"#相关例子\" title=\"相关例子\"></a></h3><h4 id=\"经典面试题\">经典面试题<a href=\"#经典面试题\" title=\"经典面试题\"></a></h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Person instance = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    Person()&#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">        b++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Person person = Person.instance;</span><br><span class=\"line\">        System.out.println(Person.a);</span><br><span class=\"line\">        System.out.println(Person.b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">************************************</span><br><span class=\"line\">输出：</span><br><span class=\"line\">    <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"number\">1</span></span><br><span class=\"line\">************************************</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  将Person类中的</span></span><br><span class=\"line\"><span class=\"comment\">*  static Person instance = new Person();</span></span><br><span class=\"line\"><span class=\"comment\">*  提到最前面</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Person instance = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    Person()&#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">        b++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Person person = Person.instance;</span><br><span class=\"line\">        System.out.println(Person.a);</span><br><span class=\"line\">        System.out.println(Person.b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">************************************</span><br><span class=\"line\">输出：</span><br><span class=\"line\">    <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"number\">0</span></span><br><span class=\"line\">************************************</span><br></pre></td></tr></table></figure><p><strong>原因：</strong></p>\n<p>原因在准备</p>\n<h2 id=\"类加载器\">类加载器<a href=\"#类加载器\" title=\"类加载器\"></a></h2><ul><li><p><code>BootstrapClassLoader</code></p><p>由C实现</p></li><li><p><code>ExtensionClassLoader</code></p><p>由java实现，继承于<code>ClassLoader</code></p></li><li><p><code>ApplicationClassLoader</code></p><p>由java实现，继承于<code>ClassLoader</code></p></li><li><p>自定义加载器</p><p>必须继承<code>ClassLoader</code>，默认父加载器为<code>ApplicationClassLoader</code>，可通过重写构造器自定义父加载器</p><p>源码中给出的Demo</p></li></ul><p><strong>注意：有层级关系，相互没有继承关系</strong></p>\n<h3 id=\"双亲委派模型\">双亲委派模型<a href=\"#双亲委派模型\" title=\"双亲委派模型\"></a></h3><p>简单来说，一个类似于“android中的事件分发的流程”</p>\n<p>加载类时依次向上层层调用，请求上层查找并加载，若上层不能查找或者加载到，自己加载或者查找</p>\n<p><code>java.lang.ClassLoader.java</code>加载类关键代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"keyword\">boolean</span> resolve) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>.getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; c = <span class=\"keyword\">this</span>.findLoadedClass(name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> t0 = System.nanoTime();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//判断父加载器是否为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//有，则优先调用父加载器的loadClass加载方法，层层调用</span></span><br><span class=\"line\">                    <span class=\"comment\">//上面一层的也会这样要父加载器加载</span></span><br><span class=\"line\">                    c = <span class=\"keyword\">this</span>.parent.loadClass(name, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//父加载器为空，则使用启动类加载器来加载</span></span><br><span class=\"line\">                    c = <span class=\"keyword\">this</span>.findBootstrapClassOrNull(name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException var10) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//判断c是否为空</span></span><br><span class=\"line\">            <span class=\"comment\">//为空？表示当前类加载器的所有上层加载器都不能找到或者加载此类</span></span><br><span class=\"line\">            <span class=\"comment\">//不为空？表示当前类加载器的某个上层加载器已经找到或者加载此类，并返回了Class对象</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> t1 = System.nanoTime();</span><br><span class=\"line\">                c = <span class=\"keyword\">this</span>.findClass(name);</span><br><span class=\"line\">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class=\"line\">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.resolveClass(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"优点\">优点<a href=\"#优点\" title=\"优点\"></a></h3><ul><li><p>避免类的重复加载</p></li><li><p>保护程序安全，防止核心API随意篡改</p><blockquote><p>如何保护？例如：自定义类:java.lang. String</p><p>自己建一个全类名跟String一样的类，如果这个类在java中的String类之前被加载，那么Java Api中的String会被我这个String替换，并且不再加载java自己的String。</p></blockquote></li></ul><h2 id=\"加载时机\">加载时机<a href=\"#加载时机\" title=\"加载时机\"></a></h2><h3 id=\"必须要有类去主动使用该-class。\">必须要有类去主动使用该 Class。<a href=\"#必须要有类去主动使用该-class。\" title=\"必须要有类去主动使用该 Class。\"></a></h3><ul><li>使用 new 关键字、反射、克隆、反序列化；</li><li>调用类的静态方法</li><li>调用一个类的子类的时候会初始化其父类</li><li>包含 main() 方法的类（相当于第二条）。</li></ul><h3 id=\"被动使用则不会去装载-class。\">被动使用则不会去装载 Class。<a href=\"#被动使用则不会去装载-class。\" title=\"被动使用则不会去装载 Class。\"></a></h3><ul><li><p>调用了其父类的静态方法</p></li></ul><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">        Class mClass = classLoader.loadClass(<span class=\"string\">\"People\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出：</span><br><span class=\"line\">People</span><br></pre></td></tr></table></figure><p>静态代码块没有执行，说明此时<cinit>方法还没有被调用，说明只加载没有初始化，原因在哪？</cinit></p>\n<p><code>java.lang.ClassLoader#loadClass(java.lang.String, boolean)</code>，这个方法的第二个参数，就是控制链接的默认调用<code>loadClass</code>传入的时false，如果传入true最后会调用native方法进行链接</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class&lt;?&gt; loadClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loadClass(name, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"既加载又初始化\">既加载又初始化<a href=\"#既加载又初始化\" title=\"既加载又初始化\"></a></h2><p>上面举了很多例子，我们看一个关键的</p>\n<p>还是下面这一些代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"PeopleLoad\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">        Class.forName(<span class=\"string\">\"People\"</span>, <span class=\"keyword\">true</span>, classLoader);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出：</span><br><span class=\"line\">PeopleLoad</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"类加载流程\">类加载流程<a href=\"#类加载流程\" title=\"类加载流程\"></a></h2><p><strong>链接和加载时并行的，没有谁先再后的先后顺序，涉及到源码中对链接的方法的调用</strong></p>\n<h3 id=\"加载\">加载<a href=\"#加载\" title=\"加载\"></a></h3><p>”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：</p>\n<ul><li>通过一个类的全限定名来获取其定义的二进制字节流</li><li>将这个字节流所代表的的<strong>静态存储结构</strong>转化为<strong>方法区</strong>中的<strong>运行时数据结构</strong>（初始化）</li><li>在<strong>堆</strong>中生成一个代表这个类的Class对象，作为<strong>方法区</strong>中这些数据的访问入口。</li></ul><p>至于JVM的内存管理和分区结构大致是以下</p>\n<p>相对于类加载的其他阶段而言，加载阶段是<strong>可控性最强</strong>的阶段，因为程序员可以使用系统的类加载器加载，还可以使用自己的类加载器加载（从网络，本地，或者任意地方加载字节码文件）。</p>\n<p><strong>类加载器的作用就是上面虚拟机需要完成的三件事，我们定义的类加载器也是一样</strong></p>\n<h3 id=\"链接\">链接<a href=\"#链接\" title=\"链接\"></a></h3><ul><li><p>验证</p><p>保证格式正确，符合java语法规范，不会对<code>jvm</code>造成危害</p><ul><li>文件格式验证，是否符合class文件的格式的规范</li><li><strong>元数据</strong>验证，对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求</li><li>字节码验证，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证，发生在<strong>虚拟机将符号引用转化为直接引用</strong>的时候。主要是对类自身以外的信息进行校验。目的是<strong>确保解析动作能够完成</strong>。</li></ul></li><li><p>准备</p><p>准备类变量（静态变量），赋默认值</p></li><li><p>解析</p><p>解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。什么是符号应用和直接引用呢？</p><ul><li><p>符号引用：</p><p>以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）</p></li><li><p>直接引用：</p><p>是可以指向目标的<strong>指针</strong>、<strong>相对偏移量</strong>或者是<strong>一个能直接或间接定位到目标的句柄</strong>。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。解析动作主要针对<strong>类或接口</strong>、<strong>字段</strong>、<strong>类方法</strong>、<strong>接口方法</strong>、<strong>方法类型</strong>、<strong>方法句柄</strong>和<strong>调用点限定符</strong>7类符号引用进行。</p></li></ul></li></ul><h3 id=\"初始化\">初始化<a href=\"#初始化\" title=\"初始化\"></a></h3><p>执行类构造器<cinit></cinit></p>\n<ul><li><p>有父类，但是父类还没有被初始化先执行父类的初始化</p><blockquote></blockquote></li><li><p>同一个命名空间只会初始化一次</p><blockquote><p>类加载器的<strong>命名空间</strong>是由类加载器<strong>本身以及所有父加载器</strong>所加载出来的<code>binary name</code>(<code>full class name</code>)组成.</p><ul><li>在同一个命名空间里，不允许出现二个完全-样的<code>binary name</code>。</li><li>在不同的命名空间种，可以出现二个相同的<code>binary name</code>。当时二者对应的Class对象是相互不能感知到的，也就是说Class对象的类型是不一样的。</li><li>子加载器的命名空间中的binary name对应的类中可以访问父加载器命名空间中<code>binary name</code>对应的类，反之不行</li></ul></blockquote></li></ul><h3 id=\"两个重要的init方法\">两个重要的init方法<a href=\"#两个重要的init方法\" title=\"两个重要的init方法\"></a></h3><h4 id=\"init\">init<a href=\"#init\" title=\"init\"></a></h4><p>是instance实例构造器，对非静态变量解析初始化</p>\n<h4 id=\"clinit\"><strong>clinit</strong><a href=\"#clinit\" title=\"clinit\"></a></h4><p>是class类构造器对静态变量，静态代码块进行初始化</p>\n<p>方法是由编译器<strong>自动收集类中的所有类变量的赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，</p>\n<p>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不可以使用，会报非法前置引用的错误。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    a = <span class=\"number\">0</span>;<span class=\"comment\">//可以，因为在链接中的准备阶段就已经准备好了这个变量，这里相当于重新赋值</span></span><br><span class=\"line\">    System.out.println(a);<span class=\"comment\">//不可以，会被提示非法前置引用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;<span class=\"comment\">//真正对程序员所期望的初始值进行初始化</span></span><br></pre></td></tr></table></figure><h3 id=\"相关例子\">相关例子<a href=\"#相关例子\" title=\"相关例子\"></a></h3><h4 id=\"经典面试题\">经典面试题<a href=\"#经典面试题\" title=\"经典面试题\"></a></h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Person instance = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    Person()&#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">        b++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Person person = Person.instance;</span><br><span class=\"line\">        System.out.println(Person.a);</span><br><span class=\"line\">        System.out.println(Person.b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">************************************</span><br><span class=\"line\">输出：</span><br><span class=\"line\">    <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"number\">1</span></span><br><span class=\"line\">************************************</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  将Person类中的</span></span><br><span class=\"line\"><span class=\"comment\">*  static Person instance = new Person();</span></span><br><span class=\"line\"><span class=\"comment\">*  提到最前面</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Person instance = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    Person()&#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">        b++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Person person = Person.instance;</span><br><span class=\"line\">        System.out.println(Person.a);</span><br><span class=\"line\">        System.out.println(Person.b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">************************************</span><br><span class=\"line\">输出：</span><br><span class=\"line\">    <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"number\">0</span></span><br><span class=\"line\">************************************</span><br></pre></td></tr></table></figure><p><strong>原因：</strong></p>\n<p>原因在准备</p>\n<h2 id=\"类加载器\">类加载器<a href=\"#类加载器\" title=\"类加载器\"></a></h2><ul><li><p><code>BootstrapClassLoader</code></p><p>由C实现</p></li><li><p><code>ExtensionClassLoader</code></p><p>由java实现，继承于<code>ClassLoader</code></p></li><li><p><code>ApplicationClassLoader</code></p><p>由java实现，继承于<code>ClassLoader</code></p></li><li><p>自定义加载器</p><p>必须继承<code>ClassLoader</code>，默认父加载器为<code>ApplicationClassLoader</code>，可通过重写构造器自定义父加载器</p><p>源码中给出的Demo</p></li></ul><p><strong>注意：有层级关系，相互没有继承关系</strong></p>\n<h3 id=\"双亲委派模型\">双亲委派模型<a href=\"#双亲委派模型\" title=\"双亲委派模型\"></a></h3><p>简单来说，一个类似于“android中的事件分发的流程”</p>\n<p>加载类时依次向上层层调用，请求上层查找并加载，若上层不能查找或者加载到，自己加载或者查找</p>\n<p><code>java.lang.ClassLoader.java</code>加载类关键代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"keyword\">boolean</span> resolve) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>.getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; c = <span class=\"keyword\">this</span>.findLoadedClass(name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> t0 = System.nanoTime();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//判断父加载器是否为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//有，则优先调用父加载器的loadClass加载方法，层层调用</span></span><br><span class=\"line\">                    <span class=\"comment\">//上面一层的也会这样要父加载器加载</span></span><br><span class=\"line\">                    c = <span class=\"keyword\">this</span>.parent.loadClass(name, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//父加载器为空，则使用启动类加载器来加载</span></span><br><span class=\"line\">                    c = <span class=\"keyword\">this</span>.findBootstrapClassOrNull(name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException var10) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//判断c是否为空</span></span><br><span class=\"line\">            <span class=\"comment\">//为空？表示当前类加载器的所有上层加载器都不能找到或者加载此类</span></span><br><span class=\"line\">            <span class=\"comment\">//不为空？表示当前类加载器的某个上层加载器已经找到或者加载此类，并返回了Class对象</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> t1 = System.nanoTime();</span><br><span class=\"line\">                c = <span class=\"keyword\">this</span>.findClass(name);</span><br><span class=\"line\">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class=\"line\">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.resolveClass(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"优点\">优点<a href=\"#优点\" title=\"优点\"></a></h3><ul><li><p>避免类的重复加载</p></li><li><p>保护程序安全，防止核心API随意篡改</p><blockquote><p>如何保护？例如：自定义类:java.lang. String</p><p>自己建一个全类名跟String一样的类，如果这个类在java中的String类之前被加载，那么Java Api中的String会被我这个String替换，并且不再加载java自己的String。</p></blockquote></li></ul><h2 id=\"加载时机\">加载时机<a href=\"#加载时机\" title=\"加载时机\"></a></h2><h3 id=\"必须要有类去主动使用该-class。\">必须要有类去主动使用该 Class。<a href=\"#必须要有类去主动使用该-class。\" title=\"必须要有类去主动使用该 Class。\"></a></h3><ul><li>使用 new 关键字、反射、克隆、反序列化；</li><li>调用类的静态方法</li><li>调用一个类的子类的时候会初始化其父类</li><li>包含 main() 方法的类（相当于第二条）。</li></ul><h3 id=\"被动使用则不会去装载-class。\">被动使用则不会去装载 Class。<a href=\"#被动使用则不会去装载-class。\" title=\"被动使用则不会去装载 Class。\"></a></h3><ul><li><p>调用了其父类的静态方法</p></li></ul><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">        Class mClass = classLoader.loadClass(<span class=\"string\">\"People\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出：</span><br><span class=\"line\">People</span><br></pre></td></tr></table></figure><p>静态代码块没有执行，说明此时<cinit>方法还没有被调用，说明只加载没有初始化，原因在哪？</cinit></p>\n<p><code>java.lang.ClassLoader#loadClass(java.lang.String, boolean)</code>，这个方法的第二个参数，就是控制链接的默认调用<code>loadClass</code>传入的时false，如果传入true最后会调用native方法进行链接</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class&lt;?&gt; loadClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loadClass(name, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"既加载又初始化\">既加载又初始化<a href=\"#既加载又初始化\" title=\"既加载又初始化\"></a></h2><p>上面举了很多例子，我们看一个关键的</p>\n<p>还是下面这一些代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"PeopleLoad\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">        Class.forName(<span class=\"string\">\"People\"</span>, <span class=\"keyword\">true</span>, classLoader);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出：</span><br><span class=\"line\">PeopleLoad</span><br></pre></td></tr></table></figure>","date_formatted":{"ll":"Apr 1, 2020","L":"04/01/2020","MM-DD":"04-01"},"plink":"https://treeeeeeee.github.io/2020/04/01/类加载和类加载器/","type":"post","toc":[{"id":"类加载流程","title":"类加载流程","index":"1","children":[{"id":"加载","title":"加载","index":"1.1"},{"id":"链接","title":"链接","index":"1.2"},{"id":"初始化","title":"初始化","index":"1.3"},{"id":"两个重要的init方法","title":"两个重要的init方法","index":"1.4"},{"id":"相关例子","title":"相关例子","index":"1.5"}]},{"id":"类加载器","title":"类加载器","index":"2","children":[{"id":"双亲委派模型","title":"双亲委派模型","index":"2.1"},{"id":"优点","title":"优点","index":"2.2"}]},{"id":"加载时机","title":"加载时机","index":"3","children":[{"id":"必须要有类去主动使用该-class。","title":"必须要有类去主动使用该 Class。","index":"3.1"},{"id":"被动使用则不会去装载-class。","title":"被动使用则不会去装载 Class。","index":"3.2"}]},{"id":"既加载又初始化","title":"既加载又初始化","index":"4"}]}],"PostAsset":[{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/Screenshot.png","slug":"Screenshot.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/github.png","slug":"github.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/基于酷q平台的管理机器人/导包.png","slug":"导包.png","post":"ck8jl8qix0018w0w0fj8v8299","modified":0,"renderable":0},{"_id":"source/_posts/hexo下完美插入图片/TIM截图20191230113452.png","slug":"TIM截图20191230113452.png","post":"ck8jl8qii000mw0w04dtucawd","modified":0,"renderable":0},{"_id":"source/_posts/idea条件断点/image-20191107003330787.png","slug":"image-20191107003330787.png","post":"ck8jl8qij000ow0w058ulge4l","modified":0,"renderable":0},{"_id":"source/_posts/深入理解volatile和并发编程的三大特性/2615789-8c0b960a27af28db.webp","slug":"2615789-8c0b960a27af28db.webp","post":"ck8jl8qj2001ew0w0drev2ga0","modified":0,"renderable":0},{"_id":"source/_posts/当Activity异常销毁FragmentManager做了什么/image-20200327042035621.png","slug":"image-20200327042035621.png","post":"ck8jl8qj8001gw0w05rrtak60","modified":0,"renderable":0},{"_id":"source/_posts/当Activity异常销毁FragmentManager做了什么/v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg","slug":"v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg","post":"ck8jl8qj8001gw0w05rrtak60","modified":0,"renderable":0},{"_id":"source/_posts/当Activity异常销毁FragmentManager做了什么/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg","slug":"v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg","post":"ck8jl8qj8001gw0w05rrtak60","modified":0,"renderable":0},{"_id":"source/_posts/JVM-内存管理和垃圾回收/局部变量表 (1).png","slug":"局部变量表 (1).png","post":"ck8jl8qhm0001w0w0d5om8qno","modified":0,"renderable":0},{"_id":"source/_posts/JVM-内存管理和垃圾回收/局部变量表.png","slug":"局部变量表.png","post":"ck8jl8qhm0001w0w0d5om8qno","modified":0,"renderable":0},{"_id":"source/_posts/基于酷q平台的管理机器人/idea新建项目.png","slug":"idea新建项目.png","post":"ck8jl8qix0018w0w0fj8v8299","modified":0,"renderable":0},{"_id":"source/_posts/基于酷q平台的管理机器人/image-20191113001251371.png","slug":"image-20191113001251371.png","post":"ck8jl8qix0018w0w0fj8v8299","modified":0,"renderable":0},{"_id":"source/_posts/基于酷q平台的管理机器人/补登请假.jpg","slug":"补登请假.jpg","post":"ck8jl8qix0018w0w0fj8v8299","modified":0,"renderable":0},{"_id":"source/_posts/基于酷q平台的管理机器人/请假.jpg","slug":"请假.jpg","post":"ck8jl8qix0018w0w0fj8v8299","modified":0,"renderable":0},{"_id":"source/_posts/基于酷q平台的管理机器人/请假文档.jpg","slug":"请假文档.jpg","post":"ck8jl8qix0018w0w0fj8v8299","modified":0,"renderable":0},{"_id":"source/_posts/基于酷q平台的管理机器人/通知.jpg","slug":"通知.jpg","post":"ck8jl8qix0018w0w0fj8v8299","modified":0,"renderable":0},{"_id":"source/_posts/基于酷q平台的管理机器人/酷q配置坏境的注意事项.jpg","slug":"酷q配置坏境的注意事项.jpg","post":"ck8jl8qix0018w0w0fj8v8299","modified":0,"renderable":0},{"_id":"source/_posts/Android消息机制深入了解/QQ20200308-1.png","slug":"QQ20200308-1.png","post":"ck8jl8qhb0000w0w05tpl8g88","modified":0,"renderable":0},{"_id":"source/_posts/Android消息机制深入了解/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg","slug":"v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg","post":"ck8jl8qhb0000w0w05tpl8g88","modified":0,"renderable":0},{"_id":"source/_posts/Android消息机制深入了解/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg","slug":"v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg","post":"ck8jl8qhb0000w0w05tpl8g88","modified":0,"renderable":0},{"_id":"source/_posts/Android消息机制深入了解/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg","slug":"v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg","post":"ck8jl8qhb0000w0w05tpl8g88","modified":0,"renderable":0},{"_id":"source/_posts/Android消息机制深入了解/v2-639605533bdb1ecf1c6562677a430554_hd.jpg","slug":"v2-639605533bdb1ecf1c6562677a430554_hd.jpg","post":"ck8jl8qhb0000w0w05tpl8g88","modified":0,"renderable":0},{"_id":"source/_posts/Android消息机制深入了解/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg","slug":"v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg","post":"ck8jl8qhb0000w0w05tpl8g88","modified":0,"renderable":0},{"_id":"source/_posts/Android消息机制深入了解/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg","slug":"v2-790d03f584a1de8717e02e56547e38ca_hd.jpg","post":"ck8jl8qhb0000w0w05tpl8g88","modified":0,"renderable":0},{"_id":"source/_posts/Android消息机制深入了解/v2-8312b637ba6407992515ffa42b56391d_hd-3736965.jpg","slug":"v2-8312b637ba6407992515ffa42b56391d_hd-3736965.jpg","post":"ck8jl8qhb0000w0w05tpl8g88","modified":0,"renderable":0},{"_id":"source/_posts/Android消息机制深入了解/v2-8312b637ba6407992515ffa42b56391d_hd.jpg","slug":"v2-8312b637ba6407992515ffa42b56391d_hd.jpg","post":"ck8jl8qhb0000w0w05tpl8g88","modified":0,"renderable":0},{"_id":"source/_posts/Android消息机制深入了解/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg","slug":"v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg","post":"ck8jl8qhb0000w0w05tpl8g88","modified":0,"renderable":0},{"_id":"source/_posts/Android消息机制深入了解/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg","slug":"v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg","post":"ck8jl8qhb0000w0w05tpl8g88","modified":0,"renderable":0},{"_id":"source/_posts/Android消息机制深入了解/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg","slug":"v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg","post":"ck8jl8qhb0000w0w05tpl8g88","modified":0,"renderable":0},{"_id":"source/_posts/Android消息机制深入了解/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg","slug":"v2-ee07600d1fc49257fb502f869bb97264_hd.jpg","post":"ck8jl8qhb0000w0w05tpl8g88","modified":0,"renderable":0},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/006szvLFgy1fwll8fpyzdj30b407dq5d.jpg","slug":"006szvLFgy1fwll8fpyzdj30b407dq5d.jpg","post":"ck8jl8qi7000bw0w0gl758ye2","modified":0,"renderable":0},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/2429e4d2661e60027537aea0077f6e40.png","slug":"2429e4d2661e60027537aea0077f6e40.png","post":"ck8jl8qi7000bw0w0gl758ye2","modified":0,"renderable":0},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023163526.png","slug":"TIM截图20191023163526.png","post":"ck8jl8qi7000bw0w0gl758ye2","modified":0,"renderable":0},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023163817.png","slug":"TIM截图20191023163817.png","post":"ck8jl8qi7000bw0w0gl758ye2","modified":0,"renderable":0},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023165925.png","slug":"TIM截图20191023165925.png","post":"ck8jl8qi7000bw0w0gl758ye2","modified":0,"renderable":0},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023170652.png","slug":"TIM截图20191023170652.png","post":"ck8jl8qi7000bw0w0gl758ye2","modified":0,"renderable":0},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023170946.png","slug":"TIM截图20191023170946.png","post":"ck8jl8qi7000bw0w0gl758ye2","modified":0,"renderable":0},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023171200.png","slug":"TIM截图20191023171200.png","post":"ck8jl8qi7000bw0w0gl758ye2","modified":0,"renderable":0},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023171820.png","slug":"TIM截图20191023171820.png","post":"ck8jl8qi7000bw0w0gl758ye2","modified":0,"renderable":0},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023172756.png","slug":"TIM截图20191023172756.png","post":"ck8jl8qi7000bw0w0gl758ye2","modified":0,"renderable":0},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023173110.png","slug":"TIM截图20191023173110.png","post":"ck8jl8qi7000bw0w0gl758ye2","modified":0,"renderable":0},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023175603.png","slug":"TIM截图20191023175603.png","post":"ck8jl8qi7000bw0w0gl758ye2","modified":0,"renderable":0},{"_id":"source/_posts/git常用命令以及如何在idea上可视化操作git/TIM截图20191023175637.png","slug":"TIM截图20191023175637.png","post":"ck8jl8qi7000bw0w0gl758ye2","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/138-1570101275882.png","slug":"138-1570101275882.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/138.png","slug":"138.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/2.png","slug":"2.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/3.png","slug":"3.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM图片20191003174050.png","slug":"TIM图片20191003174050.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003175326.png","slug":"TIM截图20191003175326.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003180656.png","slug":"TIM截图20191003180656.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003180755.png","slug":"TIM截图20191003180755.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003183937.png","slug":"TIM截图20191003183937.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003184214.png","slug":"TIM截图20191003184214.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/TIM截图20191003184704.png","slug":"TIM截图20191003184704.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/m.png","slug":"m.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/new p.png","slug":"new p.png","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/nh-pluto-moonlight-1570101277085.jpg","slug":"nh-pluto-moonlight-1570101277085.jpg","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/nh-pluto-moonlight.jpg","slug":"nh-pluto-moonlight.jpg","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/v2-7461124ec772f6fe453d07554cb11363_hd.jpg","slug":"v2-7461124ec772f6fe453d07554cb11363_hd.jpg","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/v2-8125794bbf0055917b820178489c7b0f_hd.jpg","slug":"v2-8125794bbf0055917b820178489c7b0f_hd.jpg","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/v2-d2681a4830e54238450b6dc2a57d0c55_hd.jpg","slug":"v2-d2681a4830e54238450b6dc2a57d0c55_hd.jpg","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/hexo-admin-windows-服务器的综合博客平台/v2-e11377329d5cef129c0aefd10eaa1607_hd.jpg","slug":"v2-e11377329d5cef129c0aefd10eaa1607_hd.jpg","post":"ck8jl8qie000iw0w07fea5wuf","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/006APoFYjw1fbaq3q6p2xj304j050weh.jpg","slug":"006APoFYjw1fbaq3q6p2xj304j050weh.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/006APoFYjw1fbw78x1kr4g308c08caa2-1571887367591.gif","slug":"006APoFYjw1fbw78x1kr4g308c08caa2-1571887367591.gif","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/006APoFYjw1fbw78x1kr4g308c08caa2.gif","slug":"006APoFYjw1fbw78x1kr4g308c08caa2.gif","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/006szvLFgy1fwll8fpyzdj30b407dq5d.jpg","slug":"006szvLFgy1fwll8fpyzdj30b407dq5d.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/1569997947464.png","slug":"1569997947464.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/1571820564925.jpeg","slug":"1571820564925.jpeg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/1571820567750.jpeg","slug":"1571820567750.jpeg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/164336559DA3C001F7D365CBC0A67998.jpg","slug":"164336559DA3C001F7D365CBC0A67998.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/2429e4d2661e60027537aea0077f6e40.png","slug":"2429e4d2661e60027537aea0077f6e40.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/415f82b9ly1fpg6be2pudj20c8096759.jpg","slug":"415f82b9ly1fpg6be2pudj20c8096759.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/6af89bc8gw1f8tzg6lig0g209m073x6p.gif","slug":"6af89bc8gw1f8tzg6lig0g209m073x6p.gif","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/6af89bc8gw1f8tzvsvn8gj20a00a00tp.jpg","slug":"6af89bc8gw1f8tzvsvn8gj20a00a00tp.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/9150e4e5gy1g19qh568dmj206o06ogll.jpg","slug":"9150e4e5gy1g19qh568dmj206o06ogll.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/9150e4e5gy1g6o895cawsj20sg0sg76j.jpg","slug":"9150e4e5gy1g6o895cawsj20sg0sg76j.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/9150e4e5ly1fd7l5931vij202201u3ya.jpg","slug":"9150e4e5ly1fd7l5931vij202201u3ya.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191022120614.png","slug":"TIM截图20191022120614.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023152825.png","slug":"TIM截图20191023152825.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023152930.png","slug":"TIM截图20191023152930.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023163526.png","slug":"TIM截图20191023163526.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023163817.png","slug":"TIM截图20191023163817.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023165925.png","slug":"TIM截图20191023165925.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023170542.png","slug":"TIM截图20191023170542.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023170652.png","slug":"TIM截图20191023170652.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023170946.png","slug":"TIM截图20191023170946.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023171200.png","slug":"TIM截图20191023171200.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023171820.png","slug":"TIM截图20191023171820.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023172756.png","slug":"TIM截图20191023172756.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023173110.png","slug":"TIM截图20191023173110.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023175603.png","slug":"TIM截图20191023175603.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191023175637.png","slug":"TIM截图20191023175637.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191024013553.png","slug":"TIM截图20191024013553.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191024014025.png","slug":"TIM截图20191024014025.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/TIM截图20191024021220.png","slug":"TIM截图20191024021220.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/ceeb653ejw1fai8r9ct23j205c05q3yn.jpg","slug":"ceeb653ejw1fai8r9ct23j205c05q3yn.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/ceeb653ejw1faoq48816nj208z0buaan.jpg","slug":"ceeb653ejw1faoq48816nj208z0buaan.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/d.png","slug":"d.png","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-02ffe126c98c17d03a83adad5f65938b_hd.jpg","slug":"v2-02ffe126c98c17d03a83adad5f65938b_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-05aa749d19004c9fea98e84fcea3307f_hd.jpg","slug":"v2-05aa749d19004c9fea98e84fcea3307f_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-0bc6bbbfcf6d855c832b055aae892f1a_hd.jpg","slug":"v2-0bc6bbbfcf6d855c832b055aae892f1a_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-114ee3caaad0d612d39818c9f3f81201_hd.jpg","slug":"v2-114ee3caaad0d612d39818c9f3f81201_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-13d572e979351e77f984cd5b38a019b3_hd.jpg","slug":"v2-13d572e979351e77f984cd5b38a019b3_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-1a566b02828b4759584f5a5e6fee2903_hd.jpg","slug":"v2-1a566b02828b4759584f5a5e6fee2903_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-23b4f1f3873f02b9e9abd2d1ab30a73f_hd.jpg","slug":"v2-23b4f1f3873f02b9e9abd2d1ab30a73f_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-24c27adb48dfeffc6de36260df10bad5_hd.jpg","slug":"v2-24c27adb48dfeffc6de36260df10bad5_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-2b4d1f67bd8f8aaecb32920c58cd687c_hd.jpg","slug":"v2-2b4d1f67bd8f8aaecb32920c58cd687c_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg","slug":"v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd-1571843439577.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd.jpg","slug":"v2-2f4c1f2a5eb83e1368364c9a87aa258c_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-308d4b287931127b020ac4cc861a1757_hd-1571838917313.jpg","slug":"v2-308d4b287931127b020ac4cc861a1757_hd-1571838917313.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg","slug":"v2-308d4b287931127b020ac4cc861a1757_hd-1571843355924.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-308d4b287931127b020ac4cc861a1757_hd.jpg","slug":"v2-308d4b287931127b020ac4cc861a1757_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-325a1104a87fafd601284c628fa6aea9_hd.jpg","slug":"v2-325a1104a87fafd601284c628fa6aea9_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-32be84269f9e3bc3722df3635792a959_hd.jpg","slug":"v2-32be84269f9e3bc3722df3635792a959_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-32db3eeb7c9cb282553504e2c1108130_hd.jpg","slug":"v2-32db3eeb7c9cb282553504e2c1108130_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-45a9abdf48e6be17cb8d9e31b53578f9_hd.jpg","slug":"v2-45a9abdf48e6be17cb8d9e31b53578f9_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-45b057e23dd633692fb0154f4a09ca49_hd.jpg","slug":"v2-45b057e23dd633692fb0154f4a09ca49_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-4d0519e265a57a53b7f92599fce86a9c_hd.jpg","slug":"v2-4d0519e265a57a53b7f92599fce86a9c_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg","slug":"v2-4d2cb53368cc8b322c3075d23d1e0c34_hd-1571843599481.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-4d2cb53368cc8b322c3075d23d1e0c34_hd.jpg","slug":"v2-4d2cb53368cc8b322c3075d23d1e0c34_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-52943cfec07e50eccbe2b6f6e4c7afcb_hd.jpg","slug":"v2-52943cfec07e50eccbe2b6f6e4c7afcb_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-53ac2d7b9f62a8ff17b795cc73570734_hd.jpg","slug":"v2-53ac2d7b9f62a8ff17b795cc73570734_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg","slug":"v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd-1571843375376.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd.jpg","slug":"v2-56d8e6cc72c947ee95df5a1a7bff9fc2_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg","slug":"v2-5f1a5d4ebb5a0c3d2751ee342dd09d71_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-61c75070123da9b76126716abb4c0dc0_hd-1571843419436.jpg","slug":"v2-61c75070123da9b76126716abb4c0dc0_hd-1571843419436.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-61c75070123da9b76126716abb4c0dc0_hd.jpg","slug":"v2-61c75070123da9b76126716abb4c0dc0_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-621e04e365e7d4a385575811df365d92_hd.jpg","slug":"v2-621e04e365e7d4a385575811df365d92_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-639605533bdb1ecf1c6562677a430554_hd.jpg","slug":"v2-639605533bdb1ecf1c6562677a430554_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg","slug":"v2-70cd1cce150de4d7c1c80c6fea270ec3_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-71abcc971fa6b70a60fed90756317c19_hd.jpg","slug":"v2-71abcc971fa6b70a60fed90756317c19_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-72c27a074e1feb699849c4d9d8c2614c_hd.jpg","slug":"v2-72c27a074e1feb699849c4d9d8c2614c_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-746b68b4c2149a0faef9f4ec9a4e8e92_hd.jpg","slug":"v2-746b68b4c2149a0faef9f4ec9a4e8e92_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-75af770ceb10d0dcfbf702142f5c625b_hd.jpg","slug":"v2-75af770ceb10d0dcfbf702142f5c625b_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-790d03f584a1de8717e02e56547e38ca_hd.jpg","slug":"v2-790d03f584a1de8717e02e56547e38ca_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-7a637419db11fb84c062b0361a4045db_hd.jpg","slug":"v2-7a637419db11fb84c062b0361a4045db_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-7e64adbe12f97ac1fb00fc17d7d72f28_hd.jpg","slug":"v2-7e64adbe12f97ac1fb00fc17d7d72f28_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-81940f37a0165b0459cb03241922e3ee_hd.jpg","slug":"v2-81940f37a0165b0459cb03241922e3ee_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-8312b637ba6407992515ffa42b56391d_hd.jpg","slug":"v2-8312b637ba6407992515ffa42b56391d_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-87072b9873cd5e8703a473b191e17042_hd.jpg","slug":"v2-87072b9873cd5e8703a473b191e17042_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-8a2e689837fdbbbf4b1ab294f9b8dd1e_hd.jpg","slug":"v2-8a2e689837fdbbbf4b1ab294f9b8dd1e_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-8c6c3bde98e8cf206839bf57085af02e_hd.jpg","slug":"v2-8c6c3bde98e8cf206839bf57085af02e_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-8d05da004dc65b91ffa63dcc213b7714_hd.jpg","slug":"v2-8d05da004dc65b91ffa63dcc213b7714_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-8da4b48b8262d2786486cb942571be4c_hd.jpg","slug":"v2-8da4b48b8262d2786486cb942571be4c_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-99e68ddacf27251a57bfffc82a43a2a0_hd.jpg","slug":"v2-99e68ddacf27251a57bfffc82a43a2a0_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg","slug":"v2-9e6c67c00b10fe66487bdac67d1642e5_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-a11eadf17f85c2caef8ac2e391d0cf69_hd.jpg","slug":"v2-a11eadf17f85c2caef8ac2e391d0cf69_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg","slug":"v2-a636ef3559b5600fdbaaf48cf794f5e4_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-a67b056f65147bc9971073f6b23d2aa3_hd.jpg","slug":"v2-a67b056f65147bc9971073f6b23d2aa3_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-a959fa53966fc0b6400f88c50b8b95e3_hd.jpg","slug":"v2-a959fa53966fc0b6400f88c50b8b95e3_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-aafe63145f01d7c98b9ca567484a2dea_hd.jpg","slug":"v2-aafe63145f01d7c98b9ca567484a2dea_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-acb2c980db4a235ed0538f34d9c2918d_hd-1571748707404.jpg","slug":"v2-acb2c980db4a235ed0538f34d9c2918d_hd-1571748707404.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-acb2c980db4a235ed0538f34d9c2918d_hd.jpg","slug":"v2-acb2c980db4a235ed0538f34d9c2918d_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-afd6a92d4313b460829bf99b7ef3759e_hd.jpg","slug":"v2-afd6a92d4313b460829bf99b7ef3759e_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-bc2e4a10498c1b64a01628d0df373856_hd.jpg","slug":"v2-bc2e4a10498c1b64a01628d0df373856_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-bdb493d4a6d79ffa93fe78c71a2fd1a8_hd.jpg","slug":"v2-bdb493d4a6d79ffa93fe78c71a2fd1a8_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-bffbbe33c937ceb498d0882bf21a651c_hd.jpg","slug":"v2-bffbbe33c937ceb498d0882bf21a651c_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-c4f54c756177054f05115c55be8058d7_hd.jpg","slug":"v2-c4f54c756177054f05115c55be8058d7_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-c73dbda0a22ac613aa85548743e89311_hd.jpg","slug":"v2-c73dbda0a22ac613aa85548743e89311_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg","slug":"v2-ca9bf81c0e81a09cf4f6dfaacd13ce04_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-cb5372ddead7e3c2bfcbc8e50e5e941f_hd.jpg","slug":"v2-cb5372ddead7e3c2bfcbc8e50e5e941f_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-cf3a3ed1086e56442c381a3ee8a1fee9_hd.jpg","slug":"v2-cf3a3ed1086e56442c381a3ee8a1fee9_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-d238eb952899a0a26dd5b66a36f76c56_hd.jpg","slug":"v2-d238eb952899a0a26dd5b66a36f76c56_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-daba4efa3f71587ad62c168eeb711a01_hd-1571838207875.jpg","slug":"v2-daba4efa3f71587ad62c168eeb711a01_hd-1571838207875.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-daba4efa3f71587ad62c168eeb711a01_hd.jpg","slug":"v2-daba4efa3f71587ad62c168eeb711a01_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-db4581e2b067caef5a9586f7eebdf201_hd-1571838820692.jpg","slug":"v2-db4581e2b067caef5a9586f7eebdf201_hd-1571838820692.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-db4581e2b067caef5a9586f7eebdf201_hd.jpg","slug":"v2-db4581e2b067caef5a9586f7eebdf201_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-e015f2d920aa5e00fa4b25d3b6a79bac_hd.jpg","slug":"v2-e015f2d920aa5e00fa4b25d3b6a79bac_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-e36c4694236b67a6e655c77d0e5336cf_hd.jpg","slug":"v2-e36c4694236b67a6e655c77d0e5336cf_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-e608e1d4f94a6d0c06f9e9b78d5458b5_hd.jpg","slug":"v2-e608e1d4f94a6d0c06f9e9b78d5458b5_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-ea2fa82794080c01e783ce025c450116_hd.jpg","slug":"v2-ea2fa82794080c01e783ce025c450116_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-ec6f0e0dfb5dc6805387101614784dcf_hd.jpg","slug":"v2-ec6f0e0dfb5dc6805387101614784dcf_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-ee07600d1fc49257fb502f869bb97264_hd.jpg","slug":"v2-ee07600d1fc49257fb502f869bb97264_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-f50699afeec4929bdc58d56db811bc47_hd.jpg","slug":"v2-f50699afeec4929bdc58d56db811bc47_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-fdddf30851f4370410c068f923e0c405_hd-1571843588629.jpg","slug":"v2-fdddf30851f4370410c068f923e0c405_hd-1571843588629.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/java面向对象-接口和其他的类/v2-fdddf30851f4370410c068f923e0c405_hd.jpg","slug":"v2-fdddf30851f4370410c068f923e0c405_hd.jpg","post":"ck8jl8qiq000uw0w04u06a8ib","modified":0,"renderable":0},{"_id":"source/_posts/深入理解volatile和并发编程的三大特性/images.webp","slug":"images.webp","post":"ck8jl8qj2001ew0w0drev2ga0","modified":0,"renderable":0},{"_id":"source/_posts/JVM-内存管理和垃圾回收/w.png","slug":"w.png","post":"ck8jl8qhm0001w0w0d5om8qno","modified":0,"renderable":0},{"_id":"source/_posts/JVM-内存管理和垃圾回收/复杂清除算法.svg","slug":"复杂清除算法.svg","post":"ck8jl8qhm0001w0w0d5om8qno","modified":0,"renderable":0},{"_id":"source/_posts/JVM-内存管理和垃圾回收/复制.svg","slug":"复制.svg","post":"ck8jl8qhm0001w0w0d5om8qno","modified":0,"renderable":0},{"_id":"source/_posts/JVM-内存管理和垃圾回收/复制-1585862631136.svg","slug":"复制-1585862631136.svg","post":"ck8jl8qhm0001w0w0d5om8qno","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ck8jl8qhb0000w0w05tpl8g88","category_id":"ck8jl8qhp0002w0w08vlfh6d3","_id":"ck8jl8qi9000cw0w0bdd5eumw"},{"post_id":"ck8jl8qhy0006w0w0blde9y7a","category_id":"ck8jl8qhp0002w0w08vlfh6d3","_id":"ck8jl8qie000gw0w0a1243zo6"},{"post_id":"ck8jl8qhm0001w0w0d5om8qno","category_id":"ck8jl8qhz0007w0w02nn3fdv1","_id":"ck8jl8qih000kw0w0bui742qa"},{"post_id":"ck8jl8qhs0004w0w01xpq3n89","category_id":"ck8jl8qhz0007w0w02nn3fdv1","_id":"ck8jl8qim000pw0w05kxqfib1"},{"post_id":"ck8jl8qhv0005w0w0g0hgcuho","category_id":"ck8jl8qih000jw0w00ut7a7j6","_id":"ck8jl8qir000vw0w0e37x4ni3"},{"post_id":"ck8jl8qij000ow0w058ulge4l","category_id":"ck8jl8qih000jw0w00ut7a7j6","_id":"ck8jl8qit0010w0w09gxde9r6"},{"post_id":"ck8jl8qi2000aw0w0hytl9osg","category_id":"ck8jl8qim000qw0w0bw6791cx","_id":"ck8jl8qiu0013w0w03b1agnkx"},{"post_id":"ck8jl8qi7000bw0w0gl758ye2","category_id":"ck8jl8qir000xw0w060003s0c","_id":"ck8jl8qj0001cw0w07sg6fpq2"},{"post_id":"ck8jl8qid000fw0w0f9czfatd","category_id":"ck8jl8qim000qw0w0bw6791cx","_id":"ck8jl8qj9001hw0w01kl0f3ri"},{"post_id":"ck8jl8qj2001ew0w0drev2ga0","category_id":"ck8jl8qhz0007w0w02nn3fdv1","_id":"ck8jl8qjd001mw0w0528a0f2k"},{"post_id":"ck8jl8qie000iw0w07fea5wuf","category_id":"ck8jl8qiz001bw0w067n5093k","_id":"ck8jl8qjk001qw0w02gh91mvn"},{"post_id":"ck8jl8qj8001gw0w05rrtak60","category_id":"ck8jl8qhp0002w0w08vlfh6d3","_id":"ck8jl8qjm001rw0w0h9xafbt0"},{"post_id":"ck8jl8qjb001kw0w0clxuexst","category_id":"ck8jl8qhz0007w0w02nn3fdv1","_id":"ck8jl8qjn001tw0w09n1jfaki"},{"post_id":"ck8jl8qii000mw0w04dtucawd","category_id":"ck8jl8qiz001bw0w067n5093k","_id":"ck8jl8qjo001ww0w0d1eic2jq"},{"post_id":"ck8jl8qiq000uw0w04u06a8ib","category_id":"ck8jl8qje001nw0w0f6enf28i","_id":"ck8jl8qjq0021w0w04ry77y30"},{"post_id":"ck8jl8qiu0012w0w0emwphil5","category_id":"ck8jl8qjo001xw0w0bujyclbx","_id":"ck8jl8qjs0025w0w01jgmc0jl"},{"post_id":"ck8jl8qiv0014w0w07orverv4","category_id":"ck8jl8qjq0022w0w0e5qx2pac","_id":"ck8jl8qjv0029w0w0d739hv9x"},{"post_id":"ck8jl8qix0018w0w0fj8v8299","category_id":"ck8jl8qiz001bw0w067n5093k","_id":"ck8jl8qjw002cw0w064wgg32y"},{"post_id":"ck8jl8qiy001aw0w003qdfrmf","category_id":"ck8jl8qju0028w0w0fu61cddy","_id":"ck8jl8qjx002hw0w0fqxdhjg8"}],"PostTag":[{"post_id":"ck8jl8qhb0000w0w05tpl8g88","tag_id":"ck8jl8qhs0003w0w01qp75j2m","_id":"ck8jl8qi20009w0w01u956qzg"},{"post_id":"ck8jl8qhm0001w0w0d5om8qno","tag_id":"ck8jl8qi00008w0w04cy6fopw","_id":"ck8jl8qie000hw0w06dft3m2b"},{"post_id":"ck8jl8qhs0004w0w01xpq3n89","tag_id":"ck8jl8qia000ew0w0f8bahfml","_id":"ck8jl8qij000nw0w0ewo3dj83"},{"post_id":"ck8jl8qhv0005w0w0g0hgcuho","tag_id":"ck8jl8qii000lw0w0611i8dbn","_id":"ck8jl8qiq000tw0w0279b9l9y"},{"post_id":"ck8jl8qij000ow0w058ulge4l","tag_id":"ck8jl8qii000lw0w0611i8dbn","_id":"ck8jl8qir000ww0w00ce0fadn"},{"post_id":"ck8jl8qhy0006w0w0blde9y7a","tag_id":"ck8jl8qin000rw0w0d601hu0m","_id":"ck8jl8qit0011w0w0bg749nif"},{"post_id":"ck8jl8qiu0012w0w0emwphil5","tag_id":"ck8jl8qit000zw0w09tns44xx","_id":"ck8jl8qix0017w0w09seo41fr"},{"post_id":"ck8jl8qi2000aw0w0hytl9osg","tag_id":"ck8jl8qit000zw0w09tns44xx","_id":"ck8jl8qiy0019w0w0elt638wa"},{"post_id":"ck8jl8qi7000bw0w0gl758ye2","tag_id":"ck8jl8qiw0016w0w0ae553n0g","_id":"ck8jl8qj8001fw0w00mjsg771"},{"post_id":"ck8jl8qid000fw0w0f9czfatd","tag_id":"ck8jl8qit000zw0w09tns44xx","_id":"ck8jl8qjd001lw0w0dgpycr2h"},{"post_id":"ck8jl8qjb001kw0w0clxuexst","tag_id":"ck8jl8qi00008w0w04cy6fopw","_id":"ck8jl8qjg001ow0w06yzbhwo6"},{"post_id":"ck8jl8qie000iw0w07fea5wuf","tag_id":"ck8jl8qja001jw0w01ad697zx","_id":"ck8jl8qjo001vw0w0dyj3cbxf"},{"post_id":"ck8jl8qie000iw0w07fea5wuf","tag_id":"ck8jl8qjg001pw0w0dg901b0l","_id":"ck8jl8qjo001yw0w0fvogager"},{"post_id":"ck8jl8qii000mw0w04dtucawd","tag_id":"ck8jl8qjn001uw0w06z0421av","_id":"ck8jl8qjp0020w0w0chwba57i"},{"post_id":"ck8jl8qiq000uw0w04u06a8ib","tag_id":"ck8jl8qjr0023w0w05a50f5zg","_id":"ck8jl8qjw002bw0w0axc4b9kc"},{"post_id":"ck8jl8qiq000uw0w04u06a8ib","tag_id":"ck8jl8qju0027w0w036sbaxhh","_id":"ck8jl8qjx002ew0w0h32v0jl4"},{"post_id":"ck8jl8qiv0014w0w07orverv4","tag_id":"ck8jl8qjv002aw0w0fa1xdr6k","_id":"ck8jl8qjx002gw0w04490degh"},{"post_id":"ck8jl8qix0018w0w0fj8v8299","tag_id":"ck8jl8qjx002fw0w0gfh1fj27","_id":"ck8jl8qjy002jw0w04zt4gmhc"},{"post_id":"ck8jl8qiy001aw0w003qdfrmf","tag_id":"ck8jl8qjx002iw0w0449rfi4x","_id":"ck8jl8qk0002nw0w06pug9die"},{"post_id":"ck8jl8qj2001ew0w0drev2ga0","tag_id":"ck8jl8qjz002mw0w0f0fu9xsx","_id":"ck8jl8qk1002pw0w012slbqtr"},{"post_id":"ck8jl8qj8001gw0w05rrtak60","tag_id":"ck8jl8qk0002ow0w0alhp81z3","_id":"ck8jl8qk1002qw0w0e5fp9p9k"}],"Tag":[{"name":"温故知新","_id":"ck8jl8qhs0003w0w01qp75j2m"},{"name":"干货","_id":"ck8jl8qi00008w0w04cy6fopw"},{"name":"备份","_id":"ck8jl8qia000ew0w0f8bahfml"},{"name":"开发工具探索","_id":"ck8jl8qii000lw0w0611i8dbn"},{"name":"归纳总结","_id":"ck8jl8qin000rw0w0d601hu0m"},{"name":"知识就是力量","_id":"ck8jl8qit000zw0w09tns44xx"},{"name":"git常用命令备份","_id":"ck8jl8qiw0016w0w0ae553n0g"},{"name":"踩坑","_id":"ck8jl8qja001jw0w01ad697zx"},{"name":"浪费了大好青春","_id":"ck8jl8qjg001pw0w0dg901b0l"},{"name":"hexo配置","_id":"ck8jl8qjn001uw0w06z0421av"},{"name":"课件附页","_id":"ck8jl8qjp001zw0w06n4y25ph"},{"name":"java","_id":"ck8jl8qjr0023w0w05a50f5zg"},{"name":"课件","_id":"ck8jl8qju0027w0w036sbaxhh"},{"name":"巨坑","_id":"ck8jl8qjv002aw0w0fa1xdr6k"},{"name":"世界这么大，当然要多去看看","_id":"ck8jl8qjx002fw0w0gfh1fj27"},{"name":"记录","_id":"ck8jl8qjx002iw0w0449rfi4x"},{"name":"java并发","_id":"ck8jl8qjz002mw0w0f0fu9xsx"},{"name":"查漏补缺","_id":"ck8jl8qk0002ow0w0alhp81z3"}]}}